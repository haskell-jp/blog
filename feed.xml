<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        
    </author>
    <updated>2025-12-07T00:00:00Z</updated>
    <entry>
    <title>簡単なHaskellのみでServant並に高機能なライブラリーを作ろうとした振り返り</title>
    <link href="https://haskell.jp/blog/posts/2025/wai-sample.html" />
    <id>https://haskell.jp/blog/posts/2025/wai-sample.html</id>
    <published>2025-12-07T00:00:00Z</published>
    <updated>2025-12-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>この記事は<a href="https://qiita.com/advent-calendar/2025/haskell"><span class="ascii">Haskell Advent Calendar 2025</span></a>の<span class="ascii">7</span>日目の記事です。</p>
<p>本日は、「<a href="https://www.youtube.com/playlist?list=PLRVf2pXOpAzJMFN810EWwGrH_qii7DKyn"><span class="ascii">Haskell</span>製ウェブアプリケーションフレームワークを作る配信</a>」で配信していた、<span class="ascii">Haskell</span>製ウェブアプリケーションフレームワークを作るプロジェクトについて振り返ります。<span class="ascii">Servant</span>のような型安全な<span class="ascii">API</span>定義を、<small>（<span class="ascii">Servant</span>のような）</small>高度な型レベルプログラミングも、<small>（<span class="ascii">Yesod</span>のような）</small><span class="ascii">TemplateHaskell</span>もなしに可能にするライブラリーを目指していましたが、開発を途中で止めることにしました。その振り返り — とりわけ、そのゴールに基づいて実装するのが困難だと分かった機能などを中心にまとめます。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#動機" title="動機">動機</a></li>
<li><a href="#できたもの" title="できたもの">できたもの</a>
<ul>
<li><a href="#最も単純な例" title="最も単純な例"><span class="ascii">(1)</span> 最も単純な例</a></li>
<li><a href="#ステータスコードを指定した例" title="ステータスコードを指定した例"><span class="ascii">(2)</span> ステータスコードを指定した例</a></li>
<li><a href="#パスの中に含まれる整数を処理する例" title="パスの中に含まれる整数を処理する例"><span class="ascii">(3)</span> パスの中に含まれる整数を処理する例</a></li>
<li><a href="#content-typeを複数指定する" title="content-typeを複数指定する"><span class="ascii">Content-Type</span>を複数指定する</a></li>
<li><a href="#サーバーアプリケーションとしての使い方" title="サーバーアプリケーションとしての使い方">サーバーアプリケーションとしての使い方</a></li>
<li><a href="#template-haskellによるクライアントの生成" title="template-haskellによるクライアントの生成"><span class="ascii">Template Haskell</span>による、クライアントの生成</a></li>
<li><a href="#ドキュメントの生成" title="ドキュメントの生成">ドキュメントの生成</a></li>
</ul></li>
<li><a href="#何故開発を止めるのか" title="何故開発を止めるのか">何故開発を止めるのか</a>
<ul>
<li><a href="#想定通りにできなかったもの-レスポンスに複数のパターンがあるとき" title="想定通りにできなかったもの-レスポンスに複数のパターンがあるとき">想定通りにできなかったもの<span class="ascii">:</span> レスポンスに複数のパターンがあるとき</a></li>
<li><a href="#パスのパーサー-実はがすでに危ない" title="パスのパーサー-実はがすでに危ない">パスのパーサー<span class="ascii">:</span> 実は<code>&lt;$&gt;</code>がすでに危ない</a></li>
</ul></li>
<li><a href="#実装し切れなかったもの" title="実装し切れなかったもの">実装し切れなかったもの</a></li>
<li><a href="#類似のライブラリー解決策" title="類似のライブラリー解決策">類似のライブラリー・解決策</a>
<ul>
<li><a href="#okapi" title="okapi"><span class="ascii">Okapi</span></a></li>
<li><a href="#ihp" title="ihp"><span class="ascii">IHP</span></a></li>
</ul></li>
<li><a href="#終わりに" title="終わりに">終わりに</a></li>
</ul>
</div>
</div>
<h1 id="動機"><span class="link-to-here-outer"><a href="#動機" title="動機"><span class="link-to-here">Link to<br />
here</span></a></span>動機</h1>
<p>そもそも、<span class="ascii">Haskell</span>には既に<span class="ascii">Servant</span>や<span class="ascii">Yesod</span>、<span class="ascii">Scotty</span>といった人気のフレームワークがあるにもかかわらず、なぜ新しいフレームワークを作ろうと思ったのでしょうか。第<span class="ascii">1</span>に、かつて私が<a href="https://wiki.haskell.jp/Hikers%20Guide%20to%20Haskell.html#web%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">「<span class="ascii">Haskell</span>の歩き方」という記事の「<span class="ascii">Web</span>アプリケーション」の節</a>で述べた、次の問題を解決したかったから、という理由があります<span class="ascii">:</span></p>
<blockquote>
<p>ただし<span class="ascii">Servant, Yesod,</span> 共通した困った特徴があります。
それぞれが<span class="ascii">Haskell</span>の高度な機能を利用した独特な<span class="ascii">DSL</span>を提供しているため、仕組みがわかりづらい、という点です。
<span class="ascii">Servant</span>は、「型レベルプログラミング」と呼ばれる、<span class="ascii">GHC</span>の言語拡張を使った仕組みを駆使して、型宣言だけで<span class="ascii">REST API</span>の仕様を記述できるようにしています。
<span class="ascii">Yesod</span>も<span class="ascii">GHC</span>の言語拡張をたくさん使っているのに加え、特に変わった特徴として、<span class="ascii">TemplateHaskell</span>や<span class="ascii">QuasiQuote</span>という仕組みを利用して、独自の<span class="ascii">DSL</span>を提供しています。
それぞれ、見慣れた<span class="ascii">Haskell</span>と多かれ少なかれ異なる構文で書かなければいけない部分があるのです。
つまり、これらのうちどちらかを使う以上、どちらかの魔法を覚えなければならないのです。</p>
</blockquote>
<p>この「どちらかの魔法を覚えなければならない」という問題は、初心者が<span class="ascii">Haskell</span>でウェブアプリケーションを作る上で大きな壁になりえます。入門書に書いてある<span class="ascii">Haskell</span>の機能だけでは、<span class="ascii">Servant</span>や<span class="ascii">Yesod</span>などのフレームワークで書くコードを理解できず、サンプルコードから雰囲気で書かなければならないのです。これが、新しいフレームワークを作ろうとした一番の動機です。</p>
<p>その他、このフレームワークを開発し始めるより更に前から開発・執筆している、<a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/">「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」</a>をウェブアプリケーションとして公開する際のフレームワークとしても使おうという考えもありました。「失敗しながら学ぶ<span class="ascii">Haskell</span>入門」はタイトルの通り<span class="ascii">Haskell</span>入門者のためのコンテンツです。そのため、<span class="ascii">Haskell</span>を学習したばかりの人でも簡単に修正できるフレームワークにしたかったのです。</p>
<h1 id="できたもの"><span class="link-to-here-outer"><a href="#できたもの" title="できたもの"><span class="link-to-here">Link to<br />
here</span></a></span>できたもの</h1>
<p>ソースコードはこちら👇️にあります。名前は仮に「<span class="ascii">wai-sample</span>」としました。</p>
<p><a href="https://github.com/igrep/wai-sample"><span class="ascii">igrep/wai-sample: Prototype of a new web application framework based on WAI.</span></a></p>
<p><span class="ascii">YouTube</span>で配信する前から行っていた<small>（私の前職である）</small><span class="ascii">IIJ</span>の社内勉強会中の開発と、全<span class="ascii">128</span>回の<span class="ascii">YouTube</span>でのライブコーディングを経て<small>（一部配信終了後に手を入れたこともありましたが）</small>、次のような構文でウェブアプリケーションを記述できるようにしました<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds         #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications  #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">WaiSample</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">sampleRoutes ::</span> [<span class="dt">Handler</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>sampleRoutes <span class="ot">=</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  [ <span class="co">-- ... 中略 ...</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (1) 最も単純な例</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  , get <span class="op">@</span>(<span class="dt">PlainText</span>, <span class="dt">T.Text</span>) <span class="st">&quot;aboutUs&quot;</span> (path <span class="st">&quot;about/us&quot;</span>) (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="st">&quot;About IIJ&quot;</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (2) ステータスコードを指定した例</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  , get <span class="op">@</span>(<span class="dt">WithStatus</span> <span class="dt">Status503</span> <span class="dt">PlainText</span>, <span class="dt">T.Text</span>) <span class="st">&quot;maintenance&quot;</span> (path <span class="st">&quot;maintenance&quot;</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>      (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="st">&quot;Sorry, we are under maintenance&quot;</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ... 中略 ...</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (3) パスをパースして含まれる整数を取得する例</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  , get <span class="op">@</span>(<span class="dt">PlainText</span>, <span class="dt">T.Text</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;customerTransaction&quot;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>      ( (,) <span class="op">&lt;$&gt;</span> (path <span class="st">&quot;customer/&quot;</span> <span class="op">*&gt;</span> decimalPiece)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;*&gt;</span> (path <span class="st">&quot;/transaction/&quot;</span> <span class="op">*&gt;</span> paramPiece)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>      (\(cId, transactionName) <span class="ot">-&gt;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;Customer &quot;</span> <span class="op">&lt;&gt;</span> T.pack (<span class="fu">show</span> cId) <span class="op">&lt;&gt;</span> <span class="st">&quot; Transaction &quot;</span> <span class="op">&lt;&gt;</span> transactionName</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ... 中略 ...</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>※完全なサンプルコードは<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Sample.hs"><span class="ascii">WaiSample/Sample.hs</span></a>をご覧ください。上記はその一部に説明用のコメントを加えています。</p>
<p>上記のサンプルコードにおける<code>sampleRoutes</code>が、<span class="ascii">Web API</span>の仕様を定めている部分です<span class="ascii">:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sampleRoutes ::</span> [<span class="dt">Handler</span>]</span></code></pre></div>
<p><code>Handler</code>という型のリストで、それぞれの<code>Handler</code>には、<span class="ascii">Web API</span>のエンドポイントを表すのに必要な情報が全て含まれています。<span class="ascii">wai-sample</span>では、この<code>Handler</code>のリストを解釈して<span class="ascii">WAI</span>ベースのサーバーアプリケーションを実行したり、<span class="ascii">Template Haskell</span>を通じてクライアントコードを生成したり、はたまたサーバーアプリケーションのドキュメントを生成したりすることができるようになっています。</p>
<h2 id="最も単純な例"><span class="link-to-here-outer"><a href="#最も単純な例" title="最も単純な例"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">(1)</span> 最も単純な例</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>get <span class="op">@</span>(<span class="dt">PlainText</span>, <span class="dt">T.Text</span>) <span class="st">&quot;aboutUs&quot;</span> (path <span class="st">&quot;about/us&quot;</span>) (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="st">&quot;About IIJ&quot;</span>)</span></code></pre></div>
<p>先程のサンプルコードから抜粋した最も単純な例↑では、<code>get</code>関数を使ってエンドポイントを定義しています。<code>get</code>関数は名前のとおり<span class="ascii">HTTP</span>の<span class="ascii">GET</span>メソッドに対応するエンドポイントを定義します。<code>TypeApplications</code>言語拡張を使って指定している<code>(PlainText, T.Text)</code>という型が、このエンドポイントが返すレスポンスの型を表しています。ここでは、<code>get</code>に渡す最後の引数に当たる関数（<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Types.hs#L104"><code>Responder</code></a>と呼びます。後述します）がレスポンスボディーとして返す型をお馴染みの<code>Text</code>型として指定しつつ、サーバーやクライアントが処理する際は<span class="ascii">MIME</span>タイプを<code>text/plain</code>として扱うように指定しています。</p>
<p><code>get</code>関数の（値の）第<span class="ascii">1</span>引数では、エンドポイントの名前を指定しています。この名前は、後述するクライアントコードを生成する機能において、関数名の一部として使われます。</p>
<p><code>get</code>関数の第<span class="ascii">2</span>引数は、エンドポイントのパスの仕様を表す<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Types.hs#L56-L65"><code>Route</code>型</a>の値です。この例では、<code>path</code>関数を使って<code>"about/us"</code>という単純な文字列を指定しています。結果、このエンドポイントのパスは<code>/about/us</code>となります<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>）。</p>
<p><code>get</code>関数の最後の引数が、このエンドポイントが<span class="ascii">HTTP</span>リクエストを受け取った際に実行する関数、<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Types.hs#L104"><code>Responder</code></a>です。ここでは、単純にレスポンスボディーとして文字列を返すだけの関数を指定しています。</p>
<h2 id="ステータスコードを指定した例"><span class="link-to-here-outer"><a href="#ステータスコードを指定した例" title="ステータスコードを指定した例"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">(2)</span> ステータスコードを指定した例</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>get <span class="op">@</span>(<span class="dt">WithStatus</span> <span class="dt">Status503</span> <span class="dt">PlainText</span>, <span class="dt">T.Text</span>) <span class="st">&quot;maintenance&quot;</span> (path <span class="st">&quot;maintenance&quot;</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="st">&quot;Sorry, we are under maintenance&quot;</span>)</span></code></pre></div>
<p>デフォルトでは、<code>get</code>関数で定義したエンドポイントはやっぱりステータスコード<span class="ascii">200</span>（<span class="ascii">OK</span>）を返します。この挙動を変えるには、先程指定したレスポンスの型のうち、<span class="ascii">MIME</span>タイプを指定していた箇所を<code>WithStatus</code>型でラップしましょう。型引数で指定しているタプルの<span class="ascii">1</span>つ目の要素は、このように<span class="ascii">HTTP</span>のレスポンスに関する仕様を<span class="ascii">Haskell</span>の型で指定するパラメーターとなっています。</p>
<p>この例では、<code>Status503</code>という型を指定しているため、<span class="ascii">HTTP</span>ステータスコード<span class="ascii">503</span>（<span class="ascii">Service Unavailable</span>）を返すエンドポイントを定義しています。</p>
<h2 id="パスの中に含まれる整数を処理する例"><span class="link-to-here-outer"><a href="#パスの中に含まれる整数を処理する例" title="パスの中に含まれる整数を処理する例"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">(3)</span> パスの中に含まれる整数を処理する例</h2>
<p>よくある<span class="ascii">Web</span>アプリケーションフレームワークでは、パスの一部に含まれる整数など、文字列型以外の値を取得するための仕組みが用意されています。</p>
<p><span class="ascii">Haskell</span>において、文字列から特定の型の値を取り出す…といえばそう、パーサーコンビネーターですね。<span class="ascii">wai-sample</span>では、サーバーが受け取ったパスをパーサーコンビネーターでパースするようになっています。従って下記の例では、<code>/customer/123/transaction/abc</code>というパスを受け取った場合、<code>123</code>と<code>"abc"</code>をタプルに詰め込んで<code>Responder</code>に渡すパスのパーサーを定義しています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>get <span class="op">@</span>(<span class="dt">PlainText</span>, <span class="dt">T.Text</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;customerTransaction&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  ( (,) <span class="op">&lt;$&gt;</span> (path <span class="st">&quot;customer/&quot;</span> <span class="op">*&gt;</span> decimalPiece)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;*&gt;</span> (path <span class="st">&quot;/transaction/&quot;</span> <span class="op">*&gt;</span> paramPiece)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  (\(cId, transactionName) <span class="ot">-&gt;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;Customer &quot;</span> <span class="op">&lt;&gt;</span> T.pack (<span class="fu">show</span> cId) <span class="op">&lt;&gt;</span> <span class="st">&quot; Transaction &quot;</span> <span class="op">&lt;&gt;</span> transactionName</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<p>実際のところここまでの話は<code>Route</code>型の値をサーバーアプリケーションが解釈した場合の挙動です。<code>Route</code>型はパスの仕様を定義する<code>Applicative</code>な内部<span class="ascii">DSL</span>となっています。これによって、サーバーアプリケーションだけでなくクライアントのコード生成機能やドキュメントの生成など、様々な応用ができるようになっています。詳しくは後述しますが、例えばクライアントのコード生成機能が<code>Route</code>型の値を解釈すると、<code>decimalPiece</code>や<code>paramPiece</code>などの値は生成した関数の引数を<span class="ascii">1</span>つずつ追加します。</p>
<h2 id="content-typeを複数指定する"><span class="link-to-here-outer"><a href="#content-typeを複数指定する" title="content-typeを複数指定する"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Content-Type</span>を複数指定する</h2>
<p><span class="ascii">Ruby on Rails</span>の<code>respond_to</code>メソッドなどで実現できるように、<span class="ascii">1</span>つのエンドポイントで<span class="ascii">1</span>つの種類のレスポンスボディーを、複数の<span class="ascii">Content-Type</span>で返す、といった機能は昨今の<span class="ascii">Web</span>アプリケーションフレームワークではごく一般的な機能でしょう。<span class="ascii">wai-sample</span>の場合、例えば次のようにして、<code>Customer</code>という型の値を<span class="ascii">JSON</span>や<code>application/x-www-form-urlencoded</code>な文字列として返すエンドポイントを定義できます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>sampleRoutes <span class="ot">=</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  [ <span class="co">-- ... 中略 ...</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  , get <span class="op">@</span>(<span class="dt">ContentTypes</span> &#39;[<span class="dt">Json</span>, <span class="dt">FormUrlEncoded</span>], <span class="dt">Customer</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ... 中略 ...</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>これまでの例では<code>get</code>の型引数において<span class="ascii">MIME</span>タイプを表す箇所に<span class="ascii">1</span>つの型のみ（<code>PlainText</code>型）を指定していましたが、ここでは代わりに<code>ContentTypes</code>という型を使用しています。<code>ContentTypes</code>型コンストラクターに、<span class="ascii">MIME</span>タイプを表す型の型レベルリストを渡せば、レスポンスボディーを表す<span class="ascii">1</span>つの型に対して、複数の<span class="ascii">MIME</span>タイプを指定できるようになります。</p>
<p>なお、<code>Json</code>や<code>FormUrlEncoded</code>と一緒に指定した<code>Customer</code>型は、当然<a href="https://hackage.haskell.org/package/aeson/docs/Data-Aeson-Types.html#t:ToJSON"><code>ToJSON</code></a>・<a href="https://hackage.haskell.org/package/aeson/docs/Data-Aeson-Types.html#t:FromJSON"><code>FromJSON</code></a>や<a href="https://hackage.haskell.org/package/http-api-data/docs/Web-FormUrlEncoded.html#t:ToForm"><code>ToForm</code></a>・<a href="https://hackage.haskell.org/package/http-api-data/docs/Web-FormUrlEncoded.html#t:FromForm"><code>FromForm</code></a>といった型クラスのインスタンスである必要があります<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。レスポンスボディーとして指定した型が、同時に指定した<span class="ascii">MIME</span>タイプに対応する形式に変換できることを、保証できるようになっているのです。</p>
<h2 id="サーバーアプリケーションとしての使い方"><span class="link-to-here-outer"><a href="#サーバーアプリケーションとしての使い方" title="サーバーアプリケーションとしての使い方"><span class="link-to-here">Link to<br />
here</span></a></span>サーバーアプリケーションとしての使い方</h2>
<p>ここまでで定義した<code>Handler</code>型の値、すなわち<span class="ascii">Web API</span>のエンドポイントの仕様に基づいてサーバーアプリケーションを実行するには、次のように書きます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Wai</span>              (<span class="dt">Application</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Wai.Handler.Warp</span> (runEnv)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">WaiSample.Sample</span>         (sampleRoutes)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">WaiSample.Server</span>         (handles)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="ot">sampleApp ::</span> <span class="dt">Application</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>sampleApp <span class="ot">=</span> handles sampleRoutes</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="ot">runSampleApp ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>runSampleApp <span class="ot">=</span> runEnv <span class="dv">8020</span> sampleApp</span></code></pre></div>
<p>ℹ️<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Server/Sample.hs">こちら</a>にあるコードと同じ内容です。</p>
<p><code>get</code>関数などで作った<code>Handler</code>型のリストを<code>handles</code>関数に渡すと、<span class="ascii">WAI</span>の<a href="https://hackage.haskell.org/package/wai-3.2.4/docs/Network-Wai.html#t:Application"><code>Application</code></a>型の値が出来上がります。<code>Application</code>型は<span class="ascii">WAI</span>におけるサーバーアプリケーションを表す型で、<span class="ascii">Servant</span>や<span class="ascii">Yesod</span>など他の多くの<span class="ascii">Haskell</span>製フレームワークでも、最終的にこの<code>Application</code>型の値を作るよう設計されています。上記の例は<code>Application</code>型の値を<span class="ascii">Warp</span>というウェブサーバーで動かす場合のコードです。<code>Application</code>型の値を<span class="ascii">Warp</span>の<code>runEnv</code>関数に渡すことで、指定したポート番号でアプリケーションを起動できます。</p>
<p>ここで起動したサーバーアプリケーションが、実際にエンドポイントへのリクエストを受け取った際実行する関数は、<code>get</code>関数などの最後の引数にあたる関数です。その関数は<code>SimpleResponder</code>という型シノニム<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>が設定されており、次のような定義となっています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SimpleResponder</span> p resObj <span class="ot">=</span> p <span class="ot">-&gt;</span> <span class="dt">IO</span> resObj</span></code></pre></div>
<p>ℹ️<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Types.hs#L106">こちら</a>より</p>
<p>型パラメーター<code>p</code>は、エンドポイントのパスに含まれるパラメーターを表す型です。これまでの例で<code>get</code>関数に渡した<code>(path "about/us")</code>や<code>((,) &lt;$&gt; (path "customer/" *&gt; decimalPiece) &lt;*&gt; (path "/transaction/" *&gt; paramPiece))</code>という式で作られる、<code>Route</code>型の値を解釈した結果の型<code>p</code>です。</p>
<p>そして<code>resObj</code>は、エンドポイントが返すレスポンスボディーの型です。これまでの例でいうと、<code>get</code>関数の型引数で指定した<code>(PlainText, T.Text)</code>における<code>T.Text</code>型、<code>(ContentTypes '[Json, FormUrlEncoded], Customer)</code>における<code>Customer</code>型が該当します。</p>
<p><code>runSampleApp</code>は各<code>Handler</code>型の値を解釈し、サーバーアプリケーションとして実行します。エンドポイントのパスの仕様（<code>(path "about/us")</code>など）をパーサーコンビネーターとして解釈し<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>、パースが成功した<code>Handler</code>が持つ<code>SimpleResponder</code>（<code>p -&gt; IO resObj</code>）を呼び出します。そして<code>SimpleResponder</code>が返した<code>resObj</code>を、クライアントが要求した<span class="ascii">MIME</span>タイプに応じたレスポンスボディーに変換し、クライアントに返す、という流れで動くようになっています。</p>
<h2 id="template-haskellによるクライアントの生成"><span class="link-to-here-outer"><a href="#template-haskellによるクライアントの生成" title="template-haskellによるクライアントの生成"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Template Haskell</span>による、クライアントの生成</h2>
<p>サーバーアプリケーションの定義だけであれば、<span class="ascii">Haskell</span>以外のものも含め、従来の多くのウェブアプリケーションフレームワークでも可能でしょう。しかし<span class="ascii">Servant</span>を始め、昨今における<span class="ascii">REST API</span>の開発を想定した<span class="ascii">Web</span>アプリケーションフレームワークは、クライアントコードを生成する機能まで備えていることが多いです。<span class="ascii">wai-sample</span>はそうしたフレームワークを目指しているため、当然クライアントコードの生成もできるようになっています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds        #-}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell  #-}</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">WaiSample.Client</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">WaiSample.Sample</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(declareClient <span class="st">&quot;sample&quot;</span> sampleRoutes)</span></code></pre></div>
<p>ℹ️<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Client/Sample.hs">こちら</a>からほぼそのままコピペしたコードです。</p>
<p>上記の通り、クライアントコードの生成は<code>TemplateHaskell</code>を使って行います。「簡単な<span class="ascii">Haskell</span>のみで作る」という目標からは早くも外れてしまいますが、生成されるコードが十分に予測しやすいものであろうことや、考え得る限り何らかの形で「難しい<span class="ascii">Haskell</span>」を使わなければ実装できないだろうという推察から、<code>TemplateHaskell</code>を使うことにしました。</p>
<p><code>declareClient</code>という関数に、生成する関数の名前の接頭辞（<span class="ascii">prefix</span>）とこれまで定義した<code>Handler</code>型のリスト（<code>sampleRoutes</code>）を渡すと、次のような型の関数の定義を生成します<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a><span class="ascii">:</span></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sampleAboutUs ::</span> <span class="dt">Backend</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">sampleMaintenance ::</span> <span class="dt">Backend</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sampleCustomerTransaction ::</span> <span class="dt">Backend</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></span></code></pre></div>
<p>生成された関数は、<code>get</code>関数などの第<span class="ascii">1</span>引数として渡した関数の名前に、<code>declareClient</code>の第<span class="ascii">1</span>引数として渡した接頭辞が付いた名前で定義されます。</p>
<p>生成された関数の第<span class="ascii">1</span>引数、<code>Backend</code>型は、クライアントがサーバーアプリケーションに実際に<span class="ascii">HTTP</span>リクエストを送るための関数です。次のように定義されています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.HTTP.Client</span>        <span class="kw">as</span> <span class="dt">HC</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Backend</span> <span class="ot">=</span> <span class="dt">Method</span> <span class="ot">-&gt;</span> <span class="dt">Url</span> <span class="ot">-&gt;</span> <span class="dt">RequestHeaders</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">HC.Response</span> <span class="dt">BL.ByteString</span>)</span></code></pre></div>
<p>このバックエンドを、例えば<code>http-client</code>パッケージの関数を使って実装することで、生成された関数がサーバーアプリケーションにリクエストを送ることができます。以下は実際に<code>http-client</code>パッケージを使って実装したバックエンドの例です<span class="ascii">:</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.HTTP.Client</span>        <span class="kw">as</span> <span class="dt">HC</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.UTF8</span>       <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">httpClientBackend ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Manager</span> <span class="ot">-&gt;</span> <span class="dt">Backend</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>httpClientBackend rootUrl manager method pathPieces rawReqHds <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  req0 <span class="ot">&lt;-</span> parseUrlThrow <span class="op">.</span> BS.toString <span class="op">$</span> method <span class="op">&lt;&gt;</span> B.pack <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> BS.fromString rootUrl <span class="op">&lt;&gt;</span> pathPieces</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> req <span class="ot">=</span> req0 { HC.requestHeaders <span class="ot">=</span> rawReqHds }</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  httpLbs (setRequestIgnoreStatus req) manager</span></code></pre></div>
<p>ℹ️<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Client.hs#L225-L230">こちら</a>からほぼそのままコピペしたコードです。</p>
<p><code>Backend</code>型以外の引数は、パスパラメーターを始めとする、<span class="ascii">HTTP</span>リクエストを組み立てるのに必要な情報です。<code>get</code>関数などで<code>Handler</code>型の値を定義する際に指定した<code>decimalPiece</code>や<code>paramPiece</code>を<code>declareClient</code>関数が回収して、生成した関数の引数に追加します。実際に生成した関数が受け取った引数は、もちろんパスの一部として当てはめるのに用います。</p>
<p>生成した関数の戻り値は、サーバーからのレスポンスを表す型です。<code>get</code>関数の型引数として渡した<code>(PlainText, T.Text)</code>や<code>(ContentTypes '[Json, FormUrlEncoded], Customer)</code>などにおける<code>T.Text</code>や<code>Customer</code>がそれに当たります。クライアントの関数はサーバーからのレスポンスを、<span class="ascii">MIME</span>タイプを表す型などに従って、この型に変換してから返すよう実装されているのです。</p>
<h2 id="ドキュメントの生成"><span class="link-to-here-outer"><a href="#ドキュメントの生成" title="ドキュメントの生成"><span class="link-to-here">Link to<br />
here</span></a></span>ドキュメントの生成</h2>
<p><a href="https://hackage.haskell.org/package/servant-openapi3"><span class="ascii">Servant</span>では<span class="ascii">OpenAPI</span>に則ったドキュメントを生成するパッケージがある</a>ように、<span class="ascii">Haskell</span>の構文で定義した<span class="ascii">REST API</span>の仕様から、<span class="ascii">API</span>のドキュメントを生成する機能があると便利でしょう。<span class="ascii">wai-sample</span>でも、<code>Handler</code>型のリストから<span class="ascii">API</span>のドキュメントを生成する機能を実装しました — 残念ながら完成度が低く、とても実用に耐えるものではありませんが。</p>
<p>ともあれ、試しに使ってみましょう。これまで例として紹介した<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Sample.hs#L147"><code>sampleRoutes</code></a>の各<code>Handler</code>に<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample.hs#L47"><code>showHandlerSpec</code></a>という関数を適用すると、次のように各エンドポイントへのパスやリクエスト・レスポンスの情報を取得することが出来ます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">mapM_</span> (TIO.putStrLn <span class="op">.</span> showHandlerSpec) sampleRoutes</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">index</span> <span class="st">&quot;GET&quot;</span> <span class="op">/</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Request</span><span class="op">:</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Query</span> <span class="dt">Params</span><span class="op">:</span> (none)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Headers</span><span class="op">:</span> (none)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Response</span><span class="op">:</span> (<span class="dt">PlainText</span>,<span class="dt">Text</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>maintenance <span class="st">&quot;GET&quot;</span> <span class="op">/</span>maintenance</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Request</span><span class="op">:</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Query</span> <span class="dt">Params</span><span class="op">:</span> (none)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Headers</span><span class="op">:</span> (none)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Response</span><span class="op">:</span> ((<span class="dt">WithStatus</span> <span class="dt">Status503</span> <span class="dt">PlainText</span>),<span class="dt">Text</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>aboutUs <span class="st">&quot;GET&quot;</span> <span class="op">/</span>about<span class="op">/</span>us</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Request</span><span class="op">:</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Query</span> <span class="dt">Params</span><span class="op">:</span> (none)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Headers</span><span class="op">:</span> (none)</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Response</span><span class="op">:</span> (<span class="dt">PlainText</span>,<span class="dt">Text</span>)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- ... 中略 ...</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>customerTransaction <span class="st">&quot;GET&quot;</span> <span class="op">/</span>customer<span class="op">/:</span>param<span class="op">/</span>transaction<span class="op">/:</span>param</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Request</span><span class="op">:</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Query</span> <span class="dt">Params</span><span class="op">:</span> (none)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Headers</span><span class="op">:</span> (none)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Response</span><span class="op">:</span> (<span class="dt">PlainText</span>,<span class="dt">Text</span>)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>createProduct <span class="st">&quot;POST&quot;</span> <span class="op">/</span>products</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Request</span><span class="op">:</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Query</span> <span class="dt">Params</span><span class="op">:</span> (none)</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Headers</span><span class="op">:</span> (none)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Response</span><span class="op">:</span> (<span class="dt">PlainText</span>,<span class="dt">Text</span>)</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a><span class="co">-- ... 以下略 ...</span></span></code></pre></div>
<p>…が、前述の通りあまりに完成度が低いので、詳しくは解説しません。実際に上記のコード実行すると、<code>Response</code>の型などがとても人間に読めるような出力になっていないことが分かります。今どきの<span class="ascii">Web API</span>フレームワークであれば<span class="ascii">OpenAPI</span>に則ったドキュメントを生成する機能が欲しいでしょうが、それもありません。この方向で拡張すれば実装できるとは思いますが、次の節で述べるとおり開発を止めることにしたので、ここまでとしておきます。</p>
<h1 id="何故開発を止めるのか"><span class="link-to-here-outer"><a href="#何故開発を止めるのか" title="何故開発を止めるのか"><span class="link-to-here">Link to<br />
here</span></a></span>何故開発を止めるのか</h1>
<p>開発をやめる最も大きな理由は、冒頭でも触れたとおり、当初考えていたゴールを達成するのが難しいと判断したからです<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>。<span class="ascii">wai-sample</span>のゴールは、「<span class="ascii">Servant</span>のような型安全な<span class="ascii">API</span>定義を、<small>（<span class="ascii">Servant</span>のような）</small>高度な型レベルプログラミングも、<small>（<span class="ascii">Yesod</span>のような）</small><span class="ascii">TemplateHaskell</span>もなしに可能にするライブラリー」にすることでした。ところが、後述の通りいくつかの機能においてそれが無理ではないか（少なくとも難しい）ということが発覚したのです。</p>
<h2 id="想定通りにできなかったもの-レスポンスに複数のパターンがあるとき"><span class="link-to-here-outer"><a href="#想定通りにできなかったもの-レスポンスに複数のパターンがあるとき" title="想定通りにできなかったもの-レスポンスに複数のパターンがあるとき"><span class="link-to-here">Link to<br />
here</span></a></span>想定通りにできなかったもの<span class="ascii">:</span> レスポンスに複数のパターンがあるとき</h2>
<p>「できたもの」の節では割愛しましたが、<span class="ascii">wai-sample</span>では、サーバーが返すレスポンスに複数のケースがあるエンドポイント — 例えば、一方ではステータスコード<span class="ascii">200 OK</span>と共に取得できたリソースの情報を返しつつ、一方では<span class="ascii">403 Forbidden</span>と共にエラーメッセージを返す — の実装もサポートしています。例えば次のように書けば、<code>/customer/:id.txt</code>というパスで複数の種類のレスポンスを返すエンドポイントを定義することが出来ます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>get <span class="op">@</span>(<span class="dt">Sum</span> &#39;[(<span class="dt">PlainText</span>, <span class="dt">T.Text</span>), <span class="dt">Response</span> (<span class="dt">WithStatus</span> <span class="dt">Status503</span> <span class="dt">PlainText</span>) <span class="dt">T.Text</span>])</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;customerIdTxt&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- /customer/:id.txt</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      (path <span class="st">&quot;customer/&quot;</span> <span class="op">*&gt;</span> decimalPiece <span class="op">&lt;*</span> path <span class="st">&quot;.txt&quot;</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      (\i <span class="ot">-&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> i <span class="op">==</span> <span class="dv">503</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> <span class="fu">return</span> <span class="op">.</span> sumLift <span class="op">$</span> <span class="dt">Response</span> <span class="op">@</span>(<span class="dt">WithStatus</span> <span class="dt">Status503</span> <span class="dt">PlainText</span>) (<span class="st">&quot;error&quot;</span><span class="ot"> ::</span> <span class="dt">T.Text</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> <span class="fu">return</span> <span class="op">.</span> sumLift <span class="op">$</span> <span class="st">&quot;Customer &quot;</span> <span class="op">&lt;&gt;</span> T.pack (<span class="fu">show</span> i))</span></code></pre></div>
<p>ℹ️<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Sample.hs#L175-L182">こちら</a>からほぼそのままコピペしたコードです。</p>
<p><code>get</code>関数の型引数に、随分仰々しい型が現れました。<code>Sum</code>という型は、名前のとおり和型を作ります。型レベルリストの要素として<span class="ascii">Content-Type</span>やステータスコードを表す型と、実際のレスポンスボディーの型を組み合わせたタプル（あるいは後述する<code>Response</code>型）を渡すことで、複数のケースを持つレスポンスの型を定義しています。上記の例における<code>Sum '[(PlainText, T.Text), Response (WithStatus Status503 PlainText) T.Text]</code>は、次の<span class="ascii">2</span>つのケースを持つレスポンスの型を表しています<span class="ascii">:</span></p>
<ul>
<li>ステータスコードが（デフォルトの）<code>200 OK</code>で、<span class="ascii">Content-Type</span>が<code>text/plain</code>、レスポンスボディーを表す型が<code>Text</code>型</li>
<li>ステータスコードが<code>503 Service Unavailable</code>で、<span class="ascii">Content-Type</span>が<code>text/plain</code>、レスポンスボディーを表す型が<code>Text</code>型</li>
</ul>
<p>以上のように書くことで実装できるようにはしたのですが、これによって当初の目的である「高度な型レベルプログラミングなしに実装する」という目標から外れてしまいました。型レベルリストは「高度な型レベルプログラミング」に該当すると言って差し支えないでしょう。</p>
<p>なぜこのような<span class="ascii">API</span>になったのかというと、<span class="ascii">Web API</span>に対する「入力」に当たる、パスのパース<small>（や、今回は実装しませんでしたがリクエストボディーなどの処理も）</small>などと、<span class="ascii">Web API</span>からの「出力」に当たるレスポンスの処理では、実行時に使える情報が大きく異なっていたからです。「入力」は値レベルでも<small>（高度な型レベルプログラミングなしで）</small><span class="ascii">Free Applicative</span>を応用した<span class="ascii">DSL</span>を使えば<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>、サーバーアプリケーション・クライアントコード・ドキュメント、いずれにも実行時に解釈できるフレームワークにできた一方、レスポンスボディーなど「出力」の型は値レベルの<span class="ascii">DSL</span>を書いても、サーバーアプリケーションを実行しない限りそれに整合しているかどうかが分からない、という原理的な問題が判明したからです。</p>
<p>例えば、レスポンスボディーの仕様を次のような内部<span class="ascii">DSL</span>で定義できるようにしたとします<span class="ascii">:</span></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>get [(plainText, text), ((withStatus status503 plainText), text)]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- ...</span></span></code></pre></div>
<p>型レベルプログラミングバージョンでは型引数に渡していた情報を、ほぼそのまま値レベルに落とし込んだものです。しかしこのように書いたとしても、サーバーアプリケーションを起動して、実際にクライアントからリクエストを受け取り、それに対して<code>get</code>に渡した関数（<code>Responder</code>）がレスポンスの元となる値を返すまで、レスポンスボディーの型が正しいかどうか、検証できないのです。「レスポンスの元となる値」の型はライブラリーのユーザー自身が<code>Responder</code>で返す値の型ですし、実行時以前にコンパイル時に保証できていて欲しいものです。これが、値レベルの<span class="ascii">DSL</span>を採用した場合の限界です。</p>
<p>それから、型レベルリストを使ったこと以外においても、複雑で分かりづらい要因があります。先程から少し触れているとおり、<span class="ascii">Content-Type</span>やステータスコードとレスポンスボディーの型を組み合わせを表すのに、タプル以外にも<code>Response</code>という型を用いています。<code>Response</code>型とタプル型はいずれも<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Types/Response.hs#L47-L49"><code>ResponseSpec</code></a>（下記に転載）という型クラスのインスタンスとなることで、「<span class="ascii">Content-Type</span>やステータスコード」を表す型（<code>ResponseType</code>）と<code>Responder</code>がレスポンスボディーとして返す型（<code>ResponseObject</code>）を宣言することが出来ます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ResponseSpec</span> resSpec <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ResponseType</span> resSpec</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ResponseObject</span> resSpec</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ResponseSpec</span> (resTyp, resObj) <span class="kw">where</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ResponseType</span> (resTyp, resObj) <span class="ot">=</span> resTyp</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ResponseObject</span> (resTyp, resObj) <span class="ot">=</span> resObj</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ResponseSpec</span> (<span class="dt">Response</span> resTyp resObj) <span class="kw">where</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ResponseType</span> (<span class="dt">Response</span> resTyp resObj) <span class="ot">=</span> resTyp</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ResponseObject</span> (<span class="dt">Response</span> resTyp resObj) <span class="ot">=</span> <span class="dt">Response</span> resTyp resObj</span></code></pre></div>
<p><code>ResponseSpec (resTyp, resObj)</code>と<code>ResponseSpec (Response resTyp resObj)</code>の<span class="ascii">2</span>つのインスタンスの違い、分かるでしょうか？まるで間違い探しですよね…😥。タプル型も<code>Response</code>型も<code>get</code>などに渡す型レベルリストでの役割はほぼ同じで、最初はタプルだけをとることにしていたのですが、やむを得ない理由があって<code>Response</code>を別途設けることにしました<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>。こうした分かりづらい部分が出来てしまったのも、失敗の<span class="ascii">1</span>つです。</p>
<h2 id="パスのパーサー-実はがすでに危ない"><span class="link-to-here-outer"><a href="#パスのパーサー-実はがすでに危ない" title="パスのパーサー-実はがすでに危ない"><span class="link-to-here">Link to<br />
here</span></a></span>パスのパーサー<span class="ascii">:</span> 実は<code>&lt;$&gt;</code>がすでに危ない</h2>
<p>パスのパーサーを値レベルの、<code>Applicative</code>な内部<span class="ascii">DSL</span>として実装した結果、<span class="ascii">Servant</span>と比べて型安全性を損なってしまうという問題があることも、作ってから気付きました。例えば、次のように<code>&lt;$&gt;</code>に渡す関数としてコンストラクターでない、普通の関数を渡した場合です<span class="ascii">:</span></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>path <span class="st">&quot;integers/&quot;</span> <span class="op">*&gt;</span> (<span class="fu">show</span> <span class="op">&lt;$&gt;</span> decimalPiece)</span></code></pre></div>
<p><a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Routes.hs#L22"><code>decimalPiece</code></a>は<code>Route Integer</code>という型で、それに<code>show &lt;$&gt;</code>を適用した結果は<code>Route String</code>となります。<code>Route String</code>は、パスの一部として文字列を受け取ることを表す型ですから、上記の式は<code>integers/&lt;任意の文字列&gt;</code>というパスを表すことになります。ところが！実際にサーバーアプリケーションがパスをパースするのに使っているのは<code>decimalPiece</code>なので、整数でなければなりません。このように<code>&lt;$&gt;</code>を使うだけで、<code>Route String</code>という型が表すパスのパーサーと、実際にパースできるパスの仕様が食い違ってしまうことがあります。<code>Applicative</code>（厳密に言えば<code>Functor</code>の機能ですが）を使った<span class="ascii">DSL</span>である以上、こうしたことが防げないのです。</p>
<p>まあ、実は同じ問題が同じように<code>Applicative</code>ベースの内部<span class="ascii">DSL</span>を使った他のライブラリーにもあるでしょうから、敢えて気にしない、という手もあるのかも知れませんが。ちなみに、似たような問題を解決するため<a href="https://hackage.haskell.org/package/relational-record"><span class="ascii">relational-record</span></a>というパッケージでは<code>Functor</code>や<code>Applicative</code>は使わず、<a href="https://hackage.haskell.org/package/product-isomorphic"><span class="ascii">product-isomorphic</span></a>というパッケージで、言わば「コンストラクターだけが適用できる<code>Functor</code>・<code>Applicative</code>」とも言うべき専用の型クラスを作ることで解決していました。<span class="ascii">wai-sample</span>もこれを使えないかと企みましたが、どうもうまく適用できなかったため諦めました。</p>
<h1 id="実装し切れなかったもの"><span class="link-to-here-outer"><a href="#実装し切れなかったもの" title="実装し切れなかったもの"><span class="link-to-here">Link to<br />
here</span></a></span>実装し切れなかったもの</h1>
<p>ウェブアプリケーションフレームワークとして実装すべき機能のうち、実装し切れなかったものは当然たくさんあります。例えば以下のような機能でしょう<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">HTTP</span>リクエストに関わるもの<span class="ascii">:</span>
<ul>
<li>リクエストヘッダーの処理</li>
<li>クエリーパラメーターの処理</li>
<li>（この辺りは、リクエストボディーの処理と似たような要領で実装できるはず）</li>
</ul></li>
<li><span class="ascii">HTTP</span>レスポンスに関わるもの<span class="ascii">:</span>
<ul>
<li>動的な<span class="ascii">HTML</span>の配信</li>
<li>ファイルシステムにあるファイルの配信</li>
<li>（<span class="ascii">REST API</span>に特化したフレームワークであればこれらは不要でしょうが、拡張として簡単に追加できるようにはしたいですね）</li>
</ul></li>
<li>両方に関わるもの<span class="ascii">:</span>
<ul>
<li><span class="ascii">Cookie</span>の読み書き</li>
</ul></li>
<li>ドキュメント生成に関わるもの<span class="ascii">:</span>
<ul>
<li><span class="ascii">OpenAPI</span>に準拠したドキュメント生成</li>
</ul></li>
<li>などなど！</li>
</ul>
<h1 id="類似のライブラリー解決策"><span class="link-to-here-outer"><a href="#類似のライブラリー解決策" title="類似のライブラリー解決策"><span class="link-to-here">Link to<br />
here</span></a></span>類似のライブラリー・解決策</h1>
<p>手が遅いもので、私が最初に<span class="ascii">wai-sample</span>のリポジトリーに対して行った<a href="https://github.com/igrep/wai-sample/commit/37f49dfe86af7482b09ab82b2282c5b9bf1cd73d">最初のコミット</a>から、既に約<span class="ascii">5</span>年の歳月が過ぎました<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>。当時は私の前職、<span class="ascii">IIJ</span>における社内勉強会のネタとして始めたのが懐かしいです。私が知る限り、当時は<span class="ascii">wai-sample</span>のように「値レベルのプログラミングで」「<span class="ascii">Servant</span>のように<span class="ascii">1</span>つの定義からクライアントやドキュメントの生成も出来る」ことを目指したライブラリーはなかったように思います。しかし実際のところ、執筆時点で次のライブラリーが類似の機能を実装しているようです。これらのライブラリーがいつ開発を始めたのかは分かりませんが、やはり私が<span class="ascii">wai-sample</span>を作り始めた時点で同じような問題意識を持った人はいたのでしょう。</p>
<h2 id="okapi"><span class="link-to-here-outer"><a href="#okapi" title="okapi"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://okapi.wiki/"><span class="ascii">Okapi</span></a></h2>
<p><a href="https://okapi.wiki/"><span class="ascii">Okapi</span></a>にある<a href="https://okapi.wiki/#endpoint"><span class="ascii">Endpoint</span></a>という機能は「<span class="ascii">An Endpoint is an executable specification representing a single Operation that can be taken against your API.</span>」と謳っているとおり、<span class="ascii">API</span>の仕様を表現する内部<span class="ascii">DSL</span>を提供します。しかもこれから紹介するとおり、<span class="ascii">wai-sample</span>より幾分洗練されているように見えます。</p>
<p><span class="ascii">Okapi</span>では下記の<code>Endpoint</code>という型 — <span class="ascii">wai-sample</span>でいう<code>Handler</code>に相当するようです — に、「<span class="ascii">Script</span>」と呼ばれる値レベル<span class="ascii">DSL</span>を設定して使うようです<span class="ascii">:</span></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Endpoint</span> p q h b r <span class="ot">=</span> <span class="dt">Endpoint</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> method ::</span> <span class="dt">StdMethod</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> path ::</span> <span class="dt">Path.Script</span> p</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> query ::</span> <span class="dt">Query.Script</span> q</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> body ::</span> <span class="dt">Body.Script</span> b</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> headers ::</span> <span class="dt">Headers.Script</span> h</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> responder ::</span> <span class="dt">Responder.Script</span> r</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>詳細はもちろん公式ドキュメントにも書かれていますが、読んでわかる範囲でこちらでも解説しましょう。<code>Endpoint</code>型の各フィールドは、<span class="ascii">HTTP</span>リクエスト・レスポンスに関わる各要素の仕様を表しています。<code>method</code>フィールドを除くすべてのフィールドは、それぞれのフィールドのために作られた<code>Script</code>という型の<code>Applicative</code><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>な<span class="ascii">DSL</span>を使って仕様を表現します。<code>Path.Script p</code>はパスの仕様、<code>Query.Script q</code>はクエリーパラメーターの仕様、<code>Body.Script b</code>はリクエストボディーの仕様、<code>Headers.Script h</code>はリクエストヘッダーの仕様、<code>Responder.Script r</code>はレスポンスの仕様、といったところです。</p>
<p>各<code>Script</code>型のうち、特筆すべきは<code>Responder.Script</code>でしょう。<code>Responder.Script</code>では、レスポンスの種類毎にレスポンスボディーの型やステータスコード、レスポンスヘッダーの型を、<span class="ascii">case analysis</span>を表す型として定義できるようになっています。そして、<code>Handler</code>型は<code>Endpoint</code>型が各種<code>Script</code>を使って設定した値を使って、実際に<code>Response</code>型の値を組み立てます<span class="ascii">:</span></p>
<p>（⚠️以下のコードは、<a href="https://okapi.wiki/#cb10"><span class="ascii">Okapi</span>のドキュメントにあったサンプルコード</a>を元に、私が推測してコメントを追加したものです。間違っていたらごめんなさい <span class="ascii">hask(_ _)eller</span>）</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Responseにヘッダーを設定する関数群</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SecretHeaders</span> <span class="ot">=</span> <span class="dt">SecretHeaders</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> firstSecret ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Response</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> secondSecret ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Response</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Responseにヘッダーとボディーを設定する関数群</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">--   レスポンスの種類毎にフィールドラベルを1つ備えた、case analysisを表す型</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyResponders</span> <span class="ot">=</span> <span class="dt">MyResponders</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> allGood ::</span> (<span class="dt">SecretHeaders</span> <span class="op">%</span><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Response</span>) <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Response</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> notGood ::</span> (() <span class="op">%</span><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Response</span>) <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Response</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- | `Responder.Script`として定義する、レスポンスの仕様</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>myResponderScript <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- allGood の場合はレスポンスボディーは`Text`型で、ステータスコードは200。</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- レスポンスヘッダーとしては、`IntSecret`と`X-Another-Secret`という</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- `Int`型の2つのヘッダーを追加する。</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>  allGood <span class="ot">&lt;-</span> Responder.json <span class="op">@</span><span class="dt">Text</span> status200 <span class="kw">do</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    addSecret <span class="ot">&lt;-</span> AddHeader.using <span class="op">@</span><span class="dt">Int</span> <span class="st">&quot;IntSecret&quot;</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    addAnotherSecret <span class="ot">&lt;-</span> AddHeader.using <span class="op">@</span><span class="dt">Int</span> <span class="st">&quot;X-Another-Secret&quot;</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="dt">SecretHeaders</span> {<span class="op">..</span>}</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- notGood の場合はレスポンスボディーは`Text`型で、ステータスコードは501。</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- レスポンスヘッダーはなし。</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>  notGood <span class="ot">&lt;-</span> Responder.json <span class="op">@</span><span class="dt">Text</span> status501 <span class="op">$</span> <span class="fu">pure</span> ()</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="dt">MyResponders</span> {<span class="op">..</span>}</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Responder.Scriptで定義したcase analysisを表す型、`MyResponders`を使って、</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="co">--   レスポンスを組み立てる関数。</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a><span class="co">--   `someNumber`が100未満なら`allGood`を、そうでなければ`notGood`を使う。</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a><span class="co">--   この関数が利用していない引数は、`Endpoint`型の他のフィールドに対応するもの。</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>myHandler someNumber _ _ _ _ (<span class="dt">MyResponders</span> allGood notGood) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> someNumber <span class="op">&lt;</span> <span class="dv">100</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="fu">return</span> <span class="op">$</span> allGood</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>      (\(<span class="dt">SecretHeaders</span> firstSecret secondSecret) response <span class="ot">-&gt;</span> secondSecret <span class="dv">0</span> <span class="op">$</span> firstSecret <span class="dv">7</span> response)</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;All Good!&quot;</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">return</span> <span class="op">$</span> notGood</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>      (\() response <span class="ot">-&gt;</span> response)</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Not Good!&quot;</span></span></code></pre></div>
<p><span class="ascii">wai-sample</span>がうまく実装できなかった、レスポンスに複数のパターンがある場合の処理を、<span class="ascii">case analysis</span>を表す型で実装しているのが興味深いですね。前述した「原理的な問題」に対する解決策なのでしょう。</p>
<h2 id="ihp"><span class="link-to-here-outer"><a href="#ihp" title="ihp"><span class="link-to-here">Link to<br />
here</span></a></span><a href="https://ihp.digitallyinduced.com/"><span class="ascii">IHP</span></a></h2>
<p><span class="ascii">IHP (Integrated Haskell Platform)</span>は、<span class="ascii">Haskell</span>で書かれたフルスタックな<span class="ascii">Web</span>アプリケーションフレームワークです。<span class="ascii">wai-sample</span>のような、与えられたパスに基づいて対応する関数を呼び出す機能（ルーティング機能）はもちろんのこと、<span class="ascii">PostgreSQL</span>と接続する<span class="ascii">ORM</span>やメールの送信、バックグラウンド処理に加えて<span class="ascii">GUI</span>から管理する機能など、様々な機能を備えています。<a href="https://ihp.digitallyinduced.com/Guide/architecture.html"><span class="ascii">Architecture</span></a>を読むと察せられるとおり、古き良き<span class="ascii">Ruby on Rails</span>のようなスタイルのフレームワークのようです。</p>
<p>そんな<a href="https://ihp.digitallyinduced.com/Guide/routing.html"><span class="ascii">IHP</span>のルーティング機能</a>、とりわけ<span class="ascii">REST API</span>の慣習では表現しきれず、<a href="https://ihp.digitallyinduced.com/Guide/routing.html#custom-routing">カスタマイズしたパスを定義する際の機能</a>は、まさにパスのパーサーコンビネーターを書くことで実装できるようになっています。以下はドキュメントにあった例をそのまま貼り付けています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- /posts/an-example-blog-post というような記事の名前(slug)や</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- /posts/f85dc0bc-fc11-4341-a4e3-e047074a7982 というような記事のIDから</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 記事を表示するアクションを呼び出すルーティング</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- パスにあるパラメーターを表す型</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PostsController</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">ShowPostAction</span> {<span class="ot"> postId ::</span> <span class="op">!</span>(<span class="dt">Maybe</span> (<span class="dt">Id</span> <span class="dt">Post</span>)),<span class="ot"> slug ::</span> <span class="op">!</span>(<span class="dt">Maybe</span> <span class="dt">Text</span>) }</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- CanRoute 型クラスのインスタンスで、</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- パスのパーサーコンビネーターを定義する</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CanRoute</span> <span class="dt">PostsController</span> <span class="kw">where</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    parseRoute&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        string <span class="st">&quot;/posts/&quot;</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> postById <span class="ot">=</span> <span class="kw">do</span> <span class="fu">id</span> <span class="ot">&lt;-</span> parseId; endOfInput; <span class="fu">pure</span> <span class="dt">ShowPostAction</span> { postId <span class="ot">=</span> <span class="dt">Just</span> <span class="fu">id</span>, slug <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> postBySlug <span class="ot">=</span> <span class="kw">do</span> slug <span class="ot">&lt;-</span> remainingText; <span class="fu">pure</span> <span class="dt">ShowPostAction</span> { postId <span class="ot">=</span> <span class="dt">Nothing</span>, slug <span class="ot">=</span> <span class="dt">Just</span> slug }</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        postById <span class="op">&lt;|&gt;</span> postBySlug</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- HasPath 型クラスのインスタンスで、</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- パスに含めるパラメーターからパスを生成する関数を定義する</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasPath</span> <span class="dt">PostsController</span> <span class="kw">where</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    pathTo <span class="dt">ShowPostAction</span> { postId <span class="ot">=</span> <span class="dt">Just</span> <span class="fu">id</span>, slug <span class="ot">=</span> <span class="dt">Nothing</span> } <span class="ot">=</span> <span class="st">&quot;/posts/&quot;</span> <span class="op">&lt;&gt;</span> tshow <span class="fu">id</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    pathTo <span class="dt">ShowPostAction</span> { postId <span class="ot">=</span> <span class="dt">Nothing</span>, slug <span class="ot">=</span> <span class="dt">Just</span> slug } <span class="ot">=</span> <span class="st">&quot;/posts/&quot;</span> <span class="op">&lt;&gt;</span> slug</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>action <span class="dt">ShowPostAction</span> { postId, slug } <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>    post <span class="ot">&lt;-</span> <span class="kw">case</span> slug <span class="kw">of</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> slug <span class="ot">-&gt;</span> query <span class="op">@</span><span class="dt">Post</span> <span class="op">|&gt;</span> filterWhere (<span class="op">#</span>slug, slug) <span class="op">|&gt;</span> fetchOne</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> fetchOne postId</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- ...</span></span></code></pre></div>
<p><span class="ascii">wai-sample</span>や<span class="ascii">Okapi</span>のようにパスの定義を<span class="ascii">1</span>箇所で済ませられるわけではない（<code>CanRoute</code>と<code>HasPath</code>の<span class="ascii">2</span>つの型クラスのインスタンスを定義する必要がある）ようですが、パーサーコンビネーターを使って自由にパスを定義できるところは似ていますね。</p>
<h1 id="終わりに"><span class="link-to-here-outer"><a href="#終わりに" title="終わりに"><span class="link-to-here">Link to<br />
here</span></a></span>終わりに</h1>
<p><span class="ascii">wai-sample</span>は、<span class="ascii">Haskell</span>で<span class="ascii">Web API</span>を実装するためのフレームワークとして、<span class="ascii">Servant</span>や<span class="ascii">Yesod</span>のような既存のフレームワークとは異なるアプローチを試みました。残念ながら目標の達成が技術的に困難であることが分かり、開発を止めることにしましたが、<span class="ascii">Haskell</span>で<span class="ascii">Web API</span>を実装するため新しいアプローチとして、何かしら参考になれば幸いです。</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>先頭のスラッシュにご注意ください。<span class="ascii">wai-sample</span>が<code>Route</code>型の値を処理する際は、先頭のスラッシュは付けない前提としています。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>諸般の事情で、<span class="ascii">wai-sample</span>では<a href="https://github.com/igrep/http-api-data/tree/151de32409960354de3a3f786f20bc4a496d2b65"><code>http-api-data</code>パッケージをフォーク</a>して使っています。そのため、<code>ToForm</code>型クラスなどの仕様が<span class="ascii">Hackage</span>にあるものと異なっています。最終的に<span class="ascii">wai-sample</span>を公開する際、フォークした<span class="ascii">http-api-data</span>を新しいパッケージとして同時に公開する予定でした。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>名前から察せられるとおり<code>Simple</code>じゃない普通の<code>Responder</code>型もありますが、ここでは割愛します。<code>Responder</code>型はクエリーパラメーターやリクエストヘッダーなど、パスに含めるパラメーター以外の情報を受け取るためのものです。<code>SimpleResponder</code>型のすぐ近くで定義されているので、興味があったらご覧ください。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>パーサーコンビネーター以外のアプローチ、例えば基数木を使ってより多くのエンドポイントを高速に処理できるようにするのも可能でしょう。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><code>ghc</code>コマンドの<code>-ddump-splices</code>オプションを使って、<code>declareClient</code>関数が生成したコードを貼り付けました。みなさんの手元で試す場合は<code>stack build --ghc-options=-ddump-splices</code>などと実行するのが簡単でしょう。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>もう<span class="ascii">1</span>つは、大変申し訳ないですが、私自身の<span class="ascii">Haskell</span>に対する情熱が落ち込んでしまった、という理由もあります😞。<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>今回は詳細を省きましたが<code>Free Applicative</code>を使った<span class="ascii">DSL</span>の実装は、<a href="https://github.com/igrep/wai-sample/blob/b4ddb75a28b927b76ac7c4c182bad6812769ed01/src/WaiSample/Types.hs"><span class="ascii">WaiSample.Types</span>モジュール</a>をご覧ください。<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>詳しい理由は面倒なので解説しません！これまでに出てきたコードだけで推測できるはずですし考えてみてください！<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p><a href="https://github.com/igrep/wai-sample/commit/b2647de2a1a4c7ec8c799ec07972c3d9df6fcb55">実装に対する最後の修正</a>からも既に<span class="ascii">1</span>年以上が過ぎました。記録を作るのも遅い…😥<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>個人的には、なぜ<code>Alternative</code>にしなかったのかが気になります。<code>Body.optional</code>や<code>Headers.optional</code>などは文字通り<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#v:optional"><code>Alternative</code>の<code>optional</code></a>で実現できそうに見えるからです。<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2022/disband_admins.html" style="margin-left: auto;" lang="ja">一般社団法人としてのHaskell-jp Admins解散のお知らせ</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>一般社団法人としてのHaskell-jp Admins解散のお知らせ</title>
    <link href="https://haskell.jp/blog/posts/2022/disband_admins.html" />
    <id>https://haskell.jp/blog/posts/2022/disband_admins.html</id>
    <published>2022-09-18T00:00:00Z</published>
    <updated>2022-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>誠に残念ながら、一般社団法人としての日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会（通称<span class="ascii">Haskell-jp Admins</span>）は、去る<span class="ascii">2022</span>年<span class="ascii">4</span>月<span class="ascii">16</span>日を以て解散しました。先日、解散後に必要な処理のほぼすべてが完了しましたので、遅くなってしまいましたが、改めてこちらで報告致します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#背景" title="背景">背景</a></li>
<li><a href="#今後の活動" title="今後の活動">今後の活動</a></li>
<li><a href="#今後の連絡先" title="今後の連絡先">今後の連絡先</a></li>
</ul>
</div>
</div>
<h1 id="背景"><span class="link-to-here-outer"><a href="#背景" title="背景"><span class="link-to-here">Link to<br />
here</span></a></span>背景</h1>
<p>解散の背景を一言で申しますと、「お金がかかりすぎる上に、士気も下がってしまったから」です。設立前に調査した際、法人住民税のルールを誤解してしまったことで想定より費用がかさんだことや、当初活動の一環として掲げていた大規模なオフラインイベントが、現状のコロナ禍において難しく、その上、代表を含む社員自身の開催するモチベーションが下がってしまっていることを鑑みて、先般行われた第<span class="ascii">1</span>期の社員総会で解散する事を合意しました。</p>
<h1 id="今後の活動"><span class="link-to-here-outer"><a href="#今後の活動" title="今後の活動"><span class="link-to-here">Link to<br />
here</span></a></span>今後の活動</h1>
<p>「一般社団法人」という法人格を失ってしまったので、法律上必要な場面において「日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会」という名前を使用することはできなくなってしまいました。それでもできる範囲内で、任意団体として今までどおりの活動を継続したいと思います。</p>
<p>具体的には、</p>
<ul>
<li>プログラミング言語<span class="ascii">Haskell</span>に関するイベントの企画・開催・運営
<ul>
<li>任意団体として適宜実施します</li>
</ul></li>
<li><span class="ascii">haskell.jp</span> ドメインの維持・管理
<ul>
<li>ひとまず、代表であった山本悠滋が個人として引き継ぐことにします</li>
</ul></li>
<li><a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>を始めとする、交流や情報共有を行う場の提供・管理・運営
<ul>
<li>こちらは引き続き行います</li>
</ul></li>
</ul>
<h1 id="今後の連絡先"><span class="link-to-here-outer"><a href="#今後の連絡先" title="今後の連絡先"><span class="link-to-here">Link to<br />
here</span></a></span>今後の連絡先</h1>
<p>こちらは<a href="../about_admins.html">設立時の記事</a>から特に変更はありません。<a href="../about_admins.html#今後の活動と連絡先">該当するセクション</a>をご覧ください。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2025/wai-sample.html" lang="ja">簡単なHaskellのみでServant並に高機能なライブラリーを作ろうとした振り返り</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2021/text-mono-traversable.html" style="margin-left: auto;" lang="ja">文字列型を抽象化するのにはmono-traversableパッケージがいいかも</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>文字列型を抽象化するのにはmono-traversableパッケージがいいかも</title>
    <link href="https://haskell.jp/blog/posts/2021/text-mono-traversable.html" />
    <id>https://haskell.jp/blog/posts/2021/text-mono-traversable.html</id>
    <published>2021-12-25T00:00:00Z</published>
    <updated>2021-12-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>この記事は<a href="https://qiita.com/advent-calendar/2021/haskell"><span class="ascii">Haskell Advent Calendar 2021</span></a>の<span class="ascii">25</span>日目の記事です。</p>
<p><span class="ascii">Haskell</span>のよく言われる問題点の一つとして、文字列型が下記のようによく使われるものだけで<strong><span class="ascii">5</span>種類</strong>もある、という点があります<span class="ascii">:</span></p>
<ul>
<li><code>String</code></li>
<li><span class="ascii">Strict</span>な<code>Text</code></li>
<li><span class="ascii">Lazy</span>な<code>Text</code></li>
<li><span class="ascii">Strict</span>な<code>ByteString</code></li>
<li><span class="ascii">Lazy</span>な<code>ByteString</code></li>
</ul>
<p><small>（上記の頻繁に使われるもの以外にも、もっとあります）</small></p>
<p>それぞれ確かに使いどころが違うので、アプリケーションで使用する場合は場面に応じて使い分ければいいのですが、文字列を使ったライブラリーを開発する場合はなかなか悩ましいものがあります。内部で依存しているライブラリーが使用しているものがあれば、それをそのまま使うのが簡単で確実ですが、そうでない場合も多いでしょう。そこで本稿では文字列型を抽象化して扱いたい場合の手段として、<a href="https://hackage.haskell.org/package/mono-traversable"><span class="ascii">mono-traversalbe</span>パッケージ</a>を検討したいと思います。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#mono-traversableパッケージの紹介" title="mono-traversableパッケージの紹介"><span class="ascii">mono-traversable</span>パッケージの紹介</a></li>
<li><a href="#mono-traversableパッケージにおける型クラスのメソッドと各種文字列型向け関数の対応表" title="mono-traversableパッケージにおける型クラスのメソッドと各種文字列型向け関数の対応表"><span class="ascii">mono-traversable</span>パッケージにおける型クラスのメソッドと、各種文字列型向け関数の対応表</a></li>
<li><a href="#パフォーマンスに関わる注意事項" title="パフォーマンスに関わる注意事項">⚠️パフォーマンスに関わる注意事項</a></li>
<li><a href="#事例-stringから相互変換できる型を抽象化する" title="事例-stringから相互変換できる型を抽象化する">事例<span class="ascii">:</span> <code>String</code>から相互変換できる型を抽象化する</a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h1 id="mono-traversableパッケージの紹介"><span class="link-to-here-outer"><a href="#mono-traversableパッケージの紹介" title="mono-traversableパッケージの紹介"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">mono-traversable</span>パッケージの紹介</h1>
<p><span class="ascii">mono-traversable</span>パッケージは、名前のとおり<code>MonoTraversable</code>や<code>MonoFoldable</code>、<code>MonoFunctor</code>といったおなじみの型クラスの名前に<code>Mono</code>という接頭辞を付けた型クラスによって、多様なコンテナ型を抽象化してくれます。これらの型クラスはすべて、<code>ByteString</code>や<code>Text</code>のような、「要素として持てる値の型が<span class="ascii">1</span>種類だけ」の型も対象にしているのが特徴です。<span class="ascii">Type Family</span>を応用し、次のように型毎に要素の型を固定することで、そうした特徴を実現しています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Element</span> mono</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Element</span> <span class="dt">ByteString</span> <span class="ot">=</span> <span class="dt">Word8</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Element</span> <span class="dt">Text</span> <span class="ot">=</span> <span class="dt">Char</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Element</span> [a] <span class="ot">=</span> a</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MonoFunctor</span> mono <span class="kw">where</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ...</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  omap ::</span> (<span class="dt">Element</span> mono <span class="ot">-&gt;</span> <span class="dt">Element</span> mono) <span class="ot">-&gt;</span> mono <span class="ot">-&gt;</span> mono</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonoFunctor</span> <span class="dt">ByteString</span> <span class="kw">where</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  omap <span class="ot">=</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">map</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonoFunctor</span> <span class="dt">Text</span> <span class="kw">where</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  omap <span class="ot">=</span> Text.map</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonoFunctor</span> [a] <span class="kw">where</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  omap <span class="ot">=</span> <span class="fu">map</span></span></code></pre></div>
<p>※<span class="ascii">mono-traversable</span>パッケージのソースから引用して少し改変しました。</p>
<p>さらに、これまで紹介した<code>MonoTraversable</code>や<code>MonoFoldable</code>、<code>MonoFunctor</code>に加えて、<code>SemiSequence</code>や<code>IsSequence</code>という型クラスで分解や構築に関わる操作<small>（例えば<code>cons</code>や<code>break</code>）</small>などの他、<small>（今回は取り上げませんが）</small><code>SetContainer</code>などの型クラスで<code>Map</code>や<code>Set</code>、<code>IntMap</code>などの型まで抽象化してくれます。</p>
<p>そこで次の節では、この<span class="ascii">mono-traversable</span>パッケージにおける型クラスを中心に、<code>Data.Text</code>モジュールや<code>Data.ByteString</code>モジュールにおける各関数が、どの型クラスに対するどの関数に対応するのか、まとめた表を作ってみました。</p>
<h1 id="mono-traversableパッケージにおける型クラスのメソッドと各種文字列型向け関数の対応表"><span class="link-to-here-outer"><a href="#mono-traversableパッケージにおける型クラスのメソッドと各種文字列型向け関数の対応表" title="mono-traversableパッケージにおける型クラスのメソッドと各種文字列型向け関数の対応表"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">mono-traversable</span>パッケージにおける型クラスのメソッドと、各種文字列型向け関数の対応表</h1>
<ul>
<li>ℹ️調査した<span class="ascii">mono-traversable</span>パッケージのバージョンは<span class="ascii">1.0.15.3</span>です</li>
<li>ℹ️原則として関数の名前しか見ていないので、実際には異なる用途かも知れません</li>
<li>ℹ️<span class="ascii">mono-traversable</span>パッケージにある型クラスの他、<span class="ascii">base</span>パッケージにある<code>Monoid</code>、<code>Semigroup</code>などのメソッドも調査対象に含めました</li>
<li>ℹ️<code>String</code>については<span class="ascii">base</span>パッケージにある関数のみを対象にしていますが、<code>Data.List</code>モジュールのドキュメントと自分の記憶を頼りに埋めているので間違いがあるかも知れません</li>
<li>ℹ️<code>Text</code>・<code>ByteString</code>については<span class="ascii">Strict</span>なバージョンのドキュメントのみ参照しています。<span class="ascii">Lazy</span>な方になかったらごめんなさい！</li>
<li>ℹ️<code>Textual</code>型クラスについては、<code>ByteString</code>がインスタンスになっていないのでご注意ください</li>
<li>ℹ️以下のような関数は除外しました<span class="ascii">:</span>
<ul>
<li><code>IO</code>が絡むもの</li>
<li>プリミティブな処理で使うもの</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 19%" />
<col style="width: 23%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr>
<th><code>Text</code></th>
<th><code>ByteString</code></th>
<th><code>String</code> <span class="ascii">(</span><code>[Char]</code><span class="ascii">)</span></th>
<th>型クラス <span class="ascii">/</span> 関数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>all</code></td>
<td><code>all</code></td>
<td><code>all</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>oall</code></td>
</tr>
<tr>
<td><code>any</code></td>
<td><code>any</code></td>
<td><code>any</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>oany</code></td>
</tr>
<tr>
<td><code>append</code></td>
<td><code>append</code></td>
<td><code>++</code></td>
<td><code>Semigroup</code> <span class="ascii">/</span> <code>&lt;&gt;</code></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>breakByte</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>breakEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>breakOnAll</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>breakOnEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>breakOn</code></td>
<td><code>breakSubstring</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>break</code></td>
<td><code>break</code></td>
<td><code>break</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>break</code></td>
</tr>
<tr>
<td><code>center</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>chunksOf</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>commonPrefixes</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>compareLength</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>concatMap</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>concatMap</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>ofoldMap</code></td>
</tr>
<tr>
<td><code>concat</code></td>
<td><code>concat</code></td>
<td><code>concat</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>ofold</code></td>
</tr>
<tr>
<td><code>cons</code></td>
<td><code>cons</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>SemiSequence</code> <span class="ascii">/</span> <code>cons</code></td>
</tr>
<tr>
<td><code>copy</code></td>
<td><code>copy</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>count</code></td>
<td><code>count</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>dropAround</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>dropEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>dropEnd</code></td>
</tr>
<tr>
<td><code>dropWhileEnd</code></td>
<td><code>dropWhileEnd</code></td>
<td><code>dropWhileEnd</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>dropWhile</code></td>
<td><code>dropWhile</code></td>
<td><code>dropWhile</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>dropWhile</code></td>
</tr>
<tr>
<td><code>drop</code></td>
<td><code>drop</code></td>
<td><code>drop</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>drop</code></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>elemIndexEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>elemIndex</code></td>
<td><code>elemIndex</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>elemIndices</code></td>
<td><code>elemIndices</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>elem</code></td>
<td><code>elem</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>oelem</code></td>
</tr>
<tr>
<td><code>empty</code></td>
<td><code>empty</code></td>
<td><code>""</code></td>
<td><code>Monoid</code> <span class="ascii">/</span> <code>mempty</code></td>
</tr>
<tr>
<td><code>filter</code></td>
<td><code>filter</code></td>
<td><code>filter</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>filter</code></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>findIndexEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>findIndex</code></td>
<td><code>findIndex</code></td>
<td><code>findIndex</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>findIndices</code></td>
<td><code>findIndices</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>findSubstring</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>findSubstrings</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>find</code></td>
<td><code>find</code></td>
<td><code>find</code></td>
<td><code>SemiSequence</code> <span class="ascii">/</span> <code>find</code></td>
</tr>
<tr>
<td><code>foldl'</code></td>
<td><code>foldl'</code></td>
<td><code>foldl'</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>ofoldl'</code></td>
</tr>
<tr>
<td><code>foldl1'</code></td>
<td><code>foldl1'</code></td>
<td><code>foldl1'</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>ofoldl1Ex'</code></td>
</tr>
<tr>
<td><code>foldl1</code></td>
<td><code>foldl1</code></td>
<td><code>foldl1</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>foldl</code></td>
<td><code>foldl</code></td>
<td><code>foldl</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>foldr'</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>foldr1'</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>foldr1</code></td>
<td><code>foldr1</code></td>
<td><code>foldr1</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>ofoldr1Ex</code></td>
</tr>
<tr>
<td><code>foldr</code></td>
<td><code>foldr</code></td>
<td><code>foldr</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>ofoldr</code></td>
</tr>
<tr>
<td><code>groupBy</code></td>
<td><code>groupBy</code></td>
<td><code>groupBy</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>groupBy</code></td>
</tr>
<tr>
<td><code>group</code></td>
<td><code>group</code></td>
<td><code>group</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>group</code></td>
</tr>
<tr>
<td><code>head</code></td>
<td><code>head</code></td>
<td><code>head</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>headEx</code></td>
</tr>
<tr>
<td><code>index</code></td>
<td><code>index</code></td>
<td><code>index</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>indexEx</code></td>
</tr>
<tr>
<td><code>init</code></td>
<td><code>init</code></td>
<td><code>init</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>initEx</code></td>
</tr>
<tr>
<td><code>inits</code></td>
<td><code>inits</code></td>
<td><code>inits</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>intercalate</code></td>
<td><code>intercalate</code></td>
<td><code>intercalate</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>ointercalate</code></td>
</tr>
<tr>
<td><code>intersperse</code></td>
<td><code>intersperse</code></td>
<td><code>intersperse</code></td>
<td><code>SemiSequence</code> <span class="ascii">/</span> <code>intersperse</code></td>
</tr>
<tr>
<td><code>isInfixOf</code></td>
<td><code>isInfixOf</code></td>
<td><code>isInfixOf</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>isInfixOf</code></td>
</tr>
<tr>
<td><code>isPrefixOf</code></td>
<td><code>isPrefixOf</code></td>
<td><code>isPrefixOf</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>isPrefixOf</code></td>
</tr>
<tr>
<td><code>isSuffixOf</code></td>
<td><code>isSuffixOf</code></td>
<td><code>isSuffixOf</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>isSuffixOf</code></td>
</tr>
<tr>
<td><code>justifyLeft</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>justifyRight</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>last</code></td>
<td><code>last</code></td>
<td><code>last</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>lastEx</code></td>
</tr>
<tr>
<td><code>length</code></td>
<td><code>length</code></td>
<td><code>length</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>olength</code></td>
</tr>
<tr>
<td><code>lines</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>lines</code></td>
<td><code>Textual</code> <span class="ascii">/</span> <code>lines</code></td>
</tr>
<tr>
<td><code>mapAccumL</code></td>
<td><code>mapAccumL</code></td>
<td><code>mapAccumL</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>mapAccumR</code></td>
<td><code>mapAccumR</code></td>
<td><code>mapAccumR</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>map</code></td>
<td><code>map</code></td>
<td><code>map</code></td>
<td><code>MonoFunctor</code> <span class="ascii">/</span> <code>omap</code></td>
</tr>
<tr>
<td><code>maximum</code></td>
<td><code>maximum</code></td>
<td><code>maximum</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>maximumEx</code></td>
</tr>
<tr>
<td><code>minimum</code></td>
<td><code>minimum</code></td>
<td><code>minimum</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>minimumEx</code></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>notElem</code></td>
<td><code>notElem</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>onotElem</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>null</code></td>
<td><code>null</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>onull</code></td>
</tr>
<tr>
<td><code>pack</code></td>
<td><code>pack</code></td>
<td><code>id</code></td>
<td><code>IsString</code> <span class="ascii">/</span> <code>fromString</code></td>
</tr>
<tr>
<td><code>partition</code></td>
<td><code>partition</code></td>
<td><code>partition</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>partition</code></td>
</tr>
<tr>
<td><code>replace</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>replaceSeq</code></td>
</tr>
<tr>
<td><code>replicate</code></td>
<td><code>replicate</code></td>
<td><code>replicate</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>replicate</code></td>
</tr>
<tr>
<td><code>reverse</code></td>
<td><code>reverse</code></td>
<td><code>reverse</code></td>
<td><code>SemiSequence</code> <span class="ascii">/</span> <code>reverse</code></td>
</tr>
<tr>
<td><code>scanl1</code></td>
<td><code>scanl1</code></td>
<td><code>scanl1</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>scanl</code></td>
<td><code>scanl</code></td>
<td><code>scanl</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>scanr1</code></td>
<td><code>scanr1</code></td>
<td><code>scanr1</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>scanr</code></td>
<td><code>scanr</code></td>
<td><code>scanr</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>singleton</code></td>
<td><code>singleton</code></td>
<td><code>singleton</code></td>
<td><code>MonoPointed</code> <span class="ascii">/</span> <code>opoint</code></td>
</tr>
<tr>
<td><code>snoc</code></td>
<td><code>snoc</code></td>
<td><code>snoc</code></td>
<td><code>SemiSequence</code> <span class="ascii">/</span> <code>snoc</code></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>sort</code></td>
<td><code>sort</code></td>
<td><code>SemiSequence</code> <span class="ascii">/</span> <code>sort</code></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>spanEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>span</code></td>
<td><code>span</code></td>
<td><code>span</code></td>
<td><code>SemiSequence</code> <span class="ascii">/</span> <code>span</code></td>
</tr>
<tr>
<td><code>splitAt</code></td>
<td><code>splitAt</code></td>
<td><code>splitAt</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>splitAt</code></td>
</tr>
<tr>
<td><code>splitOn</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>splitOn</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>splitSeq</code></td>
</tr>
<tr>
<td><span class="ascii">N/A</span></td>
<td><code>splitWith</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>splitElem</code></td>
</tr>
<tr>
<td><code>split</code></td>
<td><code>splitWith</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>splitWhen</code></td>
</tr>
<tr>
<td><code>stripEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><code>N/A</code></td>
</tr>
<tr>
<td><code>stripPrefix</code></td>
<td><code>stripPrefix</code></td>
<td><code>stripPrefix</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>stripPrefix</code></td>
</tr>
<tr>
<td><code>stripStart</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>stripSuffix</code></td>
<td><code>stripSuffix</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>stripSuffix</code></td>
</tr>
<tr>
<td><code>strip</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>tail</code></td>
<td><code>tail</code></td>
<td><code>tail</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>tail</code></td>
</tr>
<tr>
<td><code>tails</code></td>
<td><code>tails</code></td>
<td><code>tails</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>takeEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>takeWhileEnd</code></td>
<td><code>takeWhileEnd</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>takeWhile</code></td>
<td><code>takeWhile</code></td>
<td><code>takeWhile</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>takeWhile</code></td>
</tr>
<tr>
<td><code>take</code></td>
<td><code>take</code></td>
<td><code>take</code></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>take</code></td>
</tr>
<tr>
<td><code>toCaseFold</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><code>Textual</code> <span class="ascii">/</span> <code>toCaseFold</code></td>
</tr>
<tr>
<td><code>toLower</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><code>Textual</code> <span class="ascii">/</span> <code>toLower</code></td>
</tr>
<tr>
<td><code>toTitle</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>toUpper</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
<td><code>Textual</code> <span class="ascii">/</span> <code>toUpper</code></td>
</tr>
<tr>
<td><code>transpose</code></td>
<td><code>transpose</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>uncons</code></td>
<td><code>uncons</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>IsSequence</code> <span class="ascii">/</span> <code>uncons</code></td>
</tr>
<tr>
<td><code>unfoldrN</code></td>
<td><code>unfoldrN</code></td>
<td><span class="ascii">N/A</span></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>unfoldr</code></td>
<td><code>unfoldr</code></td>
<td><code>unfoldr</code></td>
<td><span class="ascii">N/A</span></td>
</tr>
<tr>
<td><code>unlines</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>unlines</code></td>
<td><code>Textual</code> <span class="ascii">/</span> <code>unlines</code></td>
</tr>
<tr>
<td><code>unpack</code></td>
<td><code>unpack</code></td>
<td><code>id</code></td>
<td><code>MonoFoldable</code> <span class="ascii">/</span> <code>otoList</code></td>
</tr>
<tr>
<td><code>unsnoc</code></td>
<td><code>unsnoc</code></td>
<td><code>N/A</code></td>
<td><code>SemiSequence</code> <span class="ascii">/</span> <code>unsnoc</code></td>
</tr>
<tr>
<td><code>unwords</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>unwords</code></td>
<td><code>Textual</code> <span class="ascii">/</span> <code>unwords</code></td>
</tr>
<tr>
<td><code>words</code></td>
<td><span class="ascii">N/A</span></td>
<td><code>words</code></td>
<td><code>Textual</code> <span class="ascii">/</span> <code>words</code></td>
</tr>
<tr>
<td><code>zipWith</code></td>
<td><code>zipWith</code></td>
<td><code>zipWith</code></td>
<td><code>MonoZip</code> <span class="ascii">/</span> <code>ozipWith</code></td>
</tr>
<tr>
<td><code>zip</code></td>
<td><code>zip</code></td>
<td><code>zip</code></td>
<td><code>MonoZip</code> <span class="ascii">/</span> <code>ozip</code></td>
</tr>
</tbody>
</table>
<!--
元ネタとして`:browse`した結果をメモしておきます

> :browse Data.Text
T.all :: (Char -> Bool) -> T.Text -> Bool
T.any :: (Char -> Bool) -> T.Text -> Bool
T.append :: T.Text -> T.Text -> T.Text
T.break :: (Char -> Bool) -> T.Text -> (T.Text, T.Text)
T.breakOn :: T.Text -> T.Text -> (T.Text, T.Text)
T.breakOnAll :: T.Text -> T.Text -> [(T.Text, T.Text)]
T.breakOnEnd :: T.Text -> T.Text -> (T.Text, T.Text)
T.center :: Int -> Char -> T.Text -> T.Text
T.chunksOf :: Int -> T.Text -> [T.Text]
T.commonPrefixes ::
  T.Text -> T.Text -> Maybe (T.Text, T.Text, T.Text)
T.compareLength :: T.Text -> Int -> Ordering
T.concat :: [T.Text] -> T.Text
T.concatMap :: (Char -> T.Text) -> T.Text -> T.Text
T.cons :: Char -> T.Text -> T.Text
T.copy :: T.Text -> T.Text
T.count :: T.Text -> T.Text -> Int
T.drop :: Int -> T.Text -> T.Text
T.dropAround :: (Char -> Bool) -> T.Text -> T.Text
T.dropEnd :: Int -> T.Text -> T.Text
T.dropWhile :: (Char -> Bool) -> T.Text -> T.Text
T.dropWhileEnd :: (Char -> Bool) -> T.Text -> T.Text
T.filter :: (Char -> Bool) -> T.Text -> T.Text
T.find :: (Char -> Bool) -> T.Text -> Maybe Char
T.findIndex :: (Char -> Bool) -> T.Text -> Maybe Int
T.foldl :: (a -> Char -> a) -> a -> T.Text -> a
T.foldl' :: (a -> Char -> a) -> a -> T.Text -> a
T.foldl1 :: (Char -> Char -> Char) -> T.Text -> Char
T.foldl1' :: (Char -> Char -> Char) -> T.Text -> Char
T.foldr :: (Char -> a -> a) -> a -> T.Text -> a
T.foldr1 :: (Char -> Char -> Char) -> T.Text -> Char
T.group :: T.Text -> [T.Text]
T.groupBy :: (Char -> Char -> Bool) -> T.Text -> [T.Text]
T.head :: T.Text -> Char
T.index :: T.Text -> Int -> Char
T.init :: T.Text -> T.Text
T.inits :: T.Text -> [T.Text]
T.intercalate :: T.Text -> [T.Text] -> T.Text
T.intersperse :: Char -> T.Text -> T.Text
T.isInfixOf :: T.Text -> T.Text -> Bool
T.isPrefixOf :: T.Text -> T.Text -> Bool
T.isSuffixOf :: T.Text -> T.Text -> Bool
T.justifyLeft :: Int -> Char -> T.Text -> T.Text
T.justifyRight :: Int -> Char -> T.Text -> T.Text
T.last :: T.Text -> Char
T.length :: T.Text -> Int
T.lines :: T.Text -> [T.Text]
T.map :: (Char -> Char) -> T.Text -> T.Text
T.mapAccumL ::
  (a -> Char -> (a, Char)) -> a -> T.Text -> (a, T.Text)
T.mapAccumR ::
  (a -> Char -> (a, Char)) -> a -> T.Text -> (a, T.Text)
T.maximum :: T.Text -> Char
T.minimum :: T.Text -> Char
T.null :: T.Text -> Bool
T.pack :: String -> T.Text
T.partition :: (Char -> Bool) -> T.Text -> (T.Text, T.Text)
T.replace :: T.Text -> T.Text -> T.Text -> T.Text
T.replicate :: Int -> T.Text -> T.Text
T.reverse :: T.Text -> T.Text
T.scanl :: (Char -> Char -> Char) -> Char -> T.Text -> T.Text
T.scanl1 :: (Char -> Char -> Char) -> T.Text -> T.Text
T.scanr :: (Char -> Char -> Char) -> Char -> T.Text -> T.Text
T.scanr1 :: (Char -> Char -> Char) -> T.Text -> T.Text
T.snoc :: T.Text -> Char -> T.Text
T.span :: (Char -> Bool) -> T.Text -> (T.Text, T.Text)
T.split :: (Char -> Bool) -> T.Text -> [T.Text]
T.splitAt :: Int -> T.Text -> (T.Text, T.Text)
T.splitOn :: T.Text -> T.Text -> [T.Text]
T.strip :: T.Text -> T.Text
T.stripEnd :: T.Text -> T.Text
T.stripPrefix :: T.Text -> T.Text -> Maybe T.Text
T.stripStart :: T.Text -> T.Text
T.stripSuffix :: T.Text -> T.Text -> Maybe T.Text
T.tail :: T.Text -> T.Text
T.tails :: T.Text -> [T.Text]
T.take :: Int -> T.Text -> T.Text
T.takeEnd :: Int -> T.Text -> T.Text
T.takeWhile :: (Char -> Bool) -> T.Text -> T.Text
T.takeWhileEnd :: (Char -> Bool) -> T.Text -> T.Text
T.toCaseFold :: T.Text -> T.Text
T.toLower :: T.Text -> T.Text
T.toTitle :: T.Text -> T.Text
T.toUpper :: T.Text -> T.Text
T.transpose :: [T.Text] -> [T.Text]
T.uncons :: T.Text -> Maybe (Char, T.Text)
T.unfoldr :: (a -> Maybe (Char, a)) -> a -> T.Text
T.unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> T.Text
T.unlines :: [T.Text] -> T.Text
T.unsnoc :: T.Text -> Maybe (T.Text, Char)
T.unwords :: [T.Text] -> T.Text
T.words :: T.Text -> [T.Text]
T.zip :: T.Text -> T.Text -> [(Char, Char)]
T.zipWith :: (Char -> Char -> Char) -> T.Text -> T.Text -> T.Text
type T.Text :: *
data T.Text
  = Data.Text.Internal.Text {-# UNPACK #-}Data.Text.Array.Array
                            {-# UNPACK #-}Int
                            {-# UNPACK #-}Int
T.empty :: T.Text
T.singleton :: Char -> T.Text
T.unpack :: T.Text -> String
T.unpackCString# :: GHC.Prim.Addr# -> T.Text

B.all :: (GHC.Word.Word8 -> Bool) -> B.ByteString -> Bool
B.any :: (GHC.Word.Word8 -> Bool) -> B.ByteString -> Bool
B.append :: B.ByteString -> B.ByteString -> B.ByteString
B.appendFile :: FilePath -> B.ByteString -> IO ()
B.break ::
  (GHC.Word.Word8 -> Bool)
  -> B.ByteString -> (B.ByteString, B.ByteString)
B.breakByte ::
  GHC.Word.Word8 -> B.ByteString -> (B.ByteString, B.ByteString)
B.breakEnd ::
  (GHC.Word.Word8 -> Bool)
  -> B.ByteString -> (B.ByteString, B.ByteString)
B.breakSubstring ::
  B.ByteString -> B.ByteString -> (B.ByteString, B.ByteString)
B.concat :: [B.ByteString] -> B.ByteString
B.concatMap ::
  (GHC.Word.Word8 -> B.ByteString) -> B.ByteString -> B.ByteString
B.cons :: GHC.Word.Word8 -> B.ByteString -> B.ByteString
B.copy :: B.ByteString -> B.ByteString
B.count :: GHC.Word.Word8 -> B.ByteString -> Int
B.drop :: Int -> B.ByteString -> B.ByteString
B.dropWhile ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> B.ByteString
B.dropWhileEnd ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> B.ByteString
B.elem :: GHC.Word.Word8 -> B.ByteString -> Bool
B.elemIndex :: GHC.Word.Word8 -> B.ByteString -> Maybe Int
B.elemIndexEnd :: GHC.Word.Word8 -> B.ByteString -> Maybe Int
B.elemIndices :: GHC.Word.Word8 -> B.ByteString -> [Int]
B.empty :: B.ByteString
B.filter ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> B.ByteString
B.find ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> Maybe GHC.Word.Word8
B.findIndex ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> Maybe Int
B.findIndexEnd ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> Maybe Int
B.findIndices :: (GHC.Word.Word8 -> Bool) -> B.ByteString -> [Int]
B.findSubstring :: B.ByteString -> B.ByteString -> Maybe Int
B.findSubstrings :: B.ByteString -> B.ByteString -> [Int]
B.foldl :: (a -> GHC.Word.Word8 -> a) -> a -> B.ByteString -> a
B.foldl' :: (a -> GHC.Word.Word8 -> a) -> a -> B.ByteString -> a
B.foldl1 ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> GHC.Word.Word8)
  -> B.ByteString -> GHC.Word.Word8
B.foldl1' ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> GHC.Word.Word8)
  -> B.ByteString -> GHC.Word.Word8
B.foldr :: (GHC.Word.Word8 -> a -> a) -> a -> B.ByteString -> a
B.foldr' :: (GHC.Word.Word8 -> a -> a) -> a -> B.ByteString -> a
B.foldr1 ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> GHC.Word.Word8)
  -> B.ByteString -> GHC.Word.Word8
B.foldr1' ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> GHC.Word.Word8)
  -> B.ByteString -> GHC.Word.Word8
B.getContents :: IO B.ByteString
B.getLine :: IO B.ByteString
B.group :: B.ByteString -> [B.ByteString]
B.groupBy ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> Bool)
  -> B.ByteString -> [B.ByteString]
B.hGet :: GHC.IO.Handle.Types.Handle -> Int -> IO B.ByteString
B.hGetContents :: GHC.IO.Handle.Types.Handle -> IO B.ByteString
B.hGetLine :: GHC.IO.Handle.Types.Handle -> IO B.ByteString
B.hGetNonBlocking ::
  GHC.IO.Handle.Types.Handle -> Int -> IO B.ByteString
B.hGetSome :: GHC.IO.Handle.Types.Handle -> Int -> IO B.ByteString
B.hPut :: GHC.IO.Handle.Types.Handle -> B.ByteString -> IO ()
B.hPutNonBlocking ::
  GHC.IO.Handle.Types.Handle -> B.ByteString -> IO B.ByteString
B.hPutStr :: GHC.IO.Handle.Types.Handle -> B.ByteString -> IO ()
B.hPutStrLn :: GHC.IO.Handle.Types.Handle -> B.ByteString -> IO ()
B.head :: B.ByteString -> GHC.Word.Word8
B.index :: B.ByteString -> Int -> GHC.Word.Word8
B.init :: B.ByteString -> B.ByteString
B.inits :: B.ByteString -> [B.ByteString]
B.interact :: (B.ByteString -> B.ByteString) -> IO ()
B.intercalate :: B.ByteString -> [B.ByteString] -> B.ByteString
B.intersperse :: GHC.Word.Word8 -> B.ByteString -> B.ByteString
B.isInfixOf :: B.ByteString -> B.ByteString -> Bool
B.isPrefixOf :: B.ByteString -> B.ByteString -> Bool
B.isSuffixOf :: B.ByteString -> B.ByteString -> Bool
B.last :: B.ByteString -> GHC.Word.Word8
B.length :: B.ByteString -> Int
B.map ::
  (GHC.Word.Word8 -> GHC.Word.Word8) -> B.ByteString -> B.ByteString
B.mapAccumL ::
  (acc -> GHC.Word.Word8 -> (acc, GHC.Word.Word8))
  -> acc -> B.ByteString -> (acc, B.ByteString)
B.mapAccumR ::
  (acc -> GHC.Word.Word8 -> (acc, GHC.Word.Word8))
  -> acc -> B.ByteString -> (acc, B.ByteString)
B.maximum :: B.ByteString -> GHC.Word.Word8
B.minimum :: B.ByteString -> GHC.Word.Word8
B.notElem :: GHC.Word.Word8 -> B.ByteString -> Bool
B.null :: B.ByteString -> Bool
B.pack :: [GHC.Word.Word8] -> B.ByteString
B.packCString :: Foreign.C.String.CString -> IO B.ByteString
B.packCStringLen :: Foreign.C.String.CStringLen -> IO B.ByteString
B.partition ::
  (GHC.Word.Word8 -> Bool)
  -> B.ByteString -> (B.ByteString, B.ByteString)
B.putStr :: B.ByteString -> IO ()
B.putStrLn :: B.ByteString -> IO ()
B.readFile :: FilePath -> IO B.ByteString
B.replicate :: Int -> GHC.Word.Word8 -> B.ByteString
B.reverse :: B.ByteString -> B.ByteString
B.scanl ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> GHC.Word.Word8)
  -> GHC.Word.Word8 -> B.ByteString -> B.ByteString
B.scanl1 ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> GHC.Word.Word8)
  -> B.ByteString -> B.ByteString
B.scanr ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> GHC.Word.Word8)
  -> GHC.Word.Word8 -> B.ByteString -> B.ByteString
B.scanr1 ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> GHC.Word.Word8)
  -> B.ByteString -> B.ByteString
B.singleton :: GHC.Word.Word8 -> B.ByteString
B.snoc :: B.ByteString -> GHC.Word.Word8 -> B.ByteString
B.sort :: B.ByteString -> B.ByteString
B.span ::
  (GHC.Word.Word8 -> Bool)
  -> B.ByteString -> (B.ByteString, B.ByteString)
B.spanEnd ::
  (GHC.Word.Word8 -> Bool)
  -> B.ByteString -> (B.ByteString, B.ByteString)
B.split :: GHC.Word.Word8 -> B.ByteString -> [B.ByteString]
B.splitAt :: Int -> B.ByteString -> (B.ByteString, B.ByteString)
B.splitWith ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> [B.ByteString]
B.stripPrefix :: B.ByteString -> B.ByteString -> Maybe B.ByteString
B.stripSuffix :: B.ByteString -> B.ByteString -> Maybe B.ByteString
B.tail :: B.ByteString -> B.ByteString
B.tails :: B.ByteString -> [B.ByteString]
B.take :: Int -> B.ByteString -> B.ByteString
B.takeWhile ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> B.ByteString
B.takeWhileEnd ::
  (GHC.Word.Word8 -> Bool) -> B.ByteString -> B.ByteString
B.transpose :: [B.ByteString] -> [B.ByteString]
B.uncons :: B.ByteString -> Maybe (GHC.Word.Word8, B.ByteString)
B.unfoldr :: (a -> Maybe (GHC.Word.Word8, a)) -> a -> B.ByteString
B.unfoldrN ::
  Int
  -> (a -> Maybe (GHC.Word.Word8, a)) -> a -> (B.ByteString, Maybe a)
B.unpack :: B.ByteString -> [GHC.Word.Word8]
B.unsnoc :: B.ByteString -> Maybe (B.ByteString, GHC.Word.Word8)
B.unzip ::
  [(GHC.Word.Word8, GHC.Word.Word8)] -> (B.ByteString, B.ByteString)
B.useAsCString ::
  B.ByteString -> (Foreign.C.String.CString -> IO a) -> IO a
B.useAsCStringLen ::
  B.ByteString -> (Foreign.C.String.CStringLen -> IO a) -> IO a
B.writeFile :: FilePath -> B.ByteString -> IO ()
B.zip ::
  B.ByteString -> B.ByteString -> [(GHC.Word.Word8, GHC.Word.Word8)]
B.zipWith ::
  (GHC.Word.Word8 -> GHC.Word.Word8 -> a)
  -> B.ByteString -> B.ByteString -> [a]
type B.ByteString :: *
data B.ByteString
  = Data.ByteString.Internal.PS {-# UNPACK #-}(GHC.ForeignPtr.ForeignPtr
                                                 GHC.Word.Word8)
                                {-# UNPACK #-}Int
                                {-# UNPACK #-}Int
-->
<p>以上です。残念ながら万能とはいかないようで、いくつか「<span class="ascii">N/A</span>」、すなわち対応するものがない関数もありますが、他の関数の組み合わせで実装できるものもあるでしょう。</p>
<h1 id="パフォーマンスに関わる注意事項"><span class="link-to-here-outer"><a href="#パフォーマンスに関わる注意事項" title="パフォーマンスに関わる注意事項"><span class="link-to-here">Link to<br />
here</span></a></span>⚠️パフォーマンスに関わる注意事項</h1>
<p><code>MonoTraversable</code>などに限らず、型クラスを使って関数を多相化したとき全般に言えることですが、コンパイル時にインスタンスの解決が行えなかった場合、直接対象の型の相当する関数を呼ぶより少し遅くなってしまう場合があります（<a href="https://blog.miz-ar.info/2016/06/writing-efficient-program-with-haskell/#2.specialization">参考</a>）。</p>
<p>また、それに限らず、各型クラスのメソッドでない関数は、各型の相当する関数でオーバーライドできないため、効率の悪い処理になってしまう恐れがあります。例えば、<a href="https://hackage.haskell.org/package/mono-traversable-1.0.15.3/docs/src/Data.MonoTraversable.html#ointercalate"><code>ointercalate</code>関数</a>の実装を見ると、<code>Text</code>や<code>ByteString</code>などについては<code>RULES</code>プラグマで最適な実装を設定しているようですが、それ以外の型については一旦リストに変換してから結合する、という効率の悪そうな処理をしています。</p>
<h1 id="事例-stringから相互変換できる型を抽象化する"><span class="link-to-here-outer"><a href="#事例-stringから相互変換できる型を抽象化する" title="事例-stringから相互変換できる型を抽象化する"><span class="link-to-here">Link to<br />
here</span></a></span>事例<span class="ascii">:</span> <code>String</code>から相互変換できる型を抽象化する</h1>
<p>最後に、最近私が作った（まだリリースしてない）ライブラリーにおいて、<code>MonoFoldable</code>と<code>IsString</code>を使うことで、<code>Text</code>と<code>String</code>両方をサポートした関数を紹介しておきます。ただ、時間とやる気パワーが残り少なくなってしまったので、該当の箇所だけ<a href="https://github.com/igrep/envparse-applicative/blob/0fb7b23e45a09b4f53406b46bd563312ed27f2a4/src/EnvParse/Applicative.hs#L156">こちら</a>からコピペして、説明は簡単にしておきます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stringVal ::</span> (<span class="dt">IsString</span> a, <span class="dt">MT.MonoFoldable</span> a, <span class="dt">MT.Element</span> a <span class="op">~</span> <span class="dt">Char</span>) <span class="ot">=&gt;</span> <span class="dt">CodecEnvVal</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>stringVal <span class="ot">=</span> valByFunction <span class="dt">CodecEnvValByFunction</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  { encode <span class="ot">=</span> MT.otoList</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  , decode <span class="ot">=</span> <span class="dt">Right</span> <span class="op">.</span> fromString</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p><code>CodecEnvVal a</code>型は、<code>a</code>型を<code>String</code>型と相互変換するための情報を含んだ型です。<code>stringVal</code>の場合、名前のとおり文字列っぽい型と<code>String</code>との相互変換ができなければなりません。もちろん単純に<code>String</code>型だけをサポートして<code>Text</code>用には別途<code>CodecEnvVal Text</code>を作ってもいいのですが、一つの<code>CodecEnvVal a</code>だけで扱えた方が楽でしょうし、今回は<code>MonoFoldable</code>の<code>otoList</code>と<code>IsString</code>の<code>fromString</code>を使って両方をサポートすることにしました。なお、これでは<code>ByteString</code>がサポートできませんが、ここで相互変換する<code>String</code>は、要件上人間が読み書きするファイルにおける文字列を想定しているので、<code>ByteString</code>はバイナリーデータにだけ使うべきだ、という立場から敢えてサポートしていません。</p>
<h1 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h1>
<p><span class="ascii">mono-traversable</span>パッケージをうまく使えば、自前で専用の型クラスを作らなくても<code>String</code>・<code>Text</code>・<code>ByteString</code>などを一挙にサポートする関数が書けるかも知れません！</p>
<p>それでは<span class="ascii">2022</span>年は<span class="ascii">mono-traversable</span>で<span class="ascii">Happy Haskell String Programming!</span>🚝</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2022/disband_admins.html" lang="ja">一般社団法人としてのHaskell-jp Admins解散のお知らせ</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2021/symbols-in-ghc.html" style="margin-left: auto;" lang="ja">Haskellにおける記号の調べ方</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskellにおける記号の調べ方</title>
    <link href="https://haskell.jp/blog/posts/2021/symbols-in-ghc.html" />
    <id>https://haskell.jp/blog/posts/2021/symbols-in-ghc.html</id>
    <published>2021-12-25T00:00:00Z</published>
    <updated>2021-12-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>この記事は<a href="https://qiita.com/advent-calendar/2021/gseach">ググって解決しづらかったこと <span class="ascii">Advent Calendar 2021</span></a>の<span class="ascii">25</span>日目の記事です。<a href="https://wiki.haskell.jp/Hikers%20Guide%20to%20Haskell"><span class="ascii">Haskell-jp Wiki</span>の<span class="ascii">Haskell</span>の歩き方</a>というページにもほぼ同じことを書きましたが、今回はよい機会なので実例を加えつつ詳しく紹介させてください。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#二項演算子記号関数の調べ方" title="二項演算子記号関数の調べ方">二項演算子（記号関数）の調べ方</a></li>
<li><a href="#ユーザーが定義した二項演算子ではないものの調べ方" title="ユーザーが定義した二項演算子ではないものの調べ方">ユーザーが定義した二項演算子ではないものの調べ方</a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h1 id="二項演算子記号関数の調べ方"><span class="link-to-here-outer"><a href="#二項演算子記号関数の調べ方" title="二項演算子記号関数の調べ方"><span class="link-to-here">Link to<br />
here</span></a></span>二項演算子（記号関数）の調べ方</h1>
<p>よく知られているとおり、<span class="ascii">Haskell</span>には二項演算子をプログラマーがかなり自由に定義できるという、とても変わった特徴があります。他のプログラミング言語でも使う標準的なもの（例<span class="ascii">:</span> <code>+</code><span class="ascii">,</span> <code>*</code><span class="ascii">,</span> <code>&amp;&amp;</code>など）を名前空間を絞って置き換えるほか、<a href="https://hackage.haskell.org/package/lens-5.1/docs/Control-Lens-Operators.html">例えばかの<span class="ascii">lens</span>パッケージのように</a>、ライブラリーの作者があたかも新しい構文を作り上げるかのごとく独自の二項演算子を提供することができます。</p>
<p>これは面白い機能ではあるものの、しばしば混乱を招く機能でもあります。後述するその他の記号との区別がつきにくいですし、一般的な検索エンジンで検索することさえままなりません。<a href="https://blog.fkoji.com/2017/03052055.html"><span class="ascii">Google</span>はプログラミングでよく使われる記号による検索をサポートはしている</a>ものの、<span class="ascii">Haskell</span>でしか見ないような記号の組み合わせは到底無理でしょう。</p>
<p>そんな背景もあり、<span class="ascii">Haskell</span>を使う人はしばしば<a href="https://hoogle.haskell.org/"><span class="ascii">Hoogle</span></a>などの、関数名で検索できる検索エンジンを使用することになります。こちらは二項演算子の名前での検索もサポートしています。</p>
<p>例えば<span class="ascii">lens</span>パッケージでおなじみの<code>^.</code>で検索すると<a href="https://hoogle.haskell.org/?hoogle=%5E.">次のような結果になりました</a><span class="ascii">:</span></p>
<figure>
<img src="/img/2021/symbols-in-ghc/hoogle.png" alt="Hoogleによる検索結果の例" />
<figcaption aria-hidden="true"><span class="ascii">Hoogle</span>による検索結果の例</figcaption>
</figure>
<p><span class="ascii">lens</span>パッケージ以外でも、同様の<code>^.</code>が定義されているのが分かりますね。<span class="ascii">lens</span>パッケージは依存関係がとても大きい一方、<code>^.</code>などの定義は十分単純でコピペしてもいいくらい小さいので、このようにいくつものパッケージで定義されています。</p>
<p>また、特によく使われる二項演算子は<span class="ascii">FPComplete</span>のウェブサイトでもまとめられています<span class="ascii">:</span></p>
<p><a href="https://www.fpcomplete.com/haskell/tutorial/operators/"><span class="ascii">Operator Glossary</span></a></p>
<h1 id="ユーザーが定義した二項演算子ではないものの調べ方"><span class="link-to-here-outer"><a href="#ユーザーが定義した二項演算子ではないものの調べ方" title="ユーザーが定義した二項演算子ではないものの調べ方"><span class="link-to-here">Link to<br />
here</span></a></span>ユーザーが定義した二項演算子ではないものの調べ方</h1>
<p><span class="ascii">Haskell</span>、というかそのデファクトスタンダードな処理系である<span class="ascii">GHC</span>では、<a href="https://haskell.jp/blog/posts/2018/about-ghc-exts-1.html">言語拡張</a>という形で長年新しい構文が提案されています<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。その中には、当然これまでにない方法で記号を使っているものもあります。そうした記号はプログラマーが定義した関数ではないので、前述の<span class="ascii">Hoogle</span>などを使った方法が通用しません。そこで、当ブログにも何度も寄稿いただいた<span class="ascii">@takenobu_hs</span>さんが、言語拡張によるものも含めた、<span class="ascii">Haskell</span>の構文における記号の一覧を作ってくださいました！</p>
<p><a href="https://github.com/takenobu-hs/haskell-symbol-search-cheatsheet"><span class="ascii">takenobu-hs/haskell-symbol-search-cheatsheet</span></a></p>
<p>実は日本語版も<a href="https://qiita.com/takenobu-hs/items/b95f0a4409c59440d4a9"><span class="ascii">Qiita</span>に</a>あるのですが、上記の<span class="ascii">GitHub</span>版の方が更新されているようです。そこで、今回はおまけとして、<a href="https://github.com/takenobu-hs/haskell-symbol-search-cheatsheet#--overloadedrecorddot"><span class="ascii">GitHub</span>版の方にも載っている</a>、<span class="ascii">GHC</span>に最近（バージョン<span class="ascii">9.2.1</span>以降に）追加された、新しいピリオド <code>.</code> の使い方を紹介しましょう。</p>
<p>従来、<span class="ascii">Haskell</span>でピリオドといえば関数合成を表す二項演算子でした<span class="ascii">:</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> f x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> g x <span class="ot">=</span> x <span class="op">*</span> <span class="dv">3</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> h <span class="ot">=</span> g <span class="op">.</span> f</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> h <span class="dv">2</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span> <span class="co">-- 2 に + 1 して * 3 した結果</span></span></code></pre></div>
<p>数学における関数合成の記号「<span class="ascii">g</span> ∘ <span class="ascii">f</span>」に似せてピリオドを採用したのでしょう。しかし、世は今まさに<strong>大「ピリオドといえばフィールド<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>へのアクセス演算子じゃろがい」時代</strong>です。それでなくても<span class="ascii">Haskell</span>のレコード型は扱いにくいと言われているのに、フィールドへのアクセスまで変なやり方でした<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a><span class="ascii">:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeRecord</span> <span class="ot">=</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SomeRecord</span> {<span class="ot"> field1 ::</span> <span class="dt">String</span>,<span class="ot"> field2 ::</span> <span class="dt">Int</span> }</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>someRecord <span class="ot">=</span> <span class="dt">SomeRecord</span> <span class="st">&quot;value1&quot;</span> <span class="dv">2</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> field1 someRecord</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;value1&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> field2 someRecord</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span></code></pre></div>
<p>そこで、<span class="ascii">GHC 9.2</span>からは<a href="https://downloads.haskell.org/ghc/9.2.1/docs/html/users_guide/exts/overloaded_record_dot.html#overloaded-record-dot"><code>OverloadedRecordDot</code></a>という言語拡張が導入され、これを有効にしたファイルではおなじみの言語のようにピリオドでレコードのフィールドにアクセスできるようになりました<span class="ascii">:</span></p>
<p>（以下は<span class="ascii">GHCi</span>で使用した例です）</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedRecordDot</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> someRecord<span class="op">.</span>field1</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;value1&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> someRecord<span class="op">.</span>field2</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- ⚠️ピリオドの前後に空白を入れると関数合成として解釈されてしまう！</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> someRecord <span class="op">.</span> field2</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">5</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">?</span> <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘<span class="dt">Int</span> <span class="ot">-&gt;</span> c’</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                  with actual <span class="kw">type</span> ‘<span class="dt">SomeRecord</span>’</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">?</span> <span class="dt">In</span> the first argument <span class="kw">of</span> ‘(<span class="op">.</span>)’, namely ‘someRecord’</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> the expression<span class="op">:</span> someRecord <span class="op">.</span> field2</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> an equation for ‘it’<span class="op">:</span> it <span class="ot">=</span> someRecord <span class="op">.</span> field2</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">?</span> <span class="dt">Relevant</span> bindings include</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="ot">        it ::</span> <span class="dt">SomeRecord</span> <span class="ot">-&gt;</span> c (bound at <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">5</span><span class="op">:</span><span class="dv">1</span>)</span></code></pre></div>
<p><code>OverloadedRecordDot</code>についてのより詳しい解説は、<a href="https://youtu.be/haZl-q6mfyk?t=2581"><span class="ascii">Haskell Day 2021</span>における、<span class="ascii">fumieval</span>さんの発表</a>をご覧ください。</p>
<h1 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h1>
<ul>
<li>他のプログラマーが定義した、二項演算子（記号関数）を調べるときは<span class="ascii">:</span>
<ul>
<li><a href="https://hoogle.haskell.org/"><span class="ascii">Hoogle</span></a></li>
<li>補足<span class="ascii">: Stackage</span>の最新の<span class="ascii">LTS</span>から検索したいときは<a href="https://www.stackage.org/"><span class="ascii">Stackage</span></a>のページ上部にあるフォームで検索してみましょう。こちらも内部は<span class="ascii">Hoogle</span>が使われています。</li>
</ul></li>
<li>それ以外の場合は<span class="ascii">:</span>
<ul>
<li><a href="https://github.com/takenobu-hs/haskell-symbol-search-cheatsheet"><span class="ascii">takenobu-hs/haskell-symbol-search-cheatsheet</span></a></li>
</ul></li>
<li><span class="ascii">Haskell</span>のレコード型に嫌気が差したら<span class="ascii">:</span>
<ul>
<li><a href="https://youtu.be/haZl-q6mfyk?t=2581"><span class="ascii">Haskell Day 2021</span>における、<span class="ascii">fumieval</span>さんの発表</a>を観て<a href="https://downloads.haskell.org/ghc/9.2.1/docs/html/users_guide/exts/overloaded_record_dot.html#overloaded-record-dot"><code>OverloadedRecordDot</code>拡張</a>について勉強しましょう。</li>
</ul></li>
</ul>
<p>🎁それでは<span class="ascii">2022</span>年も<span class="ascii">Happy Haskell Hacking!!</span>🎅</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>余談<span class="ascii">:</span> <a href="https://github.com/ghc-proposals/ghc-proposals"><span class="ascii">ghc-proposals</span></a>に送られた<span class="ascii">Pull request</span>を見ると、今どのような提案が議論されているか分かります。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>他のプログラミング言語では「プロパティー」と呼ばれることも多いですが、ここでは<span class="ascii">Haskell</span>のレコード型における用語に合わせました。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>個人的にはゲッターが関数になるのはとても直感的な気がして割と好きでしたが、確かにデメリットもとても多い仕様でした。セッターは単純な関数になってないですしね。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2021/text-mono-traversable.html" lang="ja">文字列型を抽象化するのにはmono-traversableパッケージがいいかも</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2021/haskell-day-2021.html" style="margin-left: auto;" lang="ja">Haskell Day 2021を開催します</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Day 2021を開催します</title>
    <link href="https://haskell.jp/blog/posts/2021/haskell-day-2021.html" />
    <id>https://haskell.jp/blog/posts/2021/haskell-day-2021.html</id>
    <published>2021-06-14T00:00:00Z</published>
    <updated>2021-06-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p><a href="https://haskell.jp/haskell-day-2021/"><span class="ascii">Haskell Day 2021</span></a>を開催します！</p>
<p><a href="https://haskell.jp/haskell-day-2021/"><img src="../../img/2021/haskell-day-2021/ogp.png" alt="Haskell Day 2021" /></a></p>
<p>こんにちは<span class="ascii">kakkun61</span>こと岡本和樹です。</p>
<p>この記事では<a href="https://haskell.jp/haskell-day-2021/"><span class="ascii">Haskell Day 2021</span></a>の紹介と開催の経緯などを記載します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#経緯" title="経緯">経緯</a></li>
<li><a href="#発表者募集" title="発表者募集">発表者募集</a></li>
<li><a href="#参加登録" title="参加登録">参加登録</a></li>
</ul>
</div>
</div>
<h1 id="経緯"><span class="link-to-here-outer"><a href="#経緯" title="経緯"><span class="link-to-here">Link to<br />
here</span></a></span>経緯</h1>
<p><span class="ascii">Haskell Day</span>は日本語で開催される<span class="ascii">Haskell</span>に関するイベントとしては最多の参加者を誇るイベントです。これまで<span class="ascii">2012</span>・<span class="ascii">2016</span>・<span class="ascii">2018</span>・<span class="ascii">2019</span>と開催してきました。新型コロナウイルスの影響により、残念ながら<span class="ascii">2020</span>は開催しませんでしたが、<span class="ascii">2021</span>は<em>オンライン</em>イベントとして開催します。</p>
<p>このようなオンラインイベントの開催は未経験だったため、さまざまなイベント形式を検討した結果、今回は事前録画動画の予約公開という形式を採用しました。生放送ももちろん検討しましたが、ノウハウ不足の中で一発勝負という生放送はリスクが大きいという判断をしました。録画公開における臨場感の不足をおぎなうことを期待し、<span class="ascii">YouTube</span>の<a href="https://creatoracademy.youtube.com/page/course/hype-with-premieres">プレミア公開</a>を使用しリアルタイムチャットによる発表者と視聴者・視聴者同士の交流をできるように予定しています。</p>
<h1 id="発表者募集"><span class="link-to-here-outer"><a href="#発表者募集" title="発表者募集"><span class="link-to-here">Link to<br />
here</span></a></span>発表者募集</h1>
<p>現在<a href="https://haskell.jp/haskell-day-2021/#call-for-papers">発表者募集</a>中です！</p>
<p>今回はオンライン開催ということで、お手数ですが発表者にもオンサイトのイベントと異なった準備をお願いすることになります。運営としてできるかぎりのサポートをしますので安心して応募いただければと思います。</p>
<h1 id="参加登録"><span class="link-to-here-outer"><a href="#参加登録" title="参加登録"><span class="link-to-here">Link to<br />
here</span></a></span>参加登録</h1>
<p><a href="https://haskell-jp.connpass.com/event/215363/"><span class="ascii">Connpass</span></a>にて参加登録の受け付けもしていますので視聴者の方も登録をお願いします。</p>
<p>その他のくわしい情報は<a href="https://haskell.jp/haskell-day-2021/"><span class="ascii">Haskell Day 2021</span>イベントページ</a>をご覧ください。</p>
<p>みなさまのご応募をお待ちしています。またお体にお気をつけください。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2021/symbols-in-ghc.html" lang="ja">Haskellにおける記号の調べ方</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/grc.html" style="margin-left: auto;" lang="ja">「相互を尊重したコミュニケーションのためのガイドライン」制定のお知らせ</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>「相互を尊重したコミュニケーションのためのガイドライン」制定のお知らせ</title>
    <link href="https://haskell.jp/blog/posts/grc.html" />
    <id>https://haskell.jp/blog/posts/grc.html</id>
    <published>2021-05-30T00:00:00Z</published>
    <updated>2021-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="about_admins.html">先日の<span class="ascii">Haskell-jp Admins</span></a>と同様に事務的な連絡で恐縮ですが、当ブログや<a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>、<a href="https://github.com/haskell-jp"><span class="ascii">GitHub</span>の<span class="ascii">Organization</span></a>などにおけるコミュニケーションに適用される、<a href="https://github.com/haskell-jp/community/blob/master/GRC.md">「相互を尊重したコミュニケーションのためのガイドライン」</a>を制定致しました。</p>
<p><a href="https://github.com/haskell-jp/community/blob/master/GRC.md"><span class="ascii">Haskell-jp</span> 相互を尊重したコミュニケーションのためのガイドライン</a></p>
<p>こちらは<a href="https://haskell.foundation/guidelines-for-respectful-communication/"><span class="ascii">Haskell Foundation</span>における<span class="ascii">Guidelines for Respectful Communication (GRC)</span></a>を日本語に翻訳し、運用主体などを<span class="ascii">Haskell-jp</span>における実態に合わせて書き換えたものです。いわゆる「行動規範<small>（<span class="ascii">Code Of Conduct</span>。しばしば「<span class="ascii">COC</span>」と略されます）</small>」と同じ役割を果たすものですが、行動規範と異なり、禁止事項よりも推奨事項を数多く挙げているのが特徴です。<a href="https://github.com/haskell-jp/community/pull/29">この<span class="ascii">GRC</span>を翻訳する前に、<span class="ascii">COC</span>を提案した際の議論</a>において<span class="ascii">GRC</span>のこうした特徴が好まれ、採用に至りました。</p>
<p>この<span class="ascii">GRC</span>は、今後<a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>や<a href="https://github.com/haskell-jp/"><span class="ascii">Haskell-jp</span>の<span class="ascii">GitHub</span>における<span class="ascii">Organization</span>が管理するリポジトリー</a>、それから<span class="ascii">Haskell-jp</span>として開催するイベントなど、様々な場面で適用されます。参加されるみなさんはご理解の上、快適なコミュニティー活動をお楽しみください。</p>
<p>加えて、もちろん今秋開催予定の<a href="https://haskell.jp/haskell-day-2021/"><span class="ascii">Haskell Day 2021</span></a>においても、こちらの<span class="ascii">GRC</span>を採用します。参加者、発表者、運営者の方々はご理解とご協力をよろしくお願いします。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2021/haskell-day-2021.html" lang="ja">Haskell Day 2021を開催します</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/about_admins.html" style="margin-left: auto;" lang="ja">日本Haskellユーザーグループ管理委員会（Haskell-jp Admins）設立のお知らせ</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>日本Haskellユーザーグループ管理委員会（Haskell-jp Admins）設立のお知らせ</title>
    <link href="https://haskell.jp/blog/posts/about_admins.html" />
    <id>https://haskell.jp/blog/posts/about_admins.html</id>
    <published>2021-03-29T00:00:00Z</published>
    <updated>2021-03-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#重大な追記" title="重大な追記"><span class="ascii">2022/09/18</span> 重大な追記</a></li>
<li><a href="#背景" title="背景">背景</a></li>
<li><a href="#今後の活動と連絡先" title="今後の活動と連絡先">今後の活動と連絡先</a></li>
<li><a href="#現在の理事社員" title="現在の理事社員">現在の理事・社員</a></li>
<li><a href="#所在地" title="所在地">所在地</a></li>
<li><a href="#定款" title="定款">定款</a></li>
</ul>
</div>
</div>
<h1 id="重大な追記"><span class="link-to-here-outer"><a href="#重大な追記" title="重大な追記"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">2022/09/18</span> 重大な追記</h1>
<p>⚠️一般社団法人としての日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会は、<span class="ascii">2022</span>年<span class="ascii">4</span>月<span class="ascii">16</span>日を以て解散しました。今後は任意団体として活動を続けます。詳細は<a href="./2022/disband_admins.html">一般社団法人日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会 解散のお知らせ</a>をご覧ください。</p>
<p>以下では、記録のために設立当時の記事をほぼそのまま残しています。</p>
<hr />
<p>去る<span class="ascii">2021</span>年<span class="ascii">2</span>月<span class="ascii">9</span>日、任意団体であり明確な会員資格を持たない、<a href="https://haskell.jp/blog/posts/about_us.html">日本<span class="ascii">Haskell</span>ユーザーグループ（<span class="ascii">Haskell-jp</span>）</a>における共有財産やコミュニケーションの場の管理・運営を担う法人として、一般社団法人日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会（通称 <span class="ascii">Haskell-jp Admins</span>。<a href="https://www.houjin-bangou.nta.go.jp/henkorireki-johoto.html?selHouzinNo=5020005014971">法人番号 <span class="ascii">5020005014971</span></a>）を設立しました。法人格を持つことを活かして、<span class="ascii">Haskell-jp Admins</span>は次の事業に取り組みます。</p>
<ul>
<li>プログラミング言語<span class="ascii">Haskell</span>に関するイベントの企画・開催・運営
<ul>
<li>イベントの会場を借りたり、ノベルティーを作成したりする際の名義として使用する予定です</li>
</ul></li>
<li><span class="ascii">haskell.jp</span> ドメインの維持・管理</li>
<li><a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>を始めとする、交流や情報共有を行う場の提供・管理・運営</li>
<li>そのほか、上記に関連して必要なこと</li>
</ul>
<h1 id="背景"><span class="link-to-here-outer"><a href="#背景" title="背景"><span class="link-to-here">Link to<br />
here</span></a></span>背景</h1>
<p>そもそもの設立の動機は、山下さん（<a href="https://twitter.com/nobsun"><span class="ascii">@nobsun</span></a>）の好意によって個人名義で保有していた<span class="ascii">haskell.jp</span> ドメインを共同で管理出来るようにするためでした。ドメインを団体として保有するには、法人格と、法人名義の銀行口座が必要なのです。これ以外にも、<span class="ascii">Haskell-jp</span>として共有する価値のあるアカウントを管理する際の名義として、随時「日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会」を使用します。</p>
<h1 id="今後の活動と連絡先"><span class="link-to-here-outer"><a href="#今後の活動と連絡先" title="今後の活動と連絡先"><span class="link-to-here">Link to<br />
here</span></a></span>今後の活動と連絡先</h1>
<p><span class="ascii">Haskell-jp Admins</span>が出来たからといって、<span class="ascii">Haskell-jp</span>のあり方が大きく変わることはありません。今後も<span class="ascii">Slack</span>で質問したり議論したり<a href="https://haskell.jp/blog/">ブログ</a>記事を書いたりしましょう！<a href="https://haskell.jp/"><span class="ascii">haskell.jp</span></a>というドメインを活かし、「公式面して」自由に活動する方をいつでも待っています！</p>
<ul>
<li>公の場で提案・相談したい場合は<span class="ascii">:</span>
<ul>
<li>前述の<a href="https://haskell.jp/signin-slack.html"><span class="ascii">Haskell-jp</span>の<span class="ascii">Slack Workspace</span></a>の<span class="ascii">#random</span>チャンネルなどで投稿いただくか、</li>
<li><a href="https://github.com/haskell-jp/community/issues"><span class="ascii">haskell-jp/community</span>に<span class="ascii">issue</span></a>として登録したり、</li>
<li><a href="https://twitter.com/haskell_jp"><span class="ascii">Haskell-jp</span>の<span class="ascii">Twitter</span>アカウント <span class="ascii">@haskell_jp</span></a>にメンションをください。</li>
</ul></li>
<li>プライベートに提案・相談したい場合は<span class="ascii">:</span>
<ul>
<li><span class="ascii">haskell-jp-admins@googlegroups.com</span> にメールを送ってください</li>
</ul></li>
</ul>
<p>我々<span class="ascii">Haskell-jp Admins</span>は、そうした活動をバックアップするために種々の問題に取り組んでいきます。</p>
<h1 id="現在の理事社員"><span class="link-to-here-outer"><a href="#現在の理事社員" title="現在の理事社員"><span class="link-to-here">Link to<br />
here</span></a></span>現在の理事・社員</h1>
<ul>
<li>代表理事<span class="ascii">:</span> 山本悠滋（<a href="https://twitter.com/igrep"><span class="ascii">@igrep</span></a>）</li>
<li>社員<span class="ascii">:</span>
<ul>
<li>中嶋大嗣（<a href="https://twitter.com/nakaji_dayo/"><span class="ascii">@nakaji_dayo</span></a><span class="ascii">)</span></li>
<li>山下伸夫（<a href="https://twitter.com/nobsun"><span class="ascii">@nobsun</span></a>）</li>
<li>岡本和樹（<a href="https://twitter.com/kakkun61"><span class="ascii">@kakkun61</span></a>）</li>
<li>木下郁章（<a href="https://twitter.com/fumieval"><span class="ascii">@fumieval</span></a>）</li>
<li>廣瀬達也（<a href="https://twitter.com/lotz84_"><span class="ascii">@lotz84_</span></a>）</li>
</ul></li>
</ul>
<h1 id="所在地"><span class="link-to-here-outer"><a href="#所在地" title="所在地"><span class="link-to-here">Link to<br />
here</span></a></span>所在地</h1>
<p><strong><span class="ascii">2022/09/18</span> 編集</strong><span class="ascii">:</span> 法人格を廃止するとともに、契約したバーチャルオフィスの規約に従い、こちらに記載していた住所も削除しました。</p>
<h1 id="定款"><span class="link-to-here-outer"><a href="#定款" title="定款"><span class="link-to-here">Link to<br />
here</span></a></span>定款</h1>
<p>こちらに一部個人情報を削除した上で掲載しています。</p>
<p><a href="https://github.com/haskell-jp/community/blob/master/admins/article.md">一般社団法人 日本<span class="ascii">Haskell</span>ユーザーグループ管理委員会 定款</a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/grc.html" lang="ja">「相互を尊重したコミュニケーションのためのガイドライン」制定のお知らせ</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/break-monad-law-with-writer.html" style="margin-left: auto;" lang="ja">Writer Monadで気軽にMonad則を破る</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Writer Monadで気軽にMonad則を破る</title>
    <link href="https://haskell.jp/blog/posts/2020/break-monad-law-with-writer.html" />
    <id>https://haskell.jp/blog/posts/2020/break-monad-law-with-writer.html</id>
    <published>2020-12-25T00:00:00Z</published>
    <updated>2020-12-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>🎅この記事は、<a href="https://qiita.com/advent-calendar/2020/haskell"><span class="ascii">Haskell Advent Calendar 2020</span></a> <span class="ascii">25</span>日目の記事です。<br />
🎄<span class="ascii">Happy Christmas!!</span>🎄</p>
<p>今回は先日<small>（といっても元の質問の投稿からもう何ヶ月も経ってしまいましたが…）</small><span class="ascii">StackOverflow</span>に上がったこちら👇の質問に対する回答の、続きっぽい話を書こうと思います。長いし、質問の回答からスコープが大きく外れてしまうので記事にしました。</p>
<p><a href="https://ja.stackoverflow.com/questions/70079/%E3%83%A2%E3%83%8A%E3%83%89%E5%89%87%E3%82%92%E5%B4%A9%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%86%E4%BE%8B%E3%81%8C%E7%9F%A5%E3%82%8A%E3%81%9F%E3%81%84"><span class="ascii">haskell -</span> モナド則を崩してしまう例が知りたい <span class="ascii">-</span> スタック・オーバーフロー</a></p>
<p><code>Monad</code>と<code>Monoid</code>にある重要な繋がりを説明した後、それを応用した<code>Writer</code> <code>Monad</code>がどう<code>Monoid</code>を使って<code>Monad</code>則を満たしているのか証明します。そして、<code>Writer</code>のそうした性質を用いて簡単に<code>Monad</code>則を破る例を紹介することで、読者のみなさんが<code>Monad</code>則のみならず<code>do</code>記法や<code>Monad</code>そのものの性質について、よりはっきりとした理解が得られることを目指します。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#サンプルコードについて" title="サンプルコードについて">サンプルコードについて</a></li>
<li><a href="#monadとmonoidの切っても切り離せない関係" title="monadとmonoidの切っても切り離せない関係"><code>Monad</code>と<code>Monoid</code>の切っても切り離せない関係</a>
<ul>
<li><a href="#monoidの例" title="monoidの例"><code>Monoid</code>の例</a></li>
</ul></li>
<li><a href="#monoidとwriterの切っても切り離せない関係" title="monoidとwriterの切っても切り離せない関係"><code>Monoid</code>と<code>Writer</code>の切っても切り離せない関係</a>
<ul>
<li><a href="#doと" title="doと"><code>do</code>と<code>&lt;&gt;</code></a></li>
<li><a href="#writer-monadの結合則とmonoidの結合則" title="writer-monadの結合則とmonoidの結合則"><code>Writer</code> <code>Monad</code>の結合則と<code>Monoid</code>の結合則</a></li>
</ul></li>
<li><a href="#関係を壊してみる" title="関係を壊してみる">関係を壊してみる</a>
<ul>
<li><a href="#とmonoidの結合則" title="とmonoidの結合則"><code>&lt;&gt;</code>と<code>Monoid</code>の結合則</a></li>
<li><a href="#とmonadの結合則" title="とmonadの結合則"><code>&gt;&gt;=</code>と<code>Monad</code>の結合則</a></li>
<li><a href="#do記法とmonadの結合則" title="do記法とmonadの結合則"><code>do</code>記法と<code>Monad</code>の結合則</a></li>
</ul></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h1 id="サンプルコードについて"><span class="link-to-here-outer"><a href="#サンプルコードについて" title="サンプルコードについて"><span class="link-to-here">Link to<br />
here</span></a></span>サンプルコードについて</h1>
<p>本記事のサンプルコードは、<span class="ascii">Haskell</span>の構文に準拠していないものを除いて、すべて<a href="https://github.com/igrep/readme-test"><span class="ascii">readme-test</span></a>というツールの<a href="https://github.com/igrep/readme-test/tree/f6ce7a6f5ce5f5f8031cd5dfedc8c6e47c13b1f3"><span class="ascii">2020</span>年<span class="ascii">12</span>月<span class="ascii">13</span>日時点の開発版</a>でテストしました。こちらのツールはまだ開発中で、今後も仕様が大きく変わる可能性がありますが、この記事のサンプルコードをテストするのに必要な機能は十分にそろっています。この<span class="ascii">readme-test</span>自体についてはいつか改めて共有します。</p>
<p>また、テストの際に用いた環境は以下の通りです<span class="ascii">:</span></p>
<ul>
<li><span class="ascii">Windows 10 Pro 20H2</span></li>
<li><span class="ascii">GHC 8.10.1</span></li>
<li><a href="https://www.stackage.org/nightly-2020-08-15"><span class="ascii">Stackage nightly-2020-08-15</span></a></li>
</ul>
<h1 id="monadとmonoidの切っても切り離せない関係"><span class="link-to-here-outer"><a href="#monadとmonoidの切っても切り離せない関係" title="monadとmonoidの切っても切り離せない関係"><span class="link-to-here">Link to<br />
here</span></a></span><code>Monad</code>と<code>Monoid</code>の切っても切り離せない関係</h1>
<p>「<a href="http://www.aoky.net/articles/james_iry/brief-incomplete-and-mostly-wrong.htm">モナドは単なる自己関手の圏におけるモノイド対象だよ。何か問題でも？</a>」というフレーズ（原文「<a href="http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html"><span class="ascii">A monad is a monoid in the category of endofunctors, what</span>’<span class="ascii">s the problem?</span></a>」が示すとおり、モナドとモノイド、<span class="ascii">Haskell</span>の識別子で言うところの<code>Monad</code>と<code>Monoid</code>には密接な関係があります。ぶっちゃけ、このフレーズの正確な意味を私は理解していないのですが、少なくとも<code>Monad</code>と<code>Monoid</code>には重要な共通点があることは知っています。それは、どちらも<strong>単位元と結合則</strong>がある、ということです！</p>
<p>具体的に<code>Monad</code>と<code>Monoid</code>の単位元・結合則を見てみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: Ignore -->
<p><code>Monoid</code>の単位元<span class="ascii">:</span> 単位元である<code>mempty</code>は、どんな値<code>x</code>に<code>&lt;&gt;</code>で足しても結果が変わらない！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">&lt;&gt;</span> <span class="fu">mempty</span> <span class="ot">=</span> x</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mempty</span> <span class="op">&lt;&gt;</span> x <span class="ot">=</span> x</span></code></pre></div>
<p><code>Monad</code>の単位元<span class="ascii">:</span> <code>return</code>は<code>&gt;&gt;=</code>の前に使っても後ろに使っても、<code>m</code>や<code>k a</code>の結果を変えない！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> a <span class="op">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> k a) <span class="ot">=</span> k a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> <span class="fu">return</span> a) <span class="ot">=</span> m</span></code></pre></div>
<p><code>Monoid</code>の結合則<span class="ascii">:</span> <code>x &lt;&gt; y &lt;&gt; z</code>の結果は、<code>y &lt;&gt; z</code>を先に計算しようと<code>x &lt;&gt; y</code>を先に計算しようと変わらない！</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">&lt;&gt;</span> (y <span class="op">&lt;&gt;</span> z) <span class="ot">=</span> (x <span class="op">&lt;&gt;</span> y) <span class="op">&lt;&gt;</span> z</span></code></pre></div>
<p><code>Monad</code>の結合則<span class="ascii">:</span> <code>m &gt;&gt;= \x -&gt; k x &gt;&gt;= h</code> の結果は、<code>\x -&gt; k x &gt;&gt;= h</code>を先に計算しようと、<code>m &gt;&gt;= (\x -&gt; k x)</code>を先に計算しようと変わらない！</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h) <span class="ot">=</span> (m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x)) <span class="op">&gt;&gt;=</span> h</span></code></pre></div>
<p>※<code>Monad</code>の単位元・結合則の式についてはわかりやすさのために<a href="http://hackage.haskell.org/package/base-4.14.0.0/docs/Control-Monad.html#t:Monad">引用元</a>から少し形を変えています。</p>
<p><span class="ascii">Haskell</span>における<code>Monad</code>・<code>Monoid</code>とは、値がそれぞれの単位元・結合則をを満たす型です<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。それ以上でも、それ以下でもありません。</p>
<p>それぞれの単位元・結合則を表す式は、一見して異なるものに見えるかも知れませんが、表す性質自体はよく似ています。なので、式を読んでもよく分からないという方は、上記に書いた日本語の説明をざっと眺めて覚えておいてください。特に、結合則における<strong>「～を先に計算しようと、～を先に計算しようと変わらない！」</strong>の部分がこの後とても重要になります。</p>
<div id="monoid-examples">

</div>
<h2 id="monoidの例"><span class="link-to-here-outer"><a href="#monoidの例" title="monoidの例"><span class="link-to-here">Link to<br />
here</span></a></span><code>Monoid</code>の例</h2>
<p>ここまで読んで、<code>Monad</code>はなんか聞いたことがあるけど<code>Monoid</code>は初めて聞くよ、という方向けに補足すると、<code>Monoid</code>とは例えば次のような型の値（と、それに対する処理）です。</p>
<p><code>Sum</code>型<span class="ascii">:</span> 数値<small>（<span class="ascii">Num</span>型クラスのインスタンス）</small>に対する、足し算を表す<code>Monoid</code>のインスタンス</p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- これから紹介する処理に必要なモジュールのimport</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span></span></code></pre></div>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Sum aに対する &lt;&gt; は + と同等なので、</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getSum (<span class="dt">Sum</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> <span class="dv">2</span> <span class="op">&lt;&gt;</span> <span class="fu">mempty</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- は、</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">0</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- と同じ。</span></span></code></pre></div>
<p><code>mempty</code>が各<code>Monoid</code>のインスタンスにおける単位元を返す、という点に注意してください。上記のとおり足し算の場合は<code>0</code>です。</p>
<p><code>Product</code>型<span class="ascii">:</span> 数値<small>（<span class="ascii">Num</span>型クラスのインスタンス）</small>に対する、かけ算を表す<code>Monoid</code>のインスタンス</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Product aに対する &lt;&gt; は * と同等なので、</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getProduct (<span class="dt">Product</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> <span class="dt">Product</span> <span class="dv">2</span> <span class="op">&lt;&gt;</span> <span class="fu">mempty</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- は、</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">1</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- と同じ。</span></span></code></pre></div>
<p>リスト型<span class="ascii">:</span> リスト型の値に対する、結合 <code>(++)</code>を表す<code>Monoid</code>のインスタンス</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- [a] に対する &lt;&gt; は ++ と同等なので、</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>] <span class="op">&lt;&gt;</span> [<span class="dv">3</span>] <span class="op">&lt;&gt;</span> <span class="fu">mempty</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- は、</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>, <span class="dv">2</span>] <span class="op">++</span> [<span class="dv">3</span>] <span class="op">++</span> []</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- と同じ</span></span></code></pre></div>
<p><code>All</code>型<span class="ascii">:</span> <code>Bool</code>型の値に対する論理積<code>&amp;&amp;</code>を表す<code>Monoid</code>のインスタンス</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getAll (<span class="dt">All</span> <span class="dt">True</span> <span class="op">&lt;&gt;</span> <span class="dt">All</span> <span class="dt">False</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- は、</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span> <span class="op">&amp;&amp;</span> <span class="dt">False</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- と同じ</span></span></code></pre></div>
<!-- ReadmeTest: ValidateAsExpression -->
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- これが何を返すかは、想像してみてください！</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>getAll <span class="fu">mempty</span></span></code></pre></div>
<p><code>Any</code>型<span class="ascii">:</span> <code>Bool</code>型の値に対する論理和<code>||</code>を表す<code>Monoid</code>のインスタンス</p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getAny (<span class="dt">Any</span> <span class="dt">True</span> <span class="op">&lt;&gt;</span> <span class="dt">Any</span> <span class="dt">False</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- は、</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span> <span class="op">||</span> <span class="dt">False</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- と同じ</span></span></code></pre></div>
<!-- ReadmeTest: ValidateAsExpression -->
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- これも何を返すかは、想像してみてください！</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>getAny <span class="fu">mempty</span></span></code></pre></div>
<p>このように、<code>Monoid</code>は他のプログラミング言語でもおなじみの、多くの二項演算を表しています。これらのインスタンスはすべて、先ほど紹介した「単位元」や「結合則」のルールを守っているので、気になった方はぜひチェックしてみてください<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p>
<h1 id="monoidとwriterの切っても切り離せない関係"><span class="link-to-here-outer"><a href="#monoidとwriterの切っても切り離せない関係" title="monoidとwriterの切っても切り離せない関係"><span class="link-to-here">Link to<br />
here</span></a></span><code>Monoid</code>と<code>Writer</code>の切っても切り離せない関係</h1>
<p>実はそんな<code>Monad</code>と<code>Monoid</code>の固い絆を象徴するような<code>Monad</code>が、この世にはあります。そう、<code>Writer</code>です！<code>Writer</code>は<code>Monoid</code>の単位元・結合則をそのまま活かすことによって<code>Monad</code>の単位元・結合則を満たした<code>Monad</code>であり、<code>Writer</code>がどうやって<code>Monad</code>則を満たしているのか知れば、<code>Monad</code>則がどうやって成立するものなのかが、すっきりクリアになることでしょう。</p>
<p>手始めに<code>Writer</code>の定義と、<code>Writer</code>が<code>Monad</code>の各メソッドをどのように実装しているか見てみましょう。<a href="https://www.sampou.org/haskell/a-a-monads/html/writermonad.html">「モナドのすべて」における<code>Writer</code>の紹介ページ</a>から、少しリファクタリングしつつ引用します<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>。</p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Writer型の定義</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> {<span class="ot"> runWriter ::</span> (a, w) }</span></code></pre></div>
<p>タプルに対して<code>newtype</code>していることから分かるとおり、<code>Writer</code>の実態はただのタプルです。ただのタプルがどうやって<code>Monad</code>になるのでしょう？その答えがこちら👇<span class="ascii">:</span></p>
<!--
```haskell
instance Functor (Writer w) where
  fmap f (Writer (x, w)) = Writer (f x, w)

instance Monoid w => Applicative (Writer w) where
  pure a = Writer (a, mempty)
  Writer (f, w1) <*> Writer (x, w2) = Writer (f x, w1 <> w2)
```
-->
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- WriterのMonad型クラスの実装</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 実際のところFunctor, Applicativeのインスタンス定義も必要だけどここでは省略</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Writer</span> (a, <span class="fu">mempty</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Writer</span> (a, w1) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> f a</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span></code></pre></div>
<p><code>return</code>の定義は比較的シンプルですね。<code>mempty</code>を受け取った値<code>a</code>と一緒にタプルに入れて返すだけです。<code>Monad</code>の単位元である<code>return</code>では、<code>Monoid</code>の単位元である<code>mempty</code>を使うのです。</p>
<p>一方、<code>&gt;&gt;=</code>はどう読めばいいでしょう？<code>let ... in ...</code>の結果にあたる<code>Writer (b, w1 &lt;&gt; w2)</code>に注目してください。</p>
<p>まず、<code>b</code>は<code>&gt;&gt;=</code>の右辺である<code>f</code>が返した結果です。<code>Writer</code>の<code>&gt;&gt;=</code>が返す、<code>Writer</code>がラップしたタプルの一つ目の要素は、ここで<code>f</code>が返した値の型と一致していなければなりません。<code>Writer</code>において<code>&gt;&gt;=</code>の型は<code>Writer w a -&gt; (a -&gt; Writer w b) -&gt; Writer w b</code>であり、右辺にあたる<code>f</code>は<code>(a -&gt; Writer w b)</code>という型なので、<code>&gt;&gt;=</code>全体の戻り値<code>Writer w b</code>と<code>f</code>の戻り値が一致している必要があることがわかりますよね？</p>
<p>さらに重要なのが<code>w1 &lt;&gt; w2</code>です。ここであの<code>Monoid</code>の演算子<code>&lt;&gt;</code>が出てきました！<code>Writer</code>は<code>&gt;&gt;=</code>の中で<code>&lt;&gt;</code>を使う<code>Monad</code>なんですね！一体何と何を<code>&lt;&gt;</code>しているのでしょう？まず、<code>&lt;&gt;</code>の左辺である<code>w1</code>は、左辺にあたる<code>Writer</code>がタプルに保持していた<code>Monoid</code>型クラスのインスタンスの値です。そして右辺の<code>w2</code>は、<code>&gt;&gt;=</code>の右辺に渡した関数<code>f</code>が<code>b</code>と一緒に返した<code>w2</code>です。</p>
<p>以上のことをまとめると、<code>Writer</code>の<code>&gt;&gt;=</code>は、</p>
<ol type="1">
<li>左辺の<code>(a, w1)</code>における<code>a</code>を<code>f</code>に渡して、</li>
<li><code>f</code>が返した<code>(b, w2)</code>における<code>b</code>を、</li>
<li><code>w1</code>と<code>w2</code>と一緒に<code>&lt;&gt;</code>でくっつけつつ返す、</li>
</ol>
<p>という処理を行っています。<code>Writer</code>は、「<code>b</code>を返すついでに<code>w1</code>と<code>w2</code>を<code>&lt;&gt;</code>でくっつける」と覚えてください。</p>
<p><code>Writer</code>は、</p>
<ul>
<li><code>Monad</code>の単位元<code>return</code>で<code>Monoid</code>の単位元<code>mempty</code>を使って、</li>
<li><code>Monad</code>の結合則を満たす<code>&gt;&gt;=</code>で、これまた<code>Monoid</code>の結合則を満たす<code>&lt;&gt;</code>を使っているのです。</li>
</ul>
<p>やっぱり<code>Writer</code>は<code>Monoid</code>あっての<code>Monad</code>と言えますね。</p>
<h2 id="doと"><span class="link-to-here-outer"><a href="#doと" title="doと"><span class="link-to-here">Link to<br />
here</span></a></span><code>do</code>と<code>&lt;&gt;</code></h2>
<p>さて、この「<code>b</code>を返すついでに<code>w1</code>と<code>w2</code>を<code>&lt;&gt;</code>でくっつける」という<code>Writer</code>の振る舞いが象徴するように、大抵の<code>Monad</code>のインスタンスにおける<code>&gt;&gt;=</code>は、<strong>何かしら値を返すついでに、何らかの処理を行う</strong>よう実装されています。この「ついでに行われる処理」は<code>Monad</code>のインスタンスを<code>do</code>記法の中で扱うと、ますます静かに身を隠すようになります。</p>
<p>こちらも<code>Writer</code>を例に説明しましょう。まず、例示用に<code>Writer</code>を作るアクションを適当に定義します。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addLogging ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>] <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>addLogging x y <span class="ot">=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Writer</span> (x <span class="op">+</span> y, [<span class="st">&quot;Adding &quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; to &quot;</span> <span class="op">++</span> <span class="fu">show</span> y <span class="op">++</span> <span class="st">&quot;.&quot;</span>])</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ot">multLogging ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>] <span class="dt">Int</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>multLogging x y <span class="ot">=</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Writer</span> (x <span class="op">*</span> y, [<span class="st">&quot;Multiplying &quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; with &quot;</span> <span class="op">++</span> <span class="fu">show</span> y <span class="op">++</span> <span class="st">&quot;.&quot;</span>])</span></code></pre></div>
<p><code>addLogging</code>と<code>multLogging</code>はそれぞれ、引数として受け取った整数を足し算したりかけ算したりしつつ、「足したよ」「かけたよ」という内容の文字列を一緒に返します。<code>Writer [String] Int</code>における<code>[String]</code>にログとして書き込んでいるようなイメージで捉えてください。</p>
<p>これらを<code>do</code>の中で使ってみると、より<code>addLogging</code>や<code>multLogging</code>が「足し算やかけ算をするついでに、ログとして書き込んでいる」っぽいイメージが伝わるでしょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testDo ::</span> <span class="dt">Writer</span> [<span class="dt">String</span>] <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>testDo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  result1 <span class="ot">&lt;-</span> addLogging <span class="dv">3</span> <span class="dv">4</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  result2 <span class="ot">&lt;-</span> multLogging <span class="dv">5</span> <span class="dv">2</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  addLogging result1 result2</span></code></pre></div>
<p><small>⚠️申し訳なくも<code>do</code>記法自体の解説、つまり<code>&gt;&gt;=</code>がどのように<code>do</code>記法に対応するかはここには書きません。お近くの<span class="ascii">Haskell</span>入門書をご覧ください。</small></p>
<p>👆では、<code>3 + 4</code>した結果<code>result1</code>と、<code>5 * 2</code>した結果<code>result2</code>を足す処理を行っています。それに加えて、「足したよ」「かけたよ」というログを表す文字列のリスト<code>[String]</code>も一緒に返しています。<code>do</code>記法が<code>&gt;&gt;=</code>に変換されるのに従い、<code>Writer</code>の<code>&gt;&gt;=</code>が内部で<code>&lt;&gt;</code>を使い、<code>addLogging 3 4</code>・<code>multLogging 5 2</code>・<code>addLogging result1 result2</code>が返した文字列のリスト<code>[String]</code>を結合することによって、あたかも<code>addLogging</code>や<code>multLogging</code>が「値を返しつつ、ログとして書き込む」かのような処理を実現できるのが<code>Writer</code>における<code>do</code>記法の特徴です。</p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<p>能書きはここまでにして、実際にどのような結果になるか見てみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runWriter testDo</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">17</span>,[<span class="st">&quot;Adding 3 to 4.&quot;</span>,<span class="st">&quot;Multiplying 5 with 2.&quot;</span>,<span class="st">&quot;Adding 7 to 10.&quot;</span>])</span></code></pre></div>
<p>はい、<code>3 + 4</code>と<code>5 * 2</code>の結果を足し算した結果<code>17</code>と、<code>addLogging 3 4</code>・<code>multLogging 5 2</code>・<code>addLogging result1 result2</code>が一緒に返していた文字列のリスト<code>[String]</code>が、書いた順番どおりに結合されて返ってきました。<code>Writer</code>は<code>do</code>記法の中に書いた<code>Writer</code>の値<code>(a, w)</code>のうち、<code>Monoid</code>のインスタンスである<code>w</code>を<code>&lt;&gt;</code>で都度結合させているということが伝わったでしょうか？</p>
<h2 id="writer-monadの結合則とmonoidの結合則"><span class="link-to-here-outer"><a href="#writer-monadの結合則とmonoidの結合則" title="writer-monadの結合則とmonoidの結合則"><span class="link-to-here">Link to<br />
here</span></a></span><code>Writer</code> <code>Monad</code>の結合則と<code>Monoid</code>の結合則</h2>
<p>ここまでで、<code>Writer</code> <code>Monad</code>がどのように<code>&lt;&gt;</code>を使っているのか、それによって<code>&gt;&gt;=</code>や<code>do</code>記法がどのように振る舞っているのか、具体例を示して説明いたしました。ここからは、<code>Writer</code>が<code>Monoid</code>の<code>&lt;&gt;</code>の結合則をどう利用することで、<code>Monad</code>としての<code>&gt;&gt;=</code>の結合則を満たしているのかを示しましょう。長いので「めんどい！」という方は<a href="#associative-law-qed">こちらをクリックしてスキップ</a>してください。</p>
<p>そのために、<code>Monad</code>の結合則における<code>&gt;&gt;=</code>を、<code>Writer</code>の<code>&gt;&gt;=</code>として展開してみます。</p>
<!-- ReadmeTest: Ignore -->
<p><span class="ascii">(0)</span> <code>Monad</code>の結合則<span class="ascii">:</span></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h) <span class="ot">=</span> (m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x)) <span class="op">&gt;&gt;=</span> h</span></code></pre></div>
<p><span class="ascii">(1)</span> <code>m</code>は<code>&gt;&gt;=</code>の左辺なので<code>Writer (a, w1)</code>に置き換える<span class="ascii">:</span></p>
<p><small>※ここからは、比較しやすくするために等式<code>=</code>の左辺と右辺を別々の行に書きます。</small></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m <span class="kw">in</span> <span class="dt">Writer</span> (a, w1) <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m <span class="kw">in</span> <span class="dt">Writer</span> (a, w1) <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x) <span class="op">&gt;&gt;=</span> h</span></code></pre></div>
<p><span class="ascii">(2)</span> 一つ目の<code>&gt;&gt;=</code>を<code>Writer</code>における<code>&gt;&gt;=</code>の定義で置き換える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h) a</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m <span class="kw">in</span> <span class="dt">Writer</span> (a, w1) <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> k x) <span class="op">&gt;&gt;=</span> h</span></code></pre></div>
<p><span class="ascii">(3)</span> 等式<code>=</code>の右辺における一つ目の<code>&gt;&gt;=</code>も同様に変換する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> (\x <span class="ot">-&gt;</span> k x <span class="op">&gt;&gt;=</span> h) a</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> (\x <span class="ot">-&gt;</span> k x) a</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2) <span class="op">&gt;&gt;=</span> h</span></code></pre></div>
<p><span class="ascii">(4)</span> 無名関数である<code>(\x -&gt; k x &gt;&gt;= h)</code>と<code>(\x -&gt; k x)</code>に、<code>a</code>を適用する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> k a <span class="op">&gt;&gt;=</span> h</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> k a</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2) <span class="op">&gt;&gt;=</span> h</span></code></pre></div>
<p><span class="ascii">(5)</span> 等式<code>=</code>の左辺における二つ目の<code>&gt;&gt;=</code>を<code>Writer</code>における<code>&gt;&gt;=</code>の定義で置き換える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> <span class="dt">Writer</span> (c, w3) <span class="ot">=</span> k a</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Writer</span> (d, w4) <span class="ot">=</span> h c</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="dt">Writer</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> k a</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)) <span class="op">&gt;&gt;=</span> h</span></code></pre></div>
<p><span class="ascii">(6)</span> 等式<code>=</code>の右辺における二つ目の<code>&gt;&gt;=</code>も同様に変換する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> <span class="dt">Writer</span> (c, w3) <span class="ot">=</span> k a</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Writer</span> (d, w4) <span class="ot">=</span> h c</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="dt">Writer</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">Writer</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Writer</span> (b, w2) <span class="ot">=</span> k a</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="kw">let</span> <span class="dt">Writer</span> (c, w3) <span class="ot">=</span> <span class="dt">Writer</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Writer</span> (d, w4) <span class="ot">=</span> h c</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="dt">Writer</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</span></code></pre></div>
<p><span class="ascii">(7)</span> <code>Writer</code>は、<code>Writer</code>と<code>(a, w)</code>を切り替えるだけで実質何もしていないので削除する<span class="ascii">:</span></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    (b, w2) <span class="ot">=</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> (c, w3) <span class="ot">=</span> k a</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>          (d, w4) <span class="ot">=</span> h c</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    (b, w2) <span class="ot">=</span> k a</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="kw">let</span> (c, w3) <span class="ot">=</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        (d, w4) <span class="ot">=</span> h c</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</span></code></pre></div>
<p><span class="ascii">(7.5) (7)</span>の等式をよく見ると、<code>=</code>の左辺においては<code>(b, w2)</code>と<code>(d, w3 &lt;&gt; w4)</code>が、<code>=</code>の右辺においては<code>(c, w3)</code>と<code>(b, w1 &lt;&gt; w2)</code>が等しい。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    (b, w2) <span class="ot">=</span> <span class="co">--           ここの(b, w2)は、</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> (c, w3) <span class="ot">=</span> k a</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>          (d, w4) <span class="ot">=</span> h c</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> (d, w3 <span class="op">&lt;&gt;</span> w4) <span class="co">-- ここの(d, w3 &lt;&gt; w4)を代入したもの！</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> (b, w1 <span class="op">&lt;&gt;</span> w2)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    (b, w2) <span class="ot">=</span> k a</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> <span class="kw">let</span> (c, w3) <span class="ot">=</span> (b, w1 <span class="op">&lt;&gt;</span> w2) <span class="co">-- ここで代入している！</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        (d, w4) <span class="ot">=</span> h c</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (d, w3 <span class="op">&lt;&gt;</span> w4)</span></code></pre></div>
<p><span class="ascii">(8) (7.5)</span>から、<code>=</code>の左辺では<code>b = d</code>で<code>w2 = w3 &lt;&gt; w4</code>、<code>=</code>の右辺では<code>c = d</code>で<code>w3 = w1 &lt;&gt; w2</code>であることがわかる。なのでそれぞれ置き換える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    (c, w3) <span class="ot">=</span> k a</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    (d, w4) <span class="ot">=</span> h c</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> (d, w1 <span class="op">&lt;&gt;</span> (w3 <span class="op">&lt;&gt;</span> w4))</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    (b, w2) <span class="ot">=</span> k a</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    (d, w4) <span class="ot">=</span> h b</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> (d, (w1 <span class="op">&lt;&gt;</span> w2) <span class="op">&lt;&gt;</span> w4)</span></code></pre></div>
<div id="associative-law-qed">

</div>
<p><span class="ascii">(9)</span> <code>a</code>～<code>d</code>・<code>w1</code>～<code>w4</code>の変数名を、登場した順番に振り直す<span class="ascii">:</span></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    (b, w2) <span class="ot">=</span> k a</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    (c, w3) <span class="ot">=</span> h b</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> (c, w1 <span class="op">&lt;&gt;</span> (w2 <span class="op">&lt;&gt;</span> w3))</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, w1) <span class="ot">=</span> m</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    (b, w2) <span class="ot">=</span> k a</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    (c, w3) <span class="ot">=</span> h b</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">in</span> (c, (w1 <span class="op">&lt;&gt;</span> w2) <span class="op">&lt;&gt;</span> w3)</span></code></pre></div>
<p>等式<code>=</code>の左辺と右辺がそっくりな式になりましたね！</p>
<p>ここで、<code>Monoid</code>の結合則を思い出してみましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">&lt;&gt;</span> (y <span class="op">&lt;&gt;</span> z) <span class="ot">=</span> (x <span class="op">&lt;&gt;</span> y) <span class="op">&lt;&gt;</span> z</span></code></pre></div>
<p>そう、<code>x &lt;&gt; y &lt;&gt; z</code>などと書いて<span class="ascii">3</span>つの<code>Monoid</code>型クラスのインスタンスの値を<code>&lt;&gt;</code>でくっつけるときは、カッコで囲って<code>(y &lt;&gt; z)</code>を先に計算しようと、<code>(x &lt;&gt; y)</code>を先に計算しようと、結果が変わらない、というものでした！</p>
<p>それを踏まえて、<span class="ascii">(9)</span>の等式<code>=</code>の両辺をよく見比べてみてください。異なっているのは<code>w1 &lt;&gt; (w2 &lt;&gt; w3)</code>と<code>(w1 &lt;&gt; w2) &lt;&gt; w3)</code>の箇所だけですね！つまり、<code>Writer</code> <code>Monad</code>における<code>&gt;&gt;=</code>の結合則は、<code>w1 &lt;&gt; (w2 &lt;&gt; w3)</code>と<code>(w1 &lt;&gt; w2) &lt;&gt; w3)</code>が等しいから、すなわち<code>Monoid</code>における<code>&lt;&gt;</code>の結合則が成り立つからこそ成立するのです。これがまさしく「<code>Monoid</code>と<code>Writer</code>の切っても切り離せない関係」なのです！</p>
<h1 id="関係を壊してみる"><span class="link-to-here-outer"><a href="#関係を壊してみる" title="関係を壊してみる"><span class="link-to-here">Link to<br />
here</span></a></span>関係を壊してみる</h1>
<p>それではいよいよ、「<code>Monoid</code>と<code>Writer</code>の切っても切り離せない関係」を利用して、<code>Monad</code>則を破ってみましょう💣</p>
<h2 id="とmonoidの結合則"><span class="link-to-here-outer"><a href="#とmonoidの結合則" title="とmonoidの結合則"><span class="link-to-here">Link to<br />
here</span></a></span><code>&lt;&gt;</code>と<code>Monoid</code>の結合則</h2>
<p>前述のとおり、<code>Writer</code>における<code>&gt;&gt;=</code>が結合則を満たすのは、<code>Writer</code>がラップしている<code>Monoid</code>な値の<code>&lt;&gt;</code>が結合則を満たしてこそ、なのでした。これは言い換えれば、その、ラップしている<code>Monoid</code>な値の<code>&lt;&gt;</code>が結合則を破れば、自然に<code>Writer</code>の<code>&gt;&gt;=</code>も結合則を破るはずです。この方法は、結合則を満たさない<code>&gt;&gt;=</code>っぽい処理をゼロから探すより遥かに簡単です。<code>&gt;&gt;=</code>のような<code>m a -&gt; (a -&gt; m b) -&gt; m b</code>というややこしい型の関数よりも、<code>&lt;&gt;</code>のような<code>a -&gt; a -&gt; a</code>という型の関数の方がずっと身近ですしね！</p>
<p><code>Monoid</code>の<code>&lt;&gt;</code>のような<code>a -&gt; a -&gt; a</code>という型の関数で、結合則を満たさない処理 — といえば、引き算<code>-</code>や割り算<code>/</code>を思い浮かべる方が多いのではないでしょうか。と、いうわけで<a href="#monoid-examples"><code>Monoid</code>の例</a>で紹介した<code>Sum</code>や<code>Product</code>のように、数値に対する引き算を表す<code>newtype</code>、<code>Difference</code>を定義してみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Difference</span> a <span class="ot">=</span> <span class="dt">Difference</span> {<span class="ot"> getDifference ::</span> a }</span></code></pre></div>
<p>それから、<code>Difference</code>を<small>（実際には間違いですが）</small><code>Monoid</code>のインスタンスにします。最近の<span class="ascii">GHC</span>では、<code>Monoid</code>のインスタンスを定義する前に<code>Semigroup</code>のインスタンスにする必要があるのでご注意ください。説明しやすさのために敢えてこれまで触れてきませんでしたが、これまで何度も使った<code>&lt;&gt;</code>は実際のところ<code>Monoid</code>の関数ではなく<code>Semigroup</code>の関数なんですね。<code>Monoid</code>は「<code>&lt;&gt;</code>で（結合則を備えた）二項演算ができるだけでなく、<code>mempty</code>という単位元もある」という性質の型クラスなので、「単に『<code>&lt;&gt;</code>で（結合則を備えた）二項演算ができる』だけの型クラスも欲しい！」というニーズから、<code>Monoid</code>の<code>&lt;&gt;</code>は<code>Semigroup</code>の関数となり、<code>Monoid</code>は<code>Semigroup</code>のサブクラスという関係に変わったのでした。</p>
<p>何はともあれ、<code>Difference</code>を<code>Semigroup</code>のインスタンスにしましょう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Difference</span> a) <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Difference</span> a <span class="op">&lt;&gt;</span> <span class="dt">Difference</span> b <span class="ot">=</span> <span class="dt">Difference</span> (a <span class="op">-</span> b)</span></code></pre></div>
<p>はい、単に両辺を<code>-</code>で引き算するだけですね。</p>
<p>今度こそ<code>Difference</code>を<code>Monoid</code>のインスタンスにします。本記事では<code>mempty</code>を直接使うことはないので何でもいいはずですが、とりあえず<code>Sum</code>と同様に<code>0</code>ということにしておきます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Difference</span> a) <span class="kw">where</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Difference</span> <span class="dv">0</span></span></code></pre></div>
<p>😈これで<code>&lt;&gt;</code>が結合則を満たさないおかしな<code>Monoid</code>のインスタンス、<code>Difference</code>ができました！早速試して結合則を破っていることを確認してみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらは 1 - (2 - 3) と同じ</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getDifference <span class="op">$</span> <span class="dt">Difference</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> (<span class="dt">Difference</span> <span class="dv">2</span> <span class="op">&lt;&gt;</span> <span class="dt">Difference</span> <span class="dv">3</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらは (1 - 2) - 3 と同じなので...</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getDifference <span class="op">$</span> (<span class="dt">Difference</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> <span class="dt">Difference</span> <span class="dv">2</span>) <span class="op">&lt;&gt;</span> <span class="dt">Difference</span> <span class="dv">3</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">4</span> <span class="co">-- &lt;- 当然 1 - (2 - 3) とは異なる結果に！</span></span></code></pre></div>
<p>バッチリ破れてますね！このように<code>&lt;&gt;</code>における結合則は、引き算などおなじみの演算で、簡単に破ることができます💪</p>
<h2 id="とmonadの結合則"><span class="link-to-here-outer"><a href="#とmonadの結合則" title="とmonadの結合則"><span class="link-to-here">Link to<br />
here</span></a></span><code>&gt;&gt;=</code>と<code>Monad</code>の結合則</h2>
<p><code>&lt;&gt;</code>における結合則を破ることができたと言うことは、<code>Writer</code>の<code>&gt;&gt;=</code>による結合則も、もはや破れたも同然です。先ほど定義した<code>Difference</code>型を使えば、<code>&gt;&gt;=</code>は途端に結合則を満たさなくなるでしょう。</p>
<p>例を示す前に、<code>Writer</code>を使う際しばしば用いられる、ユーティリティー関数を定義しておきます。実践で<code>Writer</code>を使いたくなったときにも大変便利なので、是非覚えておいてください<span class="ascii">:</span></p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tell ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>tell w <span class="ot">=</span> <span class="dt">Writer</span> ((), w)</span></code></pre></div>
<p>この<code>tell</code>関数は、受け取った<code>Monoid</code>な値をそのまま「ログとして書き込む」関数です。結果として返す値はただのユニット<code>()</code>なので、気にする必要がありません。<code>tell</code>のみを使って<code>Writer</code>を組み立てれば、「ログとして書き込む」値のみに集中することができます。これから紹介する例でもやはり関心があるのは「ログとして書き込む」値だけなので、ここで<code>tell</code>を定義しました。</p>
<p>それでは<code>tell</code>を使って、<code>Writer</code>の<code>&gt;&gt;=</code>における結合則も破ってみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらは Difference 1 &lt;&gt; (Difference 2 &lt;&gt; Difference 3) と同じ</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getDifference <span class="op">.</span> <span class="fu">snd</span> <span class="op">.</span> runWriter <span class="op">$</span> tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>)))</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらは (Difference 1 &lt;&gt; Difference 2) &lt;&gt; Difference 3 と同じなので...</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getDifference <span class="op">.</span> <span class="fu">snd</span> <span class="op">.</span> runWriter <span class="op">$</span> (tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>))) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>))</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">4</span> <span class="co">-- &lt;- 当然 1 - (2 - 3) とは異なる結果に！</span></span></code></pre></div>
<p>予想どおり一つ目の<code>Writer</code>と二つ目の<code>Writer</code>とで異なる結果となりました。<code>1 - (2 - 3)</code>と<code>(1 - 2) - 3</code>を<code>Writer</code>を使って遠回しに言い換えているだけなので、当然と言えば当然です。</p>
<p>しかし<code>tell (Difference 1) &gt;&gt;= (\_ -&gt; tell (Difference 2) &gt;&gt;= \_ -&gt; tell (Difference 3))</code>などの<code>Writer</code>型の式が<code>Monad</code>の結合則<code>m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) = (m &gt;&gt;= (\x -&gt; k x)) &gt;&gt;= h</code>にどう対応するのか、ちょっと分かりづらいですかね？<small>（式も長いし）</small>一つずつ注釈を加えます<span class="ascii">:</span></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらは m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) = (m &gt;&gt;= (\x -&gt; k x)) &gt;&gt;= h の前半、</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) に相当する</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span>  tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>)))</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- ^^^^^^^^^^^^^^^^^^^       ^    ^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">--          m                x             k                             h</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらは m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) = (m &gt;&gt;= (\x -&gt; k x)) &gt;&gt;= h の後半、</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co">--   (m &gt;&gt;= (\x -&gt; k x)) &gt;&gt;= h に相当する</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span>  (tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>))) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>))</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="co">--  ^^^^^^^^^^^^^^^^^^^       ^    ^^^^^^^^^^^^^^^^^^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="co">--           m                x             k                             h</span></span></code></pre></div>
<p>ラムダ式の引数<code>x</code>は実際には使われていない点に注意してください。これでも<code>const</code>を使って<code>\x -&gt; const (tell (Difference 2)) x</code>と書き換えれば、<code>const (tell (Difference 2))</code>が<code>k</code>に厳密に対応するので、上記の二組の式は<code>&gt;&gt;=</code>の結合則を破るペアだと言えます。</p>
<h2 id="do記法とmonadの結合則"><span class="link-to-here-outer"><a href="#do記法とmonadの結合則" title="do記法とmonadの結合則"><span class="link-to-here">Link to<br />
here</span></a></span><code>do</code>記法と<code>Monad</code>の結合則</h2>
<p>前の節では、<code>Monoid</code>の結合則を守っていない値をラップしている<code>Writer</code>を作ることで、<code>&gt;&gt;=</code>の結合則を破る例を簡単に作り出せることを紹介しました。ここでは本記事の最後として、<code>&gt;&gt;=</code>の結合則を破った結果、<code>do</code>記法がいかに直感に反する挙動となるか紹介して、<code>&gt;&gt;=</code>の結合則を守ることが私たちにどのようなメリットをもたらすのか解説します。</p>
<p>例として、先ほど<code>&gt;&gt;=</code>の結合則を破るのに使った<code>1 - 2 - 3</code>を再利用しましょう。<code>Difference</code>をラップした<code>Writer</code>で<code>1 - 2 - 3</code>を計算させると、次のような式になります<span class="ascii">:</span></p>
<!-- ReadmeTest: ValidateAsExpression -->
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>tell (<span class="dt">Difference</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">2</span>)) <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>))</span></code></pre></div>
<p>これを<code>do</code>記法に変換すると、次のようになります<span class="ascii">:</span></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">1</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">2</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">3</span>)</span></code></pre></div>
<p><code>do</code>記法における各行の間に<code>&gt;&gt;=</code>が隠れたことで、すっきりしましたね！</p>
<p>この状態から、<code>do</code>記法を使って<code>1 - (2 - 3)</code>と<code>(1 - 2) - 3</code>を表す<code>Writer</code>の式にするには、次のように書き換えます<span class="ascii">:</span></p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらが 1 - (2 - 3) を表す</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>do_1minus&#39;2minus3&#39; <span class="ot">=</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    tell (<span class="dt">Difference</span> <span class="dv">1</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>      tell (<span class="dt">Difference</span> <span class="dv">2</span>)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>      tell (<span class="dt">Difference</span> <span class="dv">3</span>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらが (1 - 2) - 3 を表す</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>do_&#39;1minus2&#39;minus3 <span class="ot">=</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>      tell (<span class="dt">Difference</span> <span class="dv">1</span>)</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>      tell (<span class="dt">Difference</span> <span class="dv">2</span>)</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    tell (<span class="dt">Difference</span> <span class="dv">3</span>)</span></code></pre></div>
<p>コメントに書いたとおり、<code>do_1minus'2minus3'</code>が<code>1 - (2 - 3)</code>、<code>do_'1minus2'minus3</code>が<code>(1 - 2) - 3</code>と同等な<code>Writer</code>です。<span class="ascii">Haskell</span>はシングルクォートを変数の名前に含めることができるので、シングルクォートでカッコを表すことにしました<small>（まさかこんなところで役に立つとはね！）</small>。</p>
<p>上記の二つの式では、カッコ<code>()</code>で囲う代わりにもう一つの<code>do</code>記法に収めることで、<code>do</code>記法における各行を実行する順番をいじっています。</p>
<p>本当にこれで<code>1 - (2 - 3)</code>や<code>(1 - 2) - 3</code>と同等な式になっているのでしょうか？試しに<code>runWriter</code>して結果を確かめてみましょう<span class="ascii">:</span></p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらが 1 - (2 - 3) を表す</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getDifference <span class="op">.</span> <span class="fu">snd</span> <span class="op">$</span> runWriter do_1minus&#39;2minus3&#39;</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- こちらが (1 - 2) - 3 を表す</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> getDifference <span class="op">.</span> <span class="fu">snd</span> <span class="op">$</span> runWriter do_&#39;1minus2&#39;minus3</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">4</span></span></code></pre></div>
<p>バッチリ👌想定どおり、<code>do_1minus'2minus3'</code>が<code>1 - (2 - 3) = 2</code>を計算し、<code>do_'1minus2'minus3</code>が<code>(1 - 2) - 3 = -4</code>を計算していますね！</p>
<p>さてこれまでで、<code>Writer</code> <code>Monad</code>は<code>Monoid</code>の結合則を利用することで<code>&gt;&gt;=</code>の結合則を満たしていることを示し、ラップしている<code>Monoid</code>な値が結合則を満たしていなければ、必然的に<code>Writer</code>も結合則を破ってしまうことを、<code>&gt;&gt;=</code>や<code>do</code>記法を使って具体的に示しました。それでは今挙げた、<code>do</code>記法で結合則を破った例は、一体何を示唆しているのでしょうか？普通に<span class="ascii">Haskell</span>でコードを書いていて、前述のような書き換え、すなわち、</p>
<!-- ReadmeTest: ValidateAsExpression -->
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">1</span>)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    tell (<span class="dt">Difference</span> <span class="dv">2</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    tell (<span class="dt">Difference</span> <span class="dv">3</span>)</span></code></pre></div>
<p>から、</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    tell (<span class="dt">Difference</span> <span class="dv">1</span>)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    tell (<span class="dt">Difference</span> <span class="dv">2</span>)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">3</span>)</span></code></pre></div>
<p>への書き換え<small>（あるいはその逆）</small>は、一見するとそんな機会ないように思えます。しかしこれが、<code>do</code>記法をカッコ代わりに使うという変な方法ではなく、次のように変数に代入することで切り出していた場合、いかがでしょうか？</p>
<!-- ReadmeTest: AppendAsIs -->
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>someSingleAction <span class="ot">=</span> tell (<span class="dt">Difference</span> <span class="dv">1</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>someSequence <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">2</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">3</span>)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>someCompositeAction <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  someSingleAction</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>  someSequence</span></code></pre></div>
<p>上記👆のような三つの<code>Writer</code>の値を、下記👇の三つの値にリファクタリングする場合です。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>refactoredSequence <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">1</span>)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">2</span>)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>splitOutSingleAction <span class="ot">=</span> tell (<span class="dt">Difference</span> <span class="dv">3</span>)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>refactoredCompositeAction <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>  refactoredSequence</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>  splitOutSingleAction</span></code></pre></div>
<p>あるいは、たった<span class="ascii">3</span>行しかありませんし、一つの値に統合する方がいいかも知れません<span class="ascii">:</span></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>flattenedAction <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">1</span>)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">2</span>)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  tell (<span class="dt">Difference</span> <span class="dv">3</span>)</span></code></pre></div>
<p>これらの書き換えは、いずれも<code>do</code>記法が内部で使っている<code>&gt;&gt;=</code>の結合則を前提とすれば、可能であってしかるべきです。<code>do</code>記法は、適当に<code>Monad</code>のインスタンスの値（「アクション」などとも呼ばれます）を上から下まで列挙すれば、自動で<code>&gt;&gt;=</code>を使ってつなげてくれる、というものです。なので、適当に並べたアクションがどういう形に結合されるのか気にする必要があるのでは、安心して使えません。一方、上記の<span class="ascii">3</span>組の式は、<code>Writer Difference</code>、すなわち引き算を表す「偽<code>Monoid</code>」をラップしているが故に、<code>&gt;&gt;=</code>の結合則を満たしておりません。結果、<code>do</code>記法に変えたときに並べたアクションをどこで切り出すかで、結果が変わってしまいます。これでは安心して列挙できません！</p>
<!-- ReadmeTest: CompareAfterPrompt ByExpression -->
<!--
```haskell
> getDifference . snd $ runWriter someCompositeAction
2
> getDifference . snd $ runWriter refactoredCompositeAction
-4
> getDifference . snd $ runWriter flattenedAction
2
```
-->
<h1 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h1>
<p>以上です。これまでで、<code>Monad</code>則のうち結合則がなぜ重要なのか、結合則を実際に破ってみることを通じて説明しました。<code>Monad</code>と同様に結合則を持った<code>Monoid</code>は、<code>Monad</code>以上にインスタンスを見つけるのが簡単で、なおかつ、例えば引き算のように「二項演算だけど結合則を満たしていない」処理を見つけるのが簡単です。本記事では<code>Monoid</code>のそうした性質と、<code>Monoid</code>の性質でもって<code>Monad</code>則を満たしている<code>Writer</code> <code>Monad</code>に注目することで、簡単に<code>Monad</code>則を破る例を提示することができました。それから、<code>Monad</code>の結合則を実際に破った例を使って、<code>Monad</code>の結合則が<code>do</code>記法を自然に書けるようにするために必要であることを示しました。これらの実例から主張したいことを一般化すると、次のとおりです<span class="ascii">:</span></p>
<ul>
<li><code>do</code>記法の各行の間で、値を返すついでに何かを行うのが<code>Monad</code>のインスタンス</li>
<li><code>do</code>記法の各行の間で、値を返すついでに行っている処理が結合則を満たす型が、<code>Monad</code>則を満たすと言える</li>
<li><code>Monad</code>則を守らない型を<code>do</code>記法で使うと、<code>do</code>記法の結合を気にして書かなければならなくなる</li>
</ul>
<p>それでは、<span class="ascii">2021</span>年も🎁<span class="ascii">Happy Haskell Hacking with Monad</span>🎁<span class="ascii">!</span></p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>一応、<code>Monad</code>についてはそのスーパークラスである<code>Applicative</code>の則、<code>Functor</code>の則がありますが、<code>Monad</code>則を満たしていればそれらは自動的に満たせるので、ここでは省略します。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>残念ながら実際のところ、<code>Float</code>型・<code>Double</code>型などの浮動小数点数に対する<code>Sum</code>や<code>Product</code>は結合則を満たさない場合があります。これは他の多くのプログラミング言語にもある、浮動小数点数の悩ましい問題です。詳しくは「情報落ち」で検索してみてください。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>ここでの定義は、実際に使われている<a href="http://hackage.haskell.org/package/transformers"><span class="ascii">transformers</span>パッケージ</a>の<code>Writer</code>の定義とは大きく異なっているのでご注意ください。実際の<code>Writer</code>はパフォーマンス上の都合や<span class="ascii">Monad Transformer</span>との兼ね合いで、幾分工夫された定義となっています。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/about_admins.html" lang="ja">日本Haskellユーザーグループ管理委員会（Haskell-jp Admins）設立のお知らせ</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/antenna-with-gh-actions.html" style="margin-left: auto;" lang="ja">Haskell AntennaのCI/CDをGitHub Actionsに移行する</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell AntennaのCI/CDをGitHub Actionsに移行する</title>
    <link href="https://haskell.jp/blog/posts/2020/antenna-with-gh-actions.html" />
    <id>https://haskell.jp/blog/posts/2020/antenna-with-gh-actions.html</id>
    <published>2020-12-12T00:00:00Z</published>
    <updated>2020-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell-jp</span>のコンテンツの一つとして<a href="https://haskell.jp/antenna/"><span class="ascii">Haskell Antenna</span></a>という<span class="ascii">Web</span>ページの開発・運用をしております。</p>
<p><img src="../../img/2020/antenna-with-gh-actions/antenna-page.jpg" style="width: 100%;"></p>
<p>バイナリのビルドや<span class="ascii">Docker</span>イメージのビルドに<span class="ascii">TravisCI</span>を、バイナリを実行してページの更新をするのに<span class="ascii">DroneCI</span>を使っていました。
しかし、長らく放置していてちゃんと動作しているか怪しかったので、メンテナンスをするついでに昨今はやり（要出典）の<a href="https://github.com/haskell-jp/antenna/pull/26"><span class="ascii">GitHub Actions</span>にこれらを移行することにしました</a>。</p>
<p><img src="../../img/2020/antenna-with-gh-actions/pr.jpg" style="width: 100%;"></p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#stackプロジェクトのビルド" title="stackプロジェクトのビルド"><span class="ascii">Stack</span>プロジェクトのビルド</a></li>
<li><a href="#dockerイメージのビルドとプッシュ" title="dockerイメージのビルドとプッシュ"><span class="ascii">Docker</span>イメージのビルドとプッシュ</a></li>
<li><a href="#antennaプログラムの実行" title="antennaプログラムの実行"><span class="ascii">antenna</span>プログラムの実行</a></li>
</ul>
</div>
</div>
<h3 id="stackプロジェクトのビルド"><span class="link-to-here-outer"><a href="#stackプロジェクトのビルド" title="stackプロジェクトのビルド"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Stack</span>プロジェクトのビルド</h3>
<p>まずはバイナリのビルドを行うように設定します。
<span class="ascii">Haskell Antenna</span>のプログラムは<span class="ascii">Haskell Stack</span>を利用しているので、<code>stack build</code>が実行できれば良いです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> Build Application</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">on</span><span class="kw">:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">pull_request</span><span class="kw">:</span><span class="at"> </span><span class="ch">null</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">push</span><span class="kw">:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">branches</span><span class="kw">:</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> master</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">name</span><span class="kw">:</span><span class="at"> ${{ matrix.os }}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-18.04</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">strategy</span><span class="kw">:</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">fail-fast</span><span class="kw">:</span><span class="at"> </span><span class="ch">false</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">matrix</span><span class="kw">:</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">ghc</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;8.8.4&quot;</span><span class="kw">]</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> actions/checkout@v2</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Cache .stack</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">id</span><span class="kw">:</span><span class="at"> cache-stack</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> actions/cache@v2</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">path</span><span class="kw">:</span><span class="at"> ~/.stack</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">key</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;\</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="st">          ${{ runner.os }}-stack\</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="st">          -${{ hashFiles(&#39;**/stack.yaml.lock&#39;) }}\</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="st">          -${{ hashFiles(&#39;**/package.yaml&#39;) }}\</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="fu">        restore-keys</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>          ${{ runner.os }}-stack-</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> haskell/actions/setup@main</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Setup Haskell</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">ghc-version</span><span class="kw">:</span><span class="at"> ${{ matrix.ghc }}</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">enable-stack</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">stack-version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;latest&#39;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Install dependencies</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> stack --system-ghc test --only-dependencies</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build and Test</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> stack --system-ghc test --copy-bins --local-bin-path=./bin</span></span></code></pre></div>
<p>これは、<span class="ascii">PR</span>が作られたときや<span class="ascii">master</span>がプッシュされたときに実行されることを想定しています。</p>
<p><span class="ascii">GitHub Actions</span>で<span class="ascii">Haskell</span>や<span class="ascii">Haskell Stack</span>を使うには、<del>公式が提供している<a href="https://github.com/actions/setup-haskell"><span class="ascii">actions/setup-haskell</span></a></del> <a href="https://github.com/haskell/actions/tree/main/setup"><span class="ascii">haskell/actions/setup</span></a> を利用します。
元々は<span class="ascii">actions/haskell-setup</span>がありましたが、どうやら<a href="https://github.com/actions/setup-haskell/pull/56">メンテナンスする人がいなくなったっぽく</a>アーカイブされてしまいました。
この記事を書いている時点では移行したばかりでちゃんとタグが切られていないため、<span class="ascii">main</span>ブランチを指定しています。
ちなみに、<span class="ascii">Stack</span>プロジェクトの<span class="ascii">GHC</span>バージョンを<span class="ascii">haskell/actions/setup</span>でインストールして、<code>stack --system-ghc</code>をすることでキャッシュサイズを減らすことができます。</p>
<p>これまた余談ですが、<span class="ascii">actions/setup-haskell</span>の方を使っていて次のようなエラーが出る場合は<span class="ascii">actions/setup-haskell</span>のバージョンが古いです（<a href="https://github.com/actions/setup-haskell/issues/44">最新では修正済みです</a>）。<span class="ascii">haskell/actions/setup</span>の方を使いましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Installing</span> ghc version 8.8.4</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">Error:</span> Unable to process command <span class="st">&#39;::add-path::/opt/ghc/8.8.4/bin&#39;</span> successfully.</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">Error:</span> The <span class="kw">`</span><span class="ex">add-path</span><span class="kw">`</span> command is disabled. Please upgrade to using Environment Files or opt into unsecure command execution by setting the <span class="kw">`</span><span class="ex">ACTIONS_ALLOW_UNSECURE_COMMANDS</span><span class="kw">`</span> environment variable to <span class="kw">`</span><span class="fu">true</span><span class="kw">`</span>. For more information see: https://github.blog/changelog/2020-10-01-github-actions-deprecating-set-env-and-add-path-commands/</span></code></pre></div>
<h3 id="dockerイメージのビルドとプッシュ"><span class="link-to-here-outer"><a href="#dockerイメージのビルドとプッシュ" title="dockerイメージのビルドとプッシュ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Docker</span>イメージのビルドとプッシュ</h3>
<p><a href="https://hub.docker.com/r/haskelljp/antenna/"><span class="ascii">antenna</span>プログラムは<span class="ascii">Docker</span>イメージにして<span class="ascii">Docker Hub</span>に置いてあります</a>（これも<span class="ascii">GitHub Container Registry</span>に移行したいですね）。
なので、<span class="ascii">master</span>の更新に合わせて<span class="ascii">Docker</span>イメージをビルドしてプッシュするジョブを設定します。
<span class="ascii">Docker</span>イメージのビルドとプッシュには<a href="https://github.com/docker/build-push-action"><span class="ascii">docker/build-push-action</span></a>を使います。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># さっきと同じ設定ファイルです</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> Build Application</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">on</span><span class="kw">:</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">pull_request</span><span class="kw">:</span><span class="at"> </span><span class="ch">null</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">push</span><span class="kw">:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">branches</span><span class="kw">:</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> master</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">name</span><span class="kw">:</span><span class="at"> ${{ matrix.os }}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-18.04</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">strategy</span><span class="kw">:</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">fail-fast</span><span class="kw">:</span><span class="at"> </span><span class="ch">false</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">matrix</span><span class="kw">:</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">ghc</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;8.8.4&quot;</span><span class="kw">]</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="at">    ...</span><span class="co"> # 割愛</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build and Test</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> stack --system-ghc test --copy-bins --local-bin-path=./bin</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co">    # Build and Push Docker Image</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Setup QEMU</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> docker/setup-qemu-action@master</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">platforms</span><span class="kw">:</span><span class="at"> all</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Setup Docker Buildx</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">id</span><span class="kw">:</span><span class="at"> buildx</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> docker/setup-buildx-action@master</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">version</span><span class="kw">:</span><span class="at"> latest</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Login to DockerHub</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> docker/login-action@v1</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">username</span><span class="kw">:</span><span class="at"> ${{ secrets.DOCKER_USERNAME }}</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">password</span><span class="kw">:</span><span class="at"> ${{ secrets.DOCKERHUB_TOKEN }}</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build and push</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> docker/build-push-action@v2</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">context</span><span class="kw">:</span><span class="at"> .</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">builder</span><span class="kw">:</span><span class="at"> ${{ steps.buildx.outputs.name }}</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">tags</span><span class="kw">:</span><span class="at"> haskelljp/antenna:latest</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">push</span><span class="kw">:</span><span class="at"> ${{ github.event_name != &#39;pull_request&#39; }}</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">build-args</span><span class="kw">:</span><span class="at"> local_bin_path=./bin</span></span></code></pre></div>
<p><span class="ascii">master</span>ブランチへのプッシュのときにだけ<span class="ascii">Docker</span>イメージのプッシュをして欲しいので、<code>push:</code> に <code>github.event_name != 'pull_request'</code> を設定しています。
また、<span class="ascii">Haskell Stack</span>でビルドされたバイナリファイルは<code>--local-bin-path=./bin</code>オプションで<code>./bin</code>に置いてあります。
これを<span class="ascii">Dockerfile</span>でコピーするようにしている（下記参照）ので、<code>docker build</code>の引数に<code>local_bin_path=./bin</code>というのを与える必要がありました。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> matsubara0507/ubuntu-for-haskell:git</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ARG</span> local_bin_path</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="fu">mkdir</span> <span class="at">-p</span> /root/.local/bin <span class="kw">&amp;&amp;</span> <span class="fu">mkdir</span> <span class="at">-p</span> /work</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> PATH /root/.local/bin:$PATH</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /work</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> ${local_bin_path} /root/.local/bin</span></code></pre></div>
<p>このように前の<span class="ascii">step</span>までの結果を利用するには <code>context: .</code> を指定する必要があります（デフォルトでは<a href="https://github.com/docker/build-push-action/tree/v2#git-context"><span class="ascii">git-context</span></a>というのを使うからです）。</p>
<h3 id="antennaプログラムの実行"><span class="link-to-here-outer"><a href="#antennaプログラムの実行" title="antennaプログラムの実行"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">antenna</span>プログラムの実行</h3>
<p>最後に、<span class="ascii">master</span>の更新があったときに<span class="ascii">antenna</span>プログラムを実行して<span class="ascii">Haskell Antenna</span>ページを更新するような設定をします。
日毎のスケジュール実行も設定したいので、新しいワークフローを切りました。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> Update Antenna page</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">on</span><span class="kw">:</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">schedule</span><span class="kw">:</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">cron</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;0 8 * * *&#39;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">push</span><span class="kw">:</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">branches</span><span class="kw">:</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> master</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">paths-ignore</span><span class="kw">:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="st">&#39;README.md&#39;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="st">&#39;CHANGELOG.md&#39;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="st">&#39;LICENSE&#39;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="st">&#39;.gitignore&#39;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">update</span><span class="kw">:</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">name</span><span class="kw">:</span><span class="at"> ${{ matrix.os }}</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-18.04</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">strategy</span><span class="kw">:</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">fail-fast</span><span class="kw">:</span><span class="at"> </span><span class="ch">false</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">matrix</span><span class="kw">:</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">ghc</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;8.8.4&quot;</span><span class="kw">]</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="at">    ...</span><span class="co"> # Install dependenciesまでは一緒なので割愛</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Build</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">run</span><span class="kw">:</span><span class="at"> stack --system-ghc build</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> actions/checkout@v2</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">with</span><span class="kw">:</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">ref</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;gh-pages&#39;</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">path</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;temp&#39;</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Exec Application</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="fu">      run</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        cp sites.yaml temp/sites.yaml</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        cp -r image/* temp/image</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        cd temp &amp;&amp; stack exec -- antenna sites.yaml</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Push changes</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">COMMIT_MESSAGE</span><span class="kw">:</span><span class="at"> Update haskell antenna. See https://haskell.jp/antenna/ for new entries!</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="fu">      run</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        git config --local user.email &quot;bot@example.com&quot;</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        git config --local user.name &quot;Bot&quot;</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        git status</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        git add -A</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        git diff --staged --quiet || git commit -m &quot;$COMMIT_MESSAGE&quot;</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        git push origin gh-pages</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">working-directory</span><span class="kw">:</span><span class="at"> ./temp</span></span></code></pre></div>
<p>バイナリをビルドするところまでは一緒です。
<span class="ascii">Haskell Antenna</span>は同じリポジトリの<span class="ascii">gh-pages</span>ブランチに置いて、<span class="ascii">GitHub Pages</span>を使って公開しています。
なので、同じリポジトリの<span class="ascii">gh-pages</span>ブランチを<span class="ascii">git clone</span>しなおしてサブディレクトリに置き、そこで<span class="ascii">antenna</span>プログラムを実行して、更新があった場合にのみプッシュしています。
同じリポジトリであれば、特に設定することなくプッシュできるのが<span class="ascii">GitHub Actions</span>のメリットですね。</p>
<h2 id="おまけzennを追加しました"><span class="link-to-here-outer"><a href="#おまけzennを追加しました" title="おまけzennを追加しました"><span class="link-to-here">Link to<br />
here</span></a></span>おまけ：<span class="ascii">Zenn</span>を追加しました！</h2>
<p>ついでに最近のアップデートによって、<a href="https://github.com/haskell-jp/antenna/pull/25"><span class="ascii">Zenn</span>を<span class="ascii">Haskell Antenna</span>に載せるサイトへ追加しました</a>（<span class="ascii">igrep</span>氏がしてくれました、ありがとうございます）。
アイコンの利用規約などがわからなかったのですが、<span class="ascii">GitHub</span>の<span class="ascii">PR</span>上で直接聞いてみたところ、問題ないという回答をいただきました。
突然だったのにありがとうございます。</p>
<p><img src="../../img/2020/antenna-with-gh-actions/antenna-page-with-zenn.jpg" style="width: 100%;"></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/break-monad-law-with-writer.html" lang="ja">Writer Monadで気軽にMonad則を破る</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/how-to-use-type-newtype-data.html" style="margin-left: auto;" lang="ja">data / newtype / type の使い方</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>data / newtype / type の使い方</title>
    <link href="https://haskell.jp/blog/posts/2020/how-to-use-type-newtype-data.html" />
    <id>https://haskell.jp/blog/posts/2020/how-to-use-type-newtype-data.html</id>
    <published>2020-06-14T00:00:00Z</published>
    <updated>2020-06-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><span class="ascii">Haskell</span> プログラミングにおいて，データ型は非常に重要な役割を持つ．データ型は，扱うデータをプログラミング上で安全かつ容易に加工するために用いられ，またデータに対してどのような操作ができるのかを規定する．</p>
<p><span class="ascii">Haskell</span> には，データ型を新たに定義する方法が<span class="ascii">3</span>つある．</p>
<ul>
<li><span class="ascii">1</span>つ目は <code>type</code> キーワードによって定義する方法で，これにより定義されたデータ型は型シノニムと呼ばれる．</li>
<li><span class="ascii">2</span>つ目は <code>data</code> キーワードによって定義する方法で，これにより定義されたデータ型は代数的データ型と呼ばれる．</li>
<li><span class="ascii">3</span>つ目は <code>newtype</code> キーワードによってある型を元に新たな型を作る方法だ．</li>
</ul>
<p>今回は，それぞれどういう使い方をするのか，どういう違いがあるのかについて見ていきたいと思う．</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#型シノニム" title="型シノニム">型シノニム</a></li>
<li><a href="#代数的データ型" title="代数的データ型">代数的データ型</a></li>
<li><a href="#ある型を元に新たな型を作る-datatype-renaming" title="ある型を元に新たな型を作る-datatype-renaming">ある型を元に新たな型を作る <span class="ascii">(Datatype Renaming)</span></a></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h2 id="型シノニム"><span class="link-to-here-outer"><a href="#型シノニム" title="型シノニム"><span class="link-to-here">Link to<br />
here</span></a></span>型シノニム</h2>
<p>例えば，あなたは <span class="ascii">Web</span> サイトを運営していて，一部年齢制限が必要なため，人の年齢が <span class="ascii">20</span> 歳以上かを判定する関数を書かなければいけないとする．年齢は整数だが，入力は必須でないため入力してない人もいる．その場合は，<span class="ascii">20</span> 歳以上でないと判定する．この関数は，</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isAdult ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>isAdult m <span class="ot">=</span> <span class="kw">case</span> m <span class="kw">of</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x <span class="op">&gt;=</span> <span class="dv">20</span></span></code></pre></div>
<p>と書ける．ただ，この定義はどこか味気ない．<code>isAdult</code> が受け取るデータは，年齢を表していて，整数か未詳かの状態を持つので，<code>Maybe Int</code> はデータを正確に捉えられている．しかし，<code>Maybe Int</code> に適合するデータは他に無数にあるため，<code>isAdult</code> が受け取るデータが年齢を表すのか知能指数を表すのか，はたまた今までお酒を飲んだことのある回数なのかは推測しないと分からない．年齢を表すデータ型を新たに定義して，それを受け取るようにすればもっとプログラムがクールになるだろう．</p>
<p><span class="ascii">Haskell</span> で新しくデータ型を定義する最も簡単な方法は，<code>type</code> キーワードを使って型シノニム <span class="ascii">(type synonym)</span> を定義する方法だ．シノニムとは，別名という意味で，型シノニムは文字通り，ある型の別名を表す．今回は次のように使える<span class="ascii">:</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">isAdult ::</span> <span class="dt">Age</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>isAdult age <span class="ot">=</span> <span class="kw">case</span> age <span class="kw">of</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x <span class="op">&gt;=</span> <span class="dv">20</span></span></code></pre></div>
<p>これで関数 <code>isAdult</code> は，先ほどと比べてとても明確になった．<code>Age</code> は <code>Maybe Int</code> を元に作られた型シノニムで，つまり <code>Age</code> は <code>Maybe Int</code> の別名になっている．単なる別名なので，<code>isAdult</code> は <code>Maybe Int -&gt; Bool</code> 型の関数だと思って使うこともできる．<span class="ascii">GHCi</span> で試してみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> (<span class="ot">isAdult ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) (<span class="dt">Just</span> <span class="dv">22</span><span class="ot"> ::</span> <span class="dt">Age</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span></code></pre></div>
<p><code>Maybe Int</code> を <code>Age</code> だと思うこともできるしその逆もできる．型シノニムと元となった型は自在に取り替え可能だ．型シノニムはとても手軽なので，<span class="ascii">Haskell</span> の標準ライブラリでも使われている．例えば，次のようなデータ型が型シノニムで定義されている<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">String</span> <span class="ot">=</span> [<span class="dt">Char</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FilePath</span> <span class="ot">=</span> <span class="dt">String</span></span></code></pre></div>
<p>文字列は文字のリストと見做せる．そこから文字列によるデータ型 <code>String</code> は，単に文字のリスト型の型シノニムで定義されている．文字列に対してリストの関数を自由に適用できるのは，このためだ．ファイルのパスによるデータ型 <code>FilePath</code> は <code>String</code> の型シノニムで定義されている．なので，文字列の関数を自由に適用できる．</p>
<p><span class="ascii">Haskell</span> の型シノニムは，これだけに止まらずもっと強力な機能も持っている．例えば，型シノニムは型コンストラクタ，すなわち型を受け取って新たな型を作るコンストラクタに対しても作れる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Option</span> <span class="ot">=</span> <span class="dt">Maybe</span></span></code></pre></div>
<p>この型シノニムを使うと，<code>Maybe Int</code> と書く代わりに <code>Option Int</code> と書くことも可能だ．部分適用された型コンストラクタに対する型シノニムも書ける<span class="ascii">:</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Failable</span> <span class="ot">=</span> <span class="dt">Either</span> <span class="dt">String</span></span></code></pre></div>
<p>この型シノニムを使うと，<code>Either String ()</code> と書く代わりに <code>Failable ()</code> と書くことができる．</p>
<p>さらに型シノニムは，パラメータを持つことができる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">List</span> a <span class="ot">=</span> [a]</span></code></pre></div>
<p>この型シノニムを使うと，<code>[Int]</code> は <code>List Int</code> と書ける．ただし，型シノニムはあくまで別名なので，全てのパラメータを適用した状態でしか書けないことに注意する必要がある．例えば，次のプログラムはコンパイルエラーになる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Apply</span> f a <span class="ot">=</span> f a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ApplyMaybe</span> <span class="ot">=</span> <span class="dt">Apply</span> <span class="dt">Maybe</span></span></code></pre></div>
<p><code>Apply</code> は<span class="ascii">2</span>つのパラメータをとるが，<code>ApplyMaybe</code> は <code>Apply</code> に<span class="ascii">1</span>つのパラメータしか渡していない．この場合，<code>Apply Maybe</code> という型がどういう型の別名になるか <span class="ascii">Haskell</span> は分からないため，この型を拒否する．このプログラムを修正するには，</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Apply</span> f a <span class="ot">=</span> f a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ApplyMaybe</span> a <span class="ot">=</span> <span class="dt">Apply</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p>というように，<code>Apply</code> に全ての引数を渡してやる必要がある．こうすることで，<span class="ascii">Haskell</span> は <code>Apply</code> の定義から <code>Apply Maybe a</code> が <code>Maybe a</code> の別名であると認識できるようになる <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>．</p>
<p>型シノニムは，他にも幾つか用途上で制限がある．<span class="ascii">1</span>つ目は再帰的な型シノニムが作れないという制限だ．例えば，</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">InfiniteList</span> a <span class="ot">=</span> (a, <span class="dt">InfiniteList</span> a)</span></code></pre></div>
<p>という定義は <span class="ascii">Haskell</span> では却下される．相互再帰的な定義も許容されていない<span class="ascii">:</span></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Rec1</span> <span class="ot">=</span> [<span class="dt">Rec2</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Rec2</span> <span class="ot">=</span> [<span class="dt">Rec1</span>]</span></code></pre></div>
<p><code>Rec1</code> の型を具体的に求めようとすると，<code>[Rec2]</code> の型になる．<code>Rec2</code> はやっぱり型シノニムで，<code>[Rec1]</code> の別名なので，この型はさらに <code>[[Rec1]]</code> という型になる．このようにして具体的な型を求めようとしても永遠に型シノニムがどこかしらに入り込むことになってしまい，型シノニムが現れない型を求めることはできない．<span class="ascii">Haskell</span> ではそのようなことがないように，そのような定義を排除している <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>．</p>
<p>もう<span class="ascii">1</span>つの制約は，型シノニムを型クラスのインスタンスとして使えないというものだ．例えば，次のようなことはできない<span class="ascii">:</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">I</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">C</span> a</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">C</span> <span class="dt">I</span></span></code></pre></div>
<p>代わりに，</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">C</span> a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">C</span> <span class="dt">Int</span></span></code></pre></div>
<p>というように型シノニムを使わず書く必要がある．これは型シノニムを使って書けない唯一の例外だ．ただ，この制限は本質的なものではなく，<span class="ascii">Haskell</span> 標準で型シノニムに対する混乱を避けるための制限になっている．もし，型シノニムに対してインスタンスを書けるようにしても，型シノニムは単なる別名なので，それは元となった型に対してインスタンスを定義してることと同じになる．このため，</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">C</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> x</span></code></pre></div>
<p>という関数は，<code>type Age = Int</code> による型シノニム <code>Age</code> に対して <code>C</code> のインスタンスが定義されていた場合，<code>a</code> が <code>Age</code> の場合も <code>Int</code> の場合も許容される．これは，プログラマが意図していない動作かもしれない．つまり，年齢のデータだけにインスタンスを定義したつもりが，整数データ全般に対していつのまにかインスタンスを定義してしまったことになるからだ <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>．</p>
<p>これらの制限はあるものの，型シノニムはデータ型を定義する上でとても強力で，しかも簡単に使用できる機能だ．</p>
<h2 id="代数的データ型"><span class="link-to-here-outer"><a href="#代数的データ型" title="代数的データ型"><span class="link-to-here">Link to<br />
here</span></a></span>代数的データ型</h2>
<p>さて，型シノニムでデータ型を定義する場合には幾つかの制限があった．では，この制限を超えたデータ型を定義する方法はないのだろうか？ そのような場合には代数的データ型 <span class="ascii">(algebraic datatype)</span> を使うことができる．</p>
<p>代数的データ型は，複数の型の値を統合して<span class="ascii">1</span>つの型の値として扱うデータ型の積と，複数の型の表現範囲を合わせて<span class="ascii">1</span>つの型として扱うデータ型の和を組み合わせることで構成されている．そして，このデータ型の定義は，型シノニムと異なり完全に新しい型を作り出す．実際の例を見てみよう．</p>
<p>あなたは積木パズルのパーツそれぞれの面積を計算する関数を，書かなければいけない．積木パズルのパーツはそれぞれ，長方形，真円，三角形から構成されている．まずはこのパーツを <span class="ascii">Haskell</span> のデータ型に落とし込む必要がある．それぞれのパーツにおいて，</p>
<ul>
<li>四角形の面積は縦横の長さ</li>
<li>真円は半径</li>
<li>三角形は三辺の長さ</li>
</ul>
<p>によって特徴付けられている．では，これを代数的データ型に落とし込んでみよう<span class="ascii">:</span></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PuzzleElement</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Rect</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Double</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- ^ 縦の長さ</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Double</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- ^ 横の長さ</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Circle</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Double</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- ^ 半径</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Triangle</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- ^ 三つの辺の長さを与える</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Double</span> <span class="dt">Double</span> <span class="dt">Double</span> </span></code></pre></div>
<p>この定義は，<code>PuzzleElement</code> という新しい型を作り，<span class="ascii">3</span>つの値コンストラクタを作る．それぞれ</p>
<ul>
<li><code>Rect :: Double -&gt; Double -&gt; PuzzleElement</code></li>
<li><code>Circle :: Double -&gt; PuzzleElement</code></li>
<li><code>Triangle :: Double -&gt; Double -&gt; Double -&gt; PuzzleElement</code></li>
</ul>
<p>という型を持つ．<code>Rect</code> は <code>Double</code> 型の値を<span class="ascii">2</span>つ受け取り，その<span class="ascii">2</span>つの値を <code>PuzzleElement</code> 型の<span class="ascii">1</span>つの値として統合する．つまり，<code>Double</code> 型<span class="ascii">2</span>つの積を作る．<code>Circle</code> や <code>Triangle</code> も同様だ．そして，<code>PuzzleElement</code> 型は<span class="ascii">3</span>種類の積の値のいずれかを表し，すなわちこれら<span class="ascii">3</span>種類の積の和を表す．このように，積和によって新しいデータ型を定義できるのが <code>data</code> 宣言であり，それによって定義されるのが代数的データ型になる．</p>
<p>代数的データ型の値から統合した値を取り出したい時は，<code>case</code> 文を使ったパターンマッチを行う<span class="ascii">:</span></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">areaMeasure ::</span> <span class="dt">PuzzleElement</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>areaMeasure x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Rect</span> w h <span class="ot">-&gt;</span> w <span class="op">*</span> h</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Circle</span> r <span class="ot">-&gt;</span> r <span class="op">*</span> r <span class="op">*</span> <span class="fu">pi</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Triangle</span> s1 s2 s3 <span class="ot">-&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="ot">=</span> (s1 <span class="op">+</span> s2 <span class="op">+</span> s3) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> <span class="fu">sqrt</span> <span class="op">$</span> s <span class="op">*</span> (s <span class="op">-</span> s1) <span class="op">*</span> (s <span class="op">-</span> s2) <span class="op">*</span> (s <span class="op">-</span> s3)</span></code></pre></div>
<p><code>areaMeasure</code> によってパズルのピースの面積を求めることができるようになった．</p>
<p>前に紹介した型シノニムは，ある型に対してその別名を与えるだけだった．それに比べ，代数的データ型では新しいデータ型を作り，その型の値を作る値コンストラクタを定義する．そして，型シノニムと大きく異なる点は，型システム上からは新たに定義された型しか分からず，実際にそのデータ型がどういう型から構成されるか分からない点にある．<code>PuzzleElement</code> 型の値は，もしかしたら <code>Double</code> 型の<span class="ascii">2</span>つの値から <code>Rect</code> コンストラクタを介して作られているかもしれないし，<code>Double</code> 型<span class="ascii">1</span>つの値から <code>Circle</code> コンストラクタを通して作られているかもしれない．これは実行時にその関数でパターンマッチをしてみて初めて分かることだ．型シノニムでは，型システムからそれがどういう型を元にしていたか分かるが，代数的データ型で観測できるのは新たに作られたデータ型があることだけだ．この違いは，代数的データ型と型シノニムの制約の違いに表れてくる．代数的データ型では，型シノニムの時に挙げたような制約はない．</p>
<p>例えば，代数的データ型は型シノニムと同様，パラメータをとることができ，さらに部分適用も可能だ <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a><span class="ascii">:</span></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Apply</span> f a <span class="ot">=</span> <span class="dt">Apply</span> (f a)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ApplyMaybe</span> <span class="ot">=</span> <span class="dt">Apply</span> <span class="dt">Maybe</span></span></code></pre></div>
<p>これは <span class="ascii">Haskell</span> の正しいプログラムになる．<code>Apply</code> は，<span class="ascii">2</span>つのパラメータをとる型コンストラクタになっていて，データ型 <code>Apply f a</code> の値を作る方法として，<code>f a</code> 型の値から値コンストラクタ <code>Apply :: f a -&gt; Apply f a</code> を通す方法がある．<code>ApplyMaybe</code> は <code>Apply Maybe</code> の型シノニムになっていて，これを使えば <code>Apply Maybe Int</code> と書く代わりに <code>ApplyMaybe Int</code> と書けるようになる．<code>ApplyMaybe</code> の定義は，<code>Apply</code> に対して<span class="ascii">1</span>つのパラメータしか渡していない．にも関わらず正しいというのが，型シノニムと異なる点になる．</p>
<p>再帰的なデータ型を代数的データ型で定義することも可能だ<span class="ascii">:</span></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Nil</span></span></code></pre></div>
<p>データ型 <code>List a</code> は <code>a</code> 型の要素を持つ単連結リストを表す．値コンストラクタが <code>List a</code> 型の値を受け取ることがポイントだ．型シノニムでは，その型の定義に自身を含めることはできなかった．これは実際の具体的な型を求めようとした時，その計算が永遠に終わらなくなってしまうからだった．代数的データ型 <code>List a</code> ではその型は単に新しい型として作られ，実際にその型の値がどういう型の値によって構成されているか知る必要はない．<code>List a</code> はそれ自体が具体的な型であり <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> ，それ以上計算する必要はないからだ．代数的データ型において，定義された型とその型の値を作る方法は分離されている．そのため，データ型の計算においてその型の値を作る方法は考慮されない．よって，自身が定義中で用いられても，型シノニムのようにデータ型の計算が永遠に終わることがないということはないため，その操作が許容されている．</p>
<p>もちろん，新しい型が定義されるため，型クラスのインスタンスを混乱なく定義できる．代数的データ型を作成した時，基本的なインスタンスを定義することは <span class="ascii">Haskell</span> プログラミングにおいてよくあることだ．<span class="ascii">Haskell</span> では，言語機能としてそれを支援する機能がある．それは，<code>deriving</code> 構文というもので，<code>Eq</code> <span class="ascii">/</span> <code>Ord</code> などの標準的な型クラスを，データ型の定義から自動で導出してくれる．例えば，<code>List a</code> に対して使ってみると，以下のようになる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Nil</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>このように代数的データ型は，型シノニムでは定義できなかったデータ型を定義することができる．そして，代数的データ型は全く新しい型を作ることもできる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Succ</span> <span class="dt">Nat</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Zero</span></span></code></pre></div>
<p>このデータ型 <code>Nat</code> は，他の型には依存しない全く新しい型だ．このように，代数的データ型は型シノニムと異なり全く新しい構造を作り出すことができる．</p>
<p>ただ，その代わり既存の関数を流用できなくなってしまう場合がある．例えば，</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> <span class="dt">Tuple</span> a b</span></code></pre></div>
<p>は，<code>(a, b)</code> と構造が同じであり，<code>(a, b)</code> に対する関数 <code>fst :: (a, b) -&gt; a</code> を適用できてもいいはずだ．ところが，データ型 <code>Tuple a b</code> とその値コンストラクタは型システム上は切り離されているため，自身の値が <code>(a, b)</code> の値と同じ方法でしか構成できないことを知らない．<code>Tuple a b</code> と <code>(a, b)</code> において型上で言及できることは，それらが異なる型であるということだけだ．なので，<code>fst</code> に <code>Tuple a b</code> 型の値を渡すことはできない．これは，もし型シノニムを使って，</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> (a, b)</span></code></pre></div>
<p>と定義した場合は解決する問題だ <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>．</p>
<p>このように両者にはトレードオフがあり，利用目的に合った使い分けをするのがいいだろう．</p>
<p>さて，<code>data</code> 宣言の構文は他に<span class="ascii">2</span>つ，便利な機能がある．</p>
<p><span class="ascii">1</span>つは正格性フラグと呼ばれる機能で，値コンストラクタにおいて引数を正格に評価することを強制できる．例えば，</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StrictTuple</span> a b <span class="ot">=</span> <span class="dt">StrictTuple</span> <span class="op">!</span>a <span class="op">!</span>b</span></code></pre></div>
<p>というように，正格性フラグ <code>!</code> を使った定義を行うと，値コンストラクタ <code>StrictTuple :: a -&gt; b -&gt; StrictTuple</code> はその引数を正格に評価してから格納するようになる．通常，</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> <span class="dt">Tuple</span> a b</span></code></pre></div>
<p>のように正格性フラグを使わない定義では，</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span> <span class="dt">Tuple</span> <span class="fu">undefined</span> <span class="fu">undefined</span> <span class="kw">of</span> <span class="dt">Tuple</span> _ _ <span class="ot">-&gt;</span> ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
<p>のように値コンストラクタは受け取った引数の評価を行わず，素直にそのままの形で遅延させて格納するため，エラーを出す式を渡してもその式の評価を行わない限りエラーにはならない．これは通常の関数の動作と同じになる．ところが，正格性フラグを使用した <code>StrictTuple</code> の場合，</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span> <span class="dt">StrictTuple</span> <span class="fu">undefined</span> <span class="fu">undefined</span> <span class="kw">of</span> <span class="dt">StrictTuple</span> _ _ <span class="ot">-&gt;</span> ()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span></code></pre></div>
<p>のように引数の評価を行うため，エラーを出す式を受け取った場合値コンストラクタの適用においてその式を評価しエラーを出す．データ型を作成する際，その元となる式の評価を強制させることはパフォーマンスに大きく寄与する．そのため，そのようなことを支援するために正格性フラグは設けられている．</p>
<p>また，代数的データ型の値コンストラクタはフィールド名を持つことができる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> <span class="dt">Tuple</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> firstVal  ::</span> a</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> secondVal ::</span> b</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>この場合，型コンストラクタ <code>Tuple</code>，値コンストラクタ <code>Tuple :: a -&gt; b -&gt; Tuple a b</code> の他に，関数 <code>firstVal :: Tuple a b -&gt; a</code>， <code>secondVal :: Tuple a b -&gt; b</code> が作られる．また，値コンストラクタの呼び出しにおいて特別なレコード構文 <code>Tuple { firstVal = 0, secondVal = 1 }</code> を使用でき，またレコード更新構文 <code>(Tuple 2 1) { firstVal = 0 }</code> を使用できる．これらは両者 <code>Tuple 0 1</code> と同様の値が作成される．</p>
<h2 id="ある型を元に新たな型を作る-datatype-renaming"><span class="link-to-here-outer"><a href="#ある型を元に新たな型を作る-datatype-renaming" title="ある型を元に新たな型を作る-datatype-renaming"><span class="link-to-here">Link to<br />
here</span></a></span>ある型を元に新たな型を作る <span class="ascii">(Datatype Renaming)</span></h2>
<p>さて，これまで見てきたように，型シノニムは型の別名を定義し，代数的データ型は型の積和により新たなデータ型を定義するものだった．<span class="ascii">Haskell</span> にはもう<span class="ascii">1</span>つデータ型を定義する方法がある．それが <code>newtype</code> 宣言だ．この宣言によって作られるデータ型は，型システム上は代数的データ型と同じように扱われ，実行時は型シノニムと同様の動作をする．</p>
<p><code>newtype</code> 宣言の構文は，<code>data</code> 宣言と同じような形をしている<span class="ascii">:</span></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> a</span></code></pre></div>
<p>フィールド名をつけることもできる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> unIdentity ::</span> a</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>この場合 <code>data</code> 宣言と同様に，型コンストラクタ <code>Identity</code>，値コンストラクタ <code>Identity</code> が作られることになる．ただし，<code>data</code> 宣言と異なり <code>newtype</code> は積和の機能を使用することはできない．単にある<span class="ascii">1</span>つの型を受け取る値コンストラクタしか定義できない．なので，</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Unit</span> <span class="ot">=</span> <span class="dt">Unit</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Tuple</span> a b <span class="ot">=</span> <span class="dt">Tuple</span> a b</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Enum</span> <span class="ot">=</span> <span class="dt">A</span> <span class="op">|</span> <span class="dt">B</span> <span class="op">|</span> <span class="dt">C</span></span></code></pre></div>
<p>はいずれも受け入れられない．この <code>newtype</code> の制約はいまいちよく分からない．では，このような制約によりどのような違いが出るのだろうか？ <code>newtype</code> と <code>data</code> は型システム上は違いはない．しかし，パターンマッチの動作など，実行時の動作に少し差異が設けられている．例えば，通常</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DataIdentity</span> a <span class="ot">=</span> <span class="dt">DataIdentity</span> a</span></code></pre></div>
<p>において，</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">DataIdentity</span> () <span class="kw">of</span> <span class="dt">DataIdentity</span> _ <span class="ot">-&gt;</span> ()</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span></code></pre></div>
<p>のようにエラーを出す式をパターンマッチで分解しようとするとエラーが出力される．ところが，<code>newtype</code> によって作られた値コンストラクタの場合，</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">Identity</span> () <span class="kw">of</span> <span class="dt">Identity</span> _ <span class="ot">-&gt;</span> ()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
<p>のようにパターンマッチ時にエラーが出されることはない．<span class="ascii">Haskell</span> では <code>newtype</code> で作られた値コンストラクタが実行動作に影響することはないと規定されている．よって，上のパターンマッチは，以下と同様の動きをすることになっている<span class="ascii">:</span></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">Identity</span> () <span class="kw">of</span> _ <span class="ot">-&gt;</span> ()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
<p>このように値コンストラクタを指定しないパターンマッチの場合，<code>data</code> 宣言で作られたものもエラーを出さない<span class="ascii">:</span></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">DataIdentity</span> () <span class="kw">of</span> _ <span class="ot">-&gt;</span> ()</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
<p>よって，<code>data</code> と <code>newtype</code> で作られた値コンストラクタの動作が異なるのは，パターンマッチにおいて値コンストラクタを指定した場合だけということになる．</p>
<p>では，<code>newtype</code> はなぜ値コンストラクタを無視するよう規定されているのだろう？ これは，<code>newtype</code> によるデータ型が実行時の動作として型シノニムと同様の動作をすることを目的としてしているからだ．値コンストラクタが無視されるのは，</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> a</span></code></pre></div>
<p>という宣言は，</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IdentitySynonym</span> a <span class="ot">=</span> a</span></code></pre></div>
<p>という宣言と同様の意味を持って欲しいことを <span class="ascii">Haskell</span> の設計者が意図しているからだ．よって，</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">Identity</span> () <span class="kw">of</span> <span class="dt">Identity</span> _ <span class="ot">-&gt;</span> ()</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
<p>の動作は，</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">case</span><span class="ot"> undefined ::</span> <span class="dt">IdentitySynonym</span> () <span class="kw">of</span> _ <span class="ot">-&gt;</span> ()</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
<p>のように，代数的データ型ではなく型シノニムに合わせてあるため，<code>data</code> 宣言主体に見ると一見不思議な動作をしていたというわけだ．</p>
<p>さて，ではなぜわざわざ型シノニムとは別に <code>newtype</code> 宣言を導入したのだろうか？ 型シノニムには幾つか制約があったのを思い出して欲しい．そして，それらの制約は代数的データ型では解決されたのだった．それは <code>type</code> 宣言が単に型の別名を導入するのに対し，<code>data</code> 宣言が完全に新たな型を作るからだった．<code>newtype</code> はその点に着目し，実行時には単なる別名として動作するが型システム上は完全に別の新たな型を導入することで，<code>type</code> 宣言同様ある型の別名を作りたいものの型シノニムの制約は回避したい需要を満たすようにしたものだ．</p>
<p>例えば，大文字小文字を区別しない文字列データを考えてみよう．この場合，<code>"aBc" == "Abc"</code> であって欲しいが，これは型シノニムで</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CaseInsensString</span> <span class="ot">=</span> <span class="dt">String</span></span></code></pre></div>
<p>と定義するだけでは，</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> (<span class="st">&quot;aBc&quot;</span><span class="ot"> ::</span> <span class="dt">CaseInsensString</span>) <span class="op">==</span> (<span class="st">&quot;Abc&quot;</span><span class="ot"> ::</span> <span class="dt">CaseInsensString</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span></span></code></pre></div>
<p>のままだ．そこで，<code>newtype</code> を使って，</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Char</span> <span class="kw">as</span> <span class="dt">Char</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">CaseInsensString</span> <span class="ot">=</span> <span class="dt">CaseInsens</span> <span class="dt">String</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">CaseInsensString</span> <span class="kw">where</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">CaseInsens</span> s1 <span class="op">==</span> <span class="dt">CaseInsens</span> s2 <span class="ot">=</span> go s1 s2</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>      go []       []       <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>      go []       (_<span class="op">:</span>_)    <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>      go (_<span class="op">:</span>_)    []       <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>      go (c1<span class="op">:</span>cs1) (c2<span class="op">:</span>cs2) <span class="ot">=</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">toLower</span> c1 <span class="op">==</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">toLower</span> c2 <span class="op">&amp;&amp;</span> go cs1 cs2</span></code></pre></div>
<p>とすれば，</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="dt">CaseInsens</span> <span class="st">&quot;aBc&quot;</span> <span class="op">==</span> <span class="dt">CaseInsens</span> <span class="st">&quot;Abc&quot;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span></code></pre></div>
<p>とできる．型シノニムは単なる <code>String</code> の別名なので，<code>String</code> と異なるインスタンスを新しく定義することはできない．それに対して，<code>newtype</code> によるデータ型は代数的データ型と同様に自由に定義することができる．そして，値コンストラクタ <code>CaseInsens</code> は単なる飾りであり，実行時には完全に無視されるため，<code>CaseInsensString</code> は動作としては <code>String</code> の別名としてみることができる．</p>
<p><code>newtype</code> は型シノニムでの制約であった，</p>
<ul>
<li>再帰的なデータ型が定義できない</li>
<li>型コンストラクタに対する部分適用ができない</li>
</ul>
<p>といった問題も解決する．このように <code>newtype</code> は型シノニムの問題を改善したデータ型を定義するが，<code>data</code> 宣言と同様型シノニムでは起きなかった問題も一緒に顕在化させてしまう．</p>
<p>上の例で，<code>CaseInsens</code> は飾りだと言ったが，実際にはこの値コンストラクタは必要不可欠であり，重要な役割を持っている．例えば，</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="dt">CaseInsens</span> <span class="st">&quot;aBc&quot;</span> <span class="op">==</span> <span class="dt">CaseInsens</span> <span class="st">&quot;Abc&quot;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span></code></pre></div>
<p>の例は，片方だけ</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;aBc&quot;</span> <span class="op">==</span> <span class="dt">CaseInsens</span> <span class="st">&quot;Abc&quot;</span></span></code></pre></div>
<p>としてしまうと，コンパイルエラーになってしまう．なぜなら，<code>(==)</code> は<span class="ascii">2</span>つの引数が同じ型の値である必要があり，<code>"aBc"</code> の型である <code>String</code> と <code>CaseInsens "Abc</code> の型である <code>CaseInsensString</code> は全く異なる型であるからだ．つまり，値コンストラクタ <code>CaseInsens</code> は，実行時には何の影響も与えないが，型システム上は全く異なる型の値であることを示すマーカーとなる．そして，型シノニムではデータ型は単なる別名であったが，<code>newtype</code> は <code>data</code> と同様全く新たな型として導入する道を選んだため，元の型として受け入れてもらうことが出来なくなってしまったのだ．</p>
<p>といっても，これは一長一短である．<code>data</code> と同様 <code>newtype</code> で作られた型は，型シノニムのように既存の関数を使い回すことができない．その反面，データの意味に沿わないプログラムを型によって弾くことができるという点は長所になる場合もある．例えば，<code>"aBc" == CaseInsens "Abc"</code> の例は，一体どのような結果を返すべきか一見して分からない．両者は単なる文字列と，大文字小文字を区別しない文字列という異なるデータを表しており，その比較は定義されないとするのが自然だろう．このような場合に，型シノニムでは定義されないことを表す方法はなかったが，<code>newtype</code> は元の型と異なる型を持つので，そのような仕組みを作ることができる．</p>
<p>さて，<code>newtype</code> において値コンストラクタは実行時に何の影響も及ぼさないことと，何故そうなっているかについて分かってもらえただろうか？ この影響は，パターンマッチ以外にも表れる．例えば，<code>newtype</code> の値コンストラクタに正格性フラグの機能はない．</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">StrictNewtype</span> <span class="ot">=</span> <span class="dt">StrictNewtype</span> <span class="op">!</span><span class="dt">Int</span></span></code></pre></div>
<p>というプログラムは，<span class="ascii">Haskell</span> では受け入れられない．なぜなら，これを受け入れた場合，値コンストラクタがあるかどうかによって実行時の動作が変わってしまうからだ．ただ，その他の <code>data</code> 宣言の機能は使用できる．<code>deriving</code> も使用できる．<code>newtype</code> で作られたデータ型は，元のデータ型のインスタンスを継承することはできない．全く新たな型を作ったため，更地の状態から始まる．ただし，<code>deriving</code> を使うことでインスタンスを用意に導出することは可能だ．ただ，標準クラスのインスタンスしか自動で導出できないため，自身で定義した型クラスなどのインスタンスは一から書く必要がある．そのことには，注意する必要があるだろう <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>．</p>
<p>最後に少し応用的な <code>newtype</code> の使い方を紹介しよう．<code>newtype</code> は上のように目的に合わせて型を既存の型から作る他，型シノニムの制約によって定義できない型上の計算を実現するのにも使用できる．例えば，</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</span></code></pre></div>
<p>という変わったデータ型を使うと，型上の不動点演算をエミュレートできる．また，<code>newtype</code> を使うことで幽霊型による曖昧な型を避けることもできる．例えば，</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">WithAnn</span> ann a <span class="ot">=</span> a</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readShow ::</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">WithAnn</span> a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>readShow s <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> <span class="fu">read</span> s</span></code></pre></div>
<p>を考える．この関数 <code>readShow</code> は，<code>WithAnn</code> で引数に <code>a</code> を使っているにもかかわらず <code>a</code> が曖昧な型になるため弾かれる．なぜなら，型シノニム <code>WithAnn a String</code> は <code>String</code> と書いてるのと同じであり，<code>readShow</code> は</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readShow ::</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>という型を持つのと同様になってしまうからだ．このため，制約だけに <code>a</code> が現れることになってしまい，曖昧な型になってしまう．この例のような，型シノニムが具体化されてしまうことで曖昧な型が生じる問題は，<code>newtype</code> を使用することで回避できる<span class="ascii">:</span></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">WithAnn</span> ann a <span class="ot">=</span> <span class="dt">WithAnn</span> a</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readShow ::</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">WithAnn</span> a <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>readShow (<span class="dt">WithAnn</span> s) <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> <span class="fu">read</span> s</span></code></pre></div>
<p><span class="ascii">Haskell</span> は型システム上は <code>WithAnn a String</code> が実行時に単なる <code>String</code> の別名として扱われることを知らず，これを<span class="ascii">1</span>つの具体化された型として認識する．このため，実際には <code>a</code> が引数の値に何ら関与しない場合も，型 <code>a</code> を伴う型として残る．よって，この場合は <code>a</code> は曖昧な型にならず，<code>WithAnn a String</code> の <code>a</code> の部分にあてがわれる型から特定することができる．このように，型シノニムで早期に元となった型に具体化されることで生じる問題は，<code>newtype</code> を使うことで実際に値を作る箇所とパターンマッチの箇所での型計算に遅延させることができ，回避できる場合がある．</p>
<h2 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h2>
<p><span class="ascii">Haskell</span> の<span class="ascii">3</span>つのデータ型定義方法について紹介した．</p>
<p>型シノニムは，ある型に対してその別名を与えることで，データ型を定義するものだった．簡易で元の型に対する関数をそのまま流用でき，使いやすい反面，部分適用ができない，再帰的データ型が定義できない，型クラスのインスタンスにできないと言う制約があった．</p>
<p>代数的データ型は複数の型の積和によって全く新しいデータ型を定義するものだった．型シノニムであった制約を回避でき，新たな構造を導入できるが，関数の流用が困難な場合があり型シノニムとの使い分けが必要だった．</p>
<p><code>newtype</code> によるデータ型は，型システム上は代数的データ型と，実行時の動作は型シノニムと同様といった，それぞれの中間をとったようなものだった．型シノニムのような関数の流用ができない場合はあるものの，その代わり型シノニムの制約を回避でき，型システム上は全く異なる振る舞いを行うことも可能だった．</p>
<p>これらは，それぞれが一長一短を持ち，目的にあった使い分けをする必要がある．この記事が，そのような場合の助けになればいいと思う．では，今回はこれで．</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>型シノニムに対して部分適用を許容する一般的な方法は，型上にもラムダ抽象にあたる表現を導入することである．ただ，この場合型上の演算が停止しない場合があり，型システムが決定不能になる．このため，<span class="ascii">Haskell</span> では型シノニムに対しての部分適用は許容していない．<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>等価再帰データ型 <span class="ascii">(equirecursive types)</span> と呼ばれる特別な型を型システムに導入することで，このような型を許容する理論は存在するが，この理論はとても複雑で型検査のアルゴリズムも難しくなりがちである．<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>ただ，このような混乱が起こるかもしれないことを許容し，利便性のため型シノニムをインスタンス定義で使いたい場合，<code>TypeSynonymInstances</code> という <span class="ascii">GHC</span> 拡張を有効にすることで許容されるようになる．<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>型上の計算によって，実際の型が特定される型シノニムとは異なり，代数的データ型の型コンストラクタはそれ自体がもう計算できないものになる．それは部分適用されても同様であり，部分適用を許容することで型シノニムと同様の問題は起こらない．これが，代数的データ型で部分適用が許容されている理由になる．<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>実際にはパラメータ <code>a</code> の部分に具体的な型を当てはめないといけないが，当てはめればそれは完全に具体的な型になる．<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>なお，代数的データ型でも型シノニムと同様の利点を手に入れるための研究は，<span class="ascii">Haskell</span> では盛んに行われている．例えば，<code>Generic</code> <span class="ascii">/</span> <code>Data</code> 型クラス，<code>lens</code> パッケージなどを使うことで，構造が同じだが異なるデータ型で関数が流用できない問題を回避できる場合がある．<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><span class="ascii">GHC</span> 拡張では，<code>deriving</code> 構文の拡張として強力な機能がいくつか搭載されている．特に <code>newtype</code> によるデータ型の場合は，<code>GeneralizedNewtypeDeriving</code> や <code>DerivingVia</code> 拡張を使えば，インスタンスの自動導出の範囲を大幅に拡大できる．<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2020/antenna-with-gh-actions.html" lang="ja">Haskell AntennaのCI/CDをGitHub Actionsに移行する</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2020/strict-gotchas.html" style="margin-left: auto;" lang="ja">Strict拡張を使用する際の注意点</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
