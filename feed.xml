<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell-jp Blog</title>
    <link href="https://haskell.jp/blog/feed.xml" rel="self" />
    <link href="https://haskell.jp/blog" />
    <id>https://haskell.jp/blog/feed.xml</id>
    <author>
        <name>Haskell-jp</name>
        <email></email>
    </author>
    <updated>2019-12-30T00:00:00Z</updated>
    <entry>
    <title>regex-applicative: 内部DSLとしての正規表現（ブログ記事版）</title>
    <link href="https://haskell.jp/blog/posts/2019/regex-applicative.html" />
    <id>https://haskell.jp/blog/posts/2019/regex-applicative.html</id>
    <published>2019-12-30T00:00:00Z</published>
    <updated>2019-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>先日、といっても<span class="ascii">2019</span>年<span class="ascii">10</span>月<span class="ascii">18</span>日のことなんでもう<span class="ascii">2</span>ヶ月以上も経ってしまいましたが、私は<a href="https://opt.connpass.com/event/140566/"><span class="ascii">Regex Festa</span></a>というイベントで、「<a href="http://hackage.haskell.org/package/regex-applicative"><span class="ascii">regex-applicative</span></a>」というパッケージの紹介を致しました。<br />
今回は<a href="https://the.igreque.info/slides/2019-10-18-regex-applicative.html">その際使用したスライド</a>を、ブログ記事として詳しく共有させていただきたいと思います！<br />
発表時のスライドと比べて、より<span class="ascii">Haskell</span>を知っている人向けになってしまいますが、<span class="ascii">regex-applicative</span>の魅力を明確に伝えるために必要なのでご了承ください。<br />
<span class="ascii">Applicative</span>スタイルを前提知識とします。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#はじめにまとめ" title="はじめにまとめ">はじめにまとめ</a></li>
<li><a href="#regex-applicativeって" title="regex-applicativeって"><span class="ascii">regex-applicative</span>って？</a></li>
<li><a href="#regex-applicativeのapi概要" title="regex-applicativeのapi概要"><span class="ascii">regex-applicative</span>の<span class="ascii">API</span>概要</a></li>
<li><a href="#regex-applicativeの使用例" title="regex-applicativeの使用例"><span class="ascii">regex-applicative</span>の使用例</a>
<ul>
<li><a href="#ただの文字-sym-eq-s-s---re-s-s" title="ただの文字-sym-eq-s-s---re-s-s">ただの文字<span class="ascii">:</span> <code>sym :: Eq s =&gt; s -&gt; RE s s</code></a></li>
<li><a href="#空文字ε-pure-a---re-s-a" title="空文字ε-pure-a---re-s-a">空文字（ε）<span class="ascii">:</span> <code>pure :: a -&gt; RE s a</code></a></li>
<li><a href="#連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a" title="連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a">連接<span class="ascii">:</span> <code>(*&gt;) :: RE s a -&gt; RE s b -&gt; RE s b</code>・<code>string :: Eq a =&gt; [a] -&gt; RE a [a]</code></a></li>
<li><a href="#選択-re-s-a---re-s-a---re-s-a" title="選択-re-s-a---re-s-a---re-s-a">選択<span class="ascii">:</span> <code>(&lt;|&gt;) :: RE s a -&gt; RE s a -&gt; RE s a</code></a></li>
<li><a href="#繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a" title="繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a">繰り返し<span class="ascii">:</span> <code>many :: RE s a -&gt; RE s [a]</code>・<code>some :: RE s a -&gt; RE s [a]</code></a></li>
<li><a href="#オプショナルなマッチ-optional-re-s-a---re-s-maybe-a" title="オプショナルなマッチ-optional-re-s-a---re-s-maybe-a">オプショナルなマッチ<span class="ascii">:</span> <code>optional :: RE s a -&gt; RE s (Maybe a)</code></a></li>
<li><a href="#マッチした結果をhaskellの値に割り当て" title="マッチした結果をhaskellの値に割り当て">マッチした結果を<span class="ascii">Haskell</span>の値に割り当て</a>
<ul>
<li><a href="#組み込みの正規表現を使う" title="組み込みの正規表現を使う">組み込みの正規表現を使う</a></li>
<li><a href="#a---b---re-s-a---re-s-b-任意の一引数の関数を適用する" title="a---b---re-s-a---re-s-b-任意の一引数の関数を適用する"><code>(&lt;$&gt;) :: (a -&gt; b) -&gt; RE s a -&gt; RE s b</code><span class="ascii">:</span> 任意の（一引数の）関数を適用する</a></li>
<li><a href="#re-s-a---b---re-s-a---re-s-b-任意の関数を適用する" title="re-s-a---b---re-s-a---re-s-b-任意の関数を適用する"><code>(&lt;*&gt;) :: RE s (a -&gt; b) -&gt; RE s a -&gt; RE s b</code><span class="ascii">:</span> 任意の関数を適用する</a></li>
</ul></li>
<li><a href="#もうちょっと複雑な例" title="もうちょっと複雑な例">もうちょっと複雑な例</a></li>
</ul></li>
<li><a href="#regex-applicativeのメリット" title="regex-applicativeのメリット">👍<span class="ascii">regex-applicative</span>のメリット</a></li>
<li><a href="#regex-applicativeのデメリット" title="regex-applicativeのデメリット">👎<span class="ascii">regex-applicative</span>のデメリット</a></li>
<li><a href="#regex-applicativeの仕組み" title="regex-applicativeの仕組み">⚙️<span class="ascii">regex-applicative</span>の仕組み</a>
<ul>
<li><a href="#正規表現エンジンの分類" title="正規表現エンジンの分類">📑正規表現エンジンの分類</a></li>
<li><a href="#regex-applicativeの実際の実装" title="regex-applicativeの実際の実装"><span class="ascii">regex-applicative</span>の実際の実装</a></li>
</ul></li>
<li><a href="#類似のライブラリーとの比較を軽く" title="類似のライブラリーとの比較を軽く">類似のライブラリーとの比較を軽く</a>
<ul>
<li><a href="#各種パーサーコンビネーター" title="各種パーサーコンビネーター">各種パーサーコンビネーター</a>
<ul>
<li><a href="#番外編-replace-attoparsecreplace-megaparsec" title="番外編-replace-attoparsecreplace-megaparsec">番外編<span class="ascii">: replace-attoparsec</span>・<span class="ascii">replace-megaparsec</span></a></li>
</ul></li>
<li><a href="#verbalexpressions" title="verbalexpressions"><span class="ascii">VerbalExpressions</span></a></li>
</ul></li>
<li><a href="#まとめ" title="まとめ">まとめ</a></li>
</ul>
</div>
</div>
<h1 id="はじめにまとめ"><span class="link-to-here-outer"><a href="#はじめにまとめ" title="はじめにまとめ"><span class="link-to-here">Link to<br />
here</span></a></span>はじめにまとめ</h1>
<ul>
<li><span class="ascii">regex-applicative</span>は、<span class="ascii">Haskell</span>の式で正規表現を書ける内部<span class="ascii">DSL</span></li>
<li>パーサーコンビネーターっぽく使えて、かつ正規表現の良さ — 中間マッチが簡単にできる点など — を持ち合わせている</li>
<li>内部は「文字を受け取って続きの状態のリストを返す関数」として表現された<span class="ascii">NFA</span>で実装されている</li>
</ul>
<h1 id="regex-applicativeって"><span class="link-to-here-outer"><a href="#regex-applicativeって" title="regex-applicativeって"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">regex-applicative</span>って？</h1>
<p><a href="http://hackage.haskell.org/package/regex-applicative"><span class="ascii">regex-applicative</span></a>は、正規表現を<span class="ascii">Haskell</span>の内部<span class="ascii">DSL</span>として表現したライブラリーです。<br />
名前のとおり、いわゆる「<code>Applicative</code>スタイル」で正規表現を書くことができます。</p>
<h1 id="regex-applicativeのapi概要"><span class="link-to-here-outer"><a href="#regex-applicativeのapi概要" title="regex-applicativeのapi概要"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">regex-applicative</span>の<span class="ascii">API</span>概要</h1>
<p><span class="ascii">regex-applicative</span>には、正規表現オブジェクト<a href="http://hackage.haskell.org/package/regex-applicative-0.3.3.1/docs/Text-Regex-Applicative.html#t:RE"><code>RE</code>型</a>の値とマッチさせる文字列を受け取って、その結果を返す関数がいくつかあります。<br />
今回はそのうち最も単純な<code>match</code>関数を使用します。👇のような型定義となっています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">match ::</span> <span class="dt">RE</span> s a <span class="ot">-&gt;</span> [s] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>定義のとおり、<code>RE</code>型は型引数としてマッチさせる文字の型<code>s</code>と、マッチした結果にも使われる「正規表現の結果」を表す型<code>a</code>を受け取ります。<br />
<code>RE</code>型を<code>Applicative</code>のインスタンスにするためには、その結果を表す型が必須なのです。この後出す例でこの「正規表現の結果」を好きな値に変える方法を示しましょう。</p>
<p>そして第<span class="ascii">2</span>引数がマッチさせる文字列に当たります。<code>[s]</code>と<code>RE</code>型の第<span class="ascii">1</span>型引数<code>s</code>のリストになっているとおり、<code>match</code>関数<small>（と、その他の<span class="ascii">regex-applicative</span>において文字列をマッチさせる<span class="ascii">API</span>）</small>は任意のリストに対して使用することができます。<br />
<span class="ascii">Haskell</span>の標準の文字列<code>String</code>の実態は<code>[Char]</code>、すなわち<code>Char</code>のリストなので、通常<span class="ascii">regex-applicative</span>を使用する場合<code>s</code>には<code>Char</code>が割り当てられます。<br />
型変数なので、当然他の型のリストに対しても使用できます。これは他の正規表現ライブラリーではあまりない特性でしょう。</p>
<p>戻り値はおなじみの<code>Maybe</code>型です。マッチが成功すれば、引数に渡した正規表現<code>RE s a</code>型の「結果」、<code>a</code>型の値を<code>Just</code>にくるんで返します。そして失敗すればもちろん<code>Nothing</code>を返します。</p>
<p>⚠️<code>match</code>関数について特筆すべきことをもう一つ。他のよくある正規表現ライブラリーと異なり、<code>match</code>関数は完全一致じゃないとマッチしないのでご注意ください。<br />
<span class="ascii">regex-applicative</span>には完全一致じゃないといけない関数と完全一致じゃなくてもよい関数両方があるので、少し混乱します😰</p>
<h1 id="regex-applicativeの使用例"><span class="link-to-here-outer"><a href="#regex-applicativeの使用例" title="regex-applicativeの使用例"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">regex-applicative</span>の使用例</h1>
<p>それではいよいよ<span class="ascii">regex-applicative</span>パッケージを使ってみましょう。<br />
👇のコマンドでインストールして、<span class="ascii">GHCi</span>で試します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">stack</span> build regex-applicative</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ex">stack</span> exec ghci</a></code></pre></div>
<p><small>（最近の）</small><code>cabal</code>の場合は👇を実行すればできるはずです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="ex">cabal</span> v2-install --lib regex-applicative</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ex">cabal</span> v2-repl -b regex-applicative</a></code></pre></div>
<p><span class="ascii">GHCi</span>が起動したら、こちらの<code>import</code>文を張って、本記事のサンプルを実行する準備をしてください。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span> <span class="dt">Text.Regex.Applicative</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">import</span> <span class="dt">Text.Regex.Applicative.Common</span></a></code></pre></div>
<h2 id="ただの文字-sym-eq-s-s---re-s-s"><span class="link-to-here-outer"><a href="#ただの文字-sym-eq-s-s---re-s-s" title="ただの文字-sym-eq-s-s---re-s-s"><span class="link-to-here">Link to<br />
here</span></a></span>ただの文字<span class="ascii">:</span> <code>sym :: Eq s =&gt; s -&gt; RE s s</code></h2>
<p>ここからは、正規表現の基本的な機能を利用するための<span class="ascii">regex-applicative</span>の<span class="ascii">API</span>を紹介します。<br />
まずはただの文字一つにマッチする<code>sym</code>から<span class="ascii">:</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="dt">Nothing</span></a></code></pre></div>
<p><code>sym :: Eq s =&gt; s -&gt; RE s s</code>という型定義のとおり、引数として受け取った文字と文字列における文字が等しいかチェックして、等しければマッチした文字をそのまま返す正規表現を作ります。</p>
<p>また、より一般化したバージョンとして、<code>psym</code>という関数もあります。<br />
こちらは<code>psym :: (s -&gt; Bool) -&gt; RE s s</code>という型定義のとおり、「文字を受け取ってブール値を返す関数」を受け取って、受け取った関数が文字に対して<code>True</code>を返したらマッチする、という正規表現を作ります。</p>
<p>なので例えば、</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&gt;</span> match (psym (<span class="op">==</span> <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;a&quot;</span></a></code></pre></div>
<p>と書けば<code>sym</code>関数と全く同じことができますし、</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="op">&gt;</span> match (psym (<span class="ot">`elem`</span> <span class="st">&quot;abcdef&quot;</span>)) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="op">&gt;</span> match (psym (<span class="ot">`elem`</span> <span class="st">&quot;abcdef&quot;</span>)) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="dt">Just</span> <span class="ch">&#39;b&#39;</span></a></code></pre></div>
<p>と書けば、文字クラスっぽいことができます。</p>
<h2 id="空文字ε-pure-a---re-s-a"><span class="link-to-here-outer"><a href="#空文字ε-pure-a---re-s-a" title="空文字ε-pure-a---re-s-a"><span class="link-to-here">Link to<br />
here</span></a></span>空文字（ε）<span class="ascii">:</span> <code>pure :: a -&gt; RE s a</code></h2>
<p>正規表現に欠かせない、空文字（ε）を表す正規表現も作れます。<br />
<code>Applicative</code>型クラスの<code>pure</code>で表現します。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="op">&gt;</span> match (<span class="fu">pure</span> <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="op">&gt;</span> match (<span class="fu">pure</span> <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="dt">Nothing</span></a></code></pre></div>
<p>もちろん、<code>pure</code>は任意の値を受け取って「受け取った値をそのまま返すもの」を作ることができるので、結果として文字（列）以外の値を返す正規表現も、簡単に作ることができます。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="op">&gt;</span> match (<span class="fu">pure</span> <span class="dt">True</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="dt">Just</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="op">&gt;</span> match (<span class="fu">pure</span> <span class="dv">42</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="dt">Just</span> <span class="dv">42</span></a></code></pre></div>
<h2 id="連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a"><span class="link-to-here-outer"><a href="#連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a" title="連接-re-s-a---re-s-b---re-s-bstring-eq-a-a---re-a-a"><span class="link-to-here">Link to<br />
here</span></a></span>連接<span class="ascii">:</span> <code>(*&gt;) :: RE s a -&gt; RE s b -&gt; RE s b</code>・<code>string :: Eq a =&gt; [a] -&gt; RE a [a]</code></h2>
<p>続いて連接、つまり「二つ以上の正規表現を続けてマッチさせる正規表現を作る」処理です。<br />
<span class="ascii">regex-applicative</span>では、<code>Applicative</code>型クラスの<code>*&gt;</code>がそのまま連接として使えるようになっています。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">*&gt;</span> sym <span class="ch">&#39;b&#39;</span>) <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;b&#39;</span></a></code></pre></div>
<p>当然、単なる文字の正規表現を並べることはありふれたことなので、<code>string</code>関数という文字列を渡すだけのバージョンも用意されています。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="co">-- マッチする文字列は同じ、より分かりやすいバージョン</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="op">&gt;</span> match (string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a></code></pre></div>
<p>さらに、<span class="ascii">regex-applicative</span>の正規表現オブジェクトは<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:IsString"><code>IsString</code></a>型クラスのインスタンスでもあるので、<code>OverloadedStrings</code>言語拡張を使えば文字列リテラルだけで正規表現オブジェクトを作ることができます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="op">&gt;</span> match <span class="st">&quot;ab&quot;</span> <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a></code></pre></div>
<h2 id="選択-re-s-a---re-s-a---re-s-a"><span class="link-to-here-outer"><a href="#選択-re-s-a---re-s-a---re-s-a" title="選択-re-s-a---re-s-a---re-s-a"><span class="link-to-here">Link to<br />
here</span></a></span>選択<span class="ascii">:</span> <code>(&lt;|&gt;) :: RE s a -&gt; RE s a -&gt; RE s a</code></h2>
<p>正規表現の「選択」、すなわち「二つの正規表現のうちどちらか一方にマッチする正規表現を作る」処理は、<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a>型クラスでおなじみの<code>&lt;|&gt;</code>を使います<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">&lt;|&gt;</span> sym <span class="ch">&#39;b&#39;</span>) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="dt">Just</span> <span class="ch">&#39;a&#39;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">&lt;|&gt;</span> sym <span class="ch">&#39;b&#39;</span>) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="dt">Just</span> <span class="ch">&#39;b&#39;</span></a></code></pre></div>
<h2 id="繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a"><span class="link-to-here-outer"><a href="#繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a" title="繰り返し-many-re-s-a---re-s-asome-re-s-a---re-s-a"><span class="link-to-here">Link to<br />
here</span></a></span>繰り返し<span class="ascii">:</span> <code>many :: RE s a -&gt; RE s [a]</code>・<code>some :: RE s a -&gt; RE s [a]</code></h2>
<p>正規表現の「繰り返し」、指定した正規表現を繰り返しマッチさせる正規表現を作る処理は、これまた<code>Alternative</code>の<code>many</code>メソッド・<code>some</code>メソッドによって実装されています。<br />
<code>Alternative</code>型クラスのデフォルトの定義どおり、<code>many</code>が<span class="ascii">0</span>回以上の繰り返し、<code>some</code>が<span class="ascii">1</span>回以上の繰り返しを表しています。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="op">&gt;</span> match (many (sym <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;aaaaaaaaaa&quot;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="dt">Just</span> <span class="st">&quot;aaaaaaaaaa&quot;</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="op">&gt;</span> match (some (sym <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;aaaaaaaaaa&quot;</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="dt">Just</span> <span class="st">&quot;aaaaaaaaaa&quot;</span></a>
<a class="sourceLine" id="cb14-5" title="5"></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="op">&gt;</span> match (many (sym <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="dt">Just</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="op">&gt;</span> match (some (sym <span class="ch">&#39;a&#39;</span>)) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="dt">Nothing</span></a></code></pre></div>
<h2 id="オプショナルなマッチ-optional-re-s-a---re-s-maybe-a"><span class="link-to-here-outer"><a href="#オプショナルなマッチ-optional-re-s-a---re-s-maybe-a" title="オプショナルなマッチ-optional-re-s-a---re-s-maybe-a"><span class="link-to-here">Link to<br />
here</span></a></span>オプショナルなマッチ<span class="ascii">:</span> <code>optional :: RE s a -&gt; RE s (Maybe a)</code></h2>
<p>それから、いわゆる「正規表現の基本三演算」には含まれてませんが<small>（選択と<code>pure</code>で実装できるので）</small>、この後の例で使用するので「オプショナルなマッチ」を実現する方法を紹介しておきます。<br />
名前のとおり<code>optional</code>という関数を使います。これも<code>Alternative</code>型クラスに対して使える関数ですね！</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">*&gt;</span> optional (sym <span class="ch">&#39;b&#39;</span>)) <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="dt">Just</span> (<span class="dt">Just</span> <span class="ch">&#39;b&#39;</span>)</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="op">&gt;</span> match (sym <span class="ch">&#39;a&#39;</span> <span class="op">*&gt;</span> optional (sym <span class="ch">&#39;b&#39;</span>)) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="dt">Just</span> <span class="dt">Nothing</span></a></code></pre></div>
<h2 id="マッチした結果をhaskellの値に割り当て"><span class="link-to-here-outer"><a href="#マッチした結果をhaskellの値に割り当て" title="マッチした結果をhaskellの値に割り当て"><span class="link-to-here">Link to<br />
here</span></a></span>マッチした結果を<span class="ascii">Haskell</span>の値に割り当て</h2>
<p>ここからは、他の正規表現ライブラリーでは珍しい、「正規表現でマッチした結果を<span class="ascii">Haskell</span>の値に割り当てる方法」をより詳しく紹介します。</p>
<h3 id="組み込みの正規表現を使う"><span class="link-to-here-outer"><a href="#組み込みの正規表現を使う" title="組み込みの正規表現を使う"><span class="link-to-here">Link to<br />
here</span></a></span>組み込みの正規表現を使う</h3>
<p>例えば、<a href="http://hackage.haskell.org/package/regex-applicative-0.3.3.1/docs/Text-Regex-Applicative-Common.html#v:digit"><code>Text.Regex.Applicative.Common</code>モジュールにある<code>digit</code></a>は、一桁の数字<small>（つまり<code>0</code>から<code>9</code>）</small>にマッチした上で、結果としてマッチした値を<strong>文字ではなく、整数として</strong>返す正規表現を提供します。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="op">&gt;</span> match digit <span class="st">&quot;1&quot;</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="dt">Just</span> <span class="dv">1</span></a></code></pre></div>
<p>加えて、先ほど紹介した<code>many</code>関数と組み合わせると、マッチした結果を整数のリストとして取得することもできます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="op">&gt;</span> match (many digit) <span class="st">&quot;12345&quot;</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</a></code></pre></div>
<h3 id="a---b---re-s-a---re-s-b-任意の一引数の関数を適用する"><span class="link-to-here-outer"><a href="#a---b---re-s-a---re-s-b-任意の一引数の関数を適用する" title="a---b---re-s-a---re-s-b-任意の一引数の関数を適用する"><span class="link-to-here">Link to<br />
here</span></a></span><code>(&lt;$&gt;) :: (a -&gt; b) -&gt; RE s a -&gt; RE s b</code><span class="ascii">:</span> 任意の（一引数の）関数を適用する</h3>
<p><span class="ascii">regex-applicative</span>は、名前のとおり正規表現を<span class="ascii">Applicative</span>スタイルで利用できるようにするためのライブラリーです。<br />
当然ながら<code>Applicative</code>スタイルに必須の<code>&lt;$&gt;</code>関数も使用できます。<br />
正規表現オブジェクト<code>RE s a</code>型の返す「マッチした結果」に、あなたの好きな関数を適用して変換した正規表現を作れるのです。</p>
<p>先ほどの<code>many digit</code>の例を再利用して、マッチした整数の合計値を求めてみましょう。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="op">&gt;</span> match (<span class="fu">sum</span> <span class="op">&lt;$&gt;</span> many digit) <span class="st">&quot;12345&quot;</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="dt">Just</span> <span class="dv">15</span></a></code></pre></div>
<h3 id="re-s-a---b---re-s-a---re-s-b-任意の関数を適用する"><span class="link-to-here-outer"><a href="#re-s-a---b---re-s-a---re-s-b-任意の関数を適用する" title="re-s-a---b---re-s-a---re-s-b-任意の関数を適用する"><span class="link-to-here">Link to<br />
here</span></a></span><code>(&lt;*&gt;) :: RE s (a -&gt; b) -&gt; RE s a -&gt; RE s b</code><span class="ascii">:</span> 任意の関数を適用する</h3>
<p><span class="ascii">Applicative</span>スタイルのもう一つの重要な関数といえば、やっぱり<code>&lt;*&gt;</code>でしょう。<br />
<code>many digit</code>を再利用して、「先頭に書かれた桁数だけ数字を取得する」という例を書いてみます。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="op">&gt;</span> match (<span class="fu">take</span> <span class="op">&lt;$&gt;</span> digit <span class="op">&lt;*&gt;</span> many digit) <span class="st">&quot;312345&quot;</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="dt">Just</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a></code></pre></div>
<h2 id="もうちょっと複雑な例"><span class="link-to-here-outer"><a href="#もうちょっと複雑な例" title="もうちょっと複雑な例"><span class="link-to-here">Link to<br />
here</span></a></span>もうちょっと複雑な例</h2>
<p>ここまで紹介した例を使用してもうちょっと複雑な例を書いてみましょう。<br />
小さな正規表現を組み合わせて、<span class="ascii">http</span>か<span class="ascii">https</span>の<span class="ascii">URL</span>における、オリジンにマッチする正規表現を簡単に書いてみます。</p>
<p>まずは部品作りです。</p>
<p><span class="ascii">URL</span>のスキームにマッチさせるために、「<code>http</code>の後にオプショナルな<code>s</code>、続けて<code>://</code>」という文字列にマッチする正規表現を作ります。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="op">&gt;</span> schemeRe <span class="ot">=</span></a>
<a class="sourceLine" id="cb20-2" title="2">    ((<span class="op">++</span>) <span class="op">&lt;$&gt;</span> string <span class="st">&quot;http&quot;</span> <span class="op">&lt;*&gt;</span> (string <span class="st">&quot;s&quot;</span> <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="st">&quot;&quot;</span>))</a>
<a class="sourceLine" id="cb20-3" title="3">      <span class="op">&lt;*</span> string <span class="st">&quot;://&quot;</span></a></code></pre></div>
<p><code>&lt;*</code>を使うことで、<code>://</code>の部分にはマッチしてもマッチした結果は無視している点にご注意ください。<br />
<span class="ascii">regex-applicative</span>はこのように、「マッチしたら関数に渡す文字列」と「マッチしても関数に渡さない文字列」をユーザーが書き分けられるようになっているので、他の正規表現ライブラリーにあるようなキャプチャー<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>や、先読み言明・後読み言明などの機能が必要ないのです。</p>
<p>続けて、ホスト名にマッチする正規表現を作ります。<br />
ここでは単純化して、「アルファベットの小文字かピリオド<span class="ascii">1</span>文字以上」という文字列にしておきます。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="op">&gt;</span> hostRe <span class="ot">=</span> some (psym (<span class="ot">`elem`</span> [<span class="ch">&#39;a&#39;</span><span class="op">..</span><span class="ch">&#39;z&#39;</span>] <span class="op">++</span> <span class="st">&quot;.&quot;</span>))</a></code></pre></div>
<p>最後はポート番号です。<br />
<code>:</code>という文字の後に<a href="http://hackage.haskell.org/package/regex-applicative-0.3.3.1/docs/Text-Regex-Applicative-Common.html#v:decimal"><code>Text.Regex.Applicative.Common</code>に入った<code>decimal</code></a>、すなわち一桁以上の<span class="ascii">10</span>進数にマッチする正規表現を使います。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="op">&gt;</span> portRe <span class="ot">=</span> sym <span class="ch">&#39;:&#39;</span> <span class="op">*&gt;</span> decimal</a></code></pre></div>
<p>以上で正規表現のパーツができました。<br />
早速使ってみる… 前に、マッチした結果を割り当てるレコード型を定義します。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">data</span> <span class="dt">Origin</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb23-2" title="2">  <span class="dt">Origin</span> {<span class="ot"> scheme ::</span> <span class="dt">String</span>,<span class="ot"> host ::</span> <span class="dt">String</span>,<span class="ot"> port ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb23-3" title="3">  <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>あとは<code>&lt;$&gt;</code>や<code>&lt;*&gt;</code>を使って組み合わせて、<code>Origin</code>値コンストラクターに食わせるだけです！<br />
ポート番号はオリジンにおいてはなくても良いので、省略した場合は仮に<code>80</code>としておきましょう<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1">originRe <span class="ot">=</span> <span class="dt">Origin</span>   <span class="op">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb24-2" title="2">           schemeRe <span class="op">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb24-3" title="3">           hostRe   <span class="op">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb24-4" title="4">           (portRe <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="dv">80</span>)</a></code></pre></div>
<p>今度こそ使ってみます。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="op">&gt;</span> match originRe <span class="st">&quot;https://example.com:8080&quot;</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="dt">Just</span> (<span class="dt">Origin</span> {scheme <span class="ot">=</span> <span class="st">&quot;https&quot;</span>, host <span class="ot">=</span> <span class="st">&quot;example.com&quot;</span>, port <span class="ot">=</span> <span class="dv">8080</span>})</a>
<a class="sourceLine" id="cb25-3" title="3"><span class="op">&gt;</span> match originRe <span class="st">&quot;http://example.com&quot;</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="dt">Just</span> (<span class="dt">Origin</span> {scheme <span class="ot">=</span> <span class="st">&quot;http&quot;</span>, host <span class="ot">=</span> <span class="st">&quot;example.com&quot;</span>, port <span class="ot">=</span> <span class="dv">80</span>})</a></code></pre></div>
<p><span class="ascii">regex-applicative</span>を使うことで、<span class="ascii">URL</span>のオリジンにマッチさせるだけでなく、マッチした結果を<code>Origin</code>型の値として割り当てる正規表現が作れました！🎉</p>
<h1 id="regex-applicativeのメリット"><span class="link-to-here-outer"><a href="#regex-applicativeのメリット" title="regex-applicativeのメリット"><span class="link-to-here">Link to<br />
here</span></a></span>👍<span class="ascii">regex-applicative</span>のメリット</h1>
<p><span class="ascii">regex-applicative</span>パッケージには、他の正規表現ライブラリーと比べて、以下のメリットがあります。</p>
<ul>
<li>文字列以外の扱いにも強い
<ul>
<li>マッチした結果から（文字列以外の）<span class="ascii">Haskell</span>の値に割り当てるのが簡単！
<ul>
<li>「生のデータ」からアプリケーションにおける「コアの処理が欲しいデータ」への変換がワンストップ</li>
</ul></li>
<li>文字列だけでなく、任意のリストに対してマッチできる</li>
</ul></li>
<li>内部<span class="ascii">DSL</span>として書けるので、コンパイラーによる型チェックの恩恵を受けやすい
<ul>
<li>前述の「マッチした結果から（文字列以外の）<span class="ascii">Haskell</span>の値に割り当てる」処理も、すべて型チェックされる</li>
</ul></li>
</ul>
<h1 id="regex-applicativeのデメリット"><span class="link-to-here-outer"><a href="#regex-applicativeのデメリット" title="regex-applicativeのデメリット"><span class="link-to-here">Link to<br />
here</span></a></span>👎<span class="ascii">regex-applicative</span>のデメリット</h1>
<p>一方<span class="ascii">regex-applicative</span>パッケージには、他の正規表現ライブラリーに対する以下のデメリットがあります。</p>
<ul>
<li>コードは長い
<ul>
<li>内部<span class="ascii">DSL</span>なのでやむなし</li>
<li>専用のメタキャラクターより分かりやすい、とも言える</li>
</ul></li>
<li>ユーザーからの入力として、正規表現を受け取ることは難しい
<ul>
<li>これも内部<span class="ascii">DSL</span>なのでやむなし</li>
</ul></li>
<li>おそらく<span class="ascii">C</span>とかで書いたものほど速くはない
<ul>
<li>そんなに細かい最適化をしているわけではないし、<span class="ascii">Pure Haskell</span>なので…</li>
</ul></li>
<li><code>String</code>以外の文字列にはマッチできない…
<ul>
<li>これが<span class="ascii">Haskeller</span>にとって一番痛い</li>
<li><code>Text</code>や<code>ByteString</code>向けのものも、原理的に実装できないというわけではないはず</li>
<li>参考<span class="ascii">:</span> <a href="http://bicycle1885.hatenablog.com/entry/2012/12/24/234707"><span class="ascii">Haskell Tips (</span>文字列編<span class="ascii">) -</span> りんごがでている</a></li>
</ul></li>
</ul>
<h1 id="regex-applicativeの仕組み"><span class="link-to-here-outer"><a href="#regex-applicativeの仕組み" title="regex-applicativeの仕組み"><span class="link-to-here">Link to<br />
here</span></a></span>⚙️<span class="ascii">regex-applicative</span>の仕組み</h1>
<p>ここからは、<span class="ascii">regex-applicative</span>における正規表現エンジンがどのように作られているか、『<a href="https://gihyo.jp/book/2015/978-4-7741-7270-5">正規表現技術入門</a>』における正規表現エンジンの分類を参考に説明しましょう。</p>
<h2 id="正規表現エンジンの分類"><span class="link-to-here-outer"><a href="#正規表現エンジンの分類" title="正規表現エンジンの分類"><span class="link-to-here">Link to<br />
here</span></a></span>📑正規表現エンジンの分類</h2>
<p>『正規表現技術入門』の<span class="ascii">p.56</span>では、正規表現エンジンを次の二つに分類しています。</p>
<ul>
<li><span class="ascii">DFA</span>型
<ul>
<li>正規表現を決定性有限オートマトン（<span class="ascii">deterministic finite automaton</span>）と呼ばれるものに変換して正規表現マッチングを行う</li>
</ul></li>
<li><span class="ascii">VM</span>型
<ul>
<li>正規表現をバイトコード（<span class="ascii">bytecode</span>）と呼ばれるものに変換して正規表現マッチングを行う</li>
</ul></li>
</ul>
<p>さて、<span class="ascii">regex-applicative</span>の場合はどちらなのでしょうか？<br />
<a href="https://github.com/feuerbach/regex-applicative/">ソースコード</a>を読んでみると、どうやらどちらでもなさそうなことがわかります。<br />
というのも、正規表現オブジェクト<code>RE s a</code>を<span class="ascii">NFA</span>に<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Object.hs#L110-L111"><code>compile</code></a>という関数で変換した後、<span class="ascii">DFA</span>に変換しないでそのまま使っているからです。<br />
一般的に、<span class="ascii">NFA</span>は<span class="ascii">DFA</span>に変換可能で、変換してからマッチさせた方がしばしば高速にマッチできることが知られています。<br />
ところが<span class="ascii">regex-applicative</span>ではその変換を行わず、<span class="ascii">NFA</span>として使用しているのです。</p>
<p>なぜそうした仕様になっているかについて、私の推測を述べましょう<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>。<br />
<span class="ascii">regex-applicative</span>では先ほど紹介した<code>psym</code>関数のように、「任意の文字を受け取る関数」を正規表現オブジェクトに含められなければなりません。<br />
結果、関数がどんな文字の時にどんな値を返すのか<small>（マッチが成功するのかしないのか）</small>、正規表現オブジェクトをコンパイルする関数にはわからなくなってしまうのです。<br />
一方、効率の良い<span class="ascii">DFA</span>の実装では、<span class="ascii">DFA</span>の一つ一つの状態ごとに「どの文字を受け取ったら次はどの状態に遷移するか」という情報を、連想配列として持っておかなければなりません<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>。<br />
そのため、どの文字を受け取ったらマッチが成功するのかわからない箇所が正規表現オブジェクトに混ざっている限り、効率の良い<span class="ascii">DFA</span>の実装にはできないのです。</p>
<p>その分、<span class="ascii">regex-applicative</span>では任意の文字を受け取る関数が使えるので、普通の正規表現ライブラリーよりも柔軟に書くことができるようになっています。<br />
その点を考慮したトレードオフなんでしょう。</p>
<h2 id="regex-applicativeの実際の実装"><span class="link-to-here-outer"><a href="#regex-applicativeの実際の実装" title="regex-applicativeの実際の実装"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">regex-applicative</span>の実際の実装</h2>
<p>さらに<span class="ascii">regex-applicative</span>の実装を掘ってみましょう。<br />
先ほど紹介した<code>compile</code>関数は、正規表現オブジェクト<code>RE s a</code>を<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Object.hs#L38-L43"><code>ReObject s r</code></a>という型の、<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Types.hs#L9-L16"><code>Thread s r</code></a>型の値のキューに変換します。<br />
これが<span class="ascii">regex-applicative</span>における<span class="ascii">NFA</span>と呼べそうですね。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">newtype</span> <span class="dt">ReObject</span> s r <span class="ot">=</span> <span class="dt">ReObject</span> (<span class="dt">SQ.StateQueue</span> (<span class="dt">Thread</span> s r))</a></code></pre></div>
<p><code>Thread s r</code>型の値は、<span class="ascii">NFA</span>における状態遷移を表します。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">data</span> <span class="dt">Thread</span> s r</a>
<a class="sourceLine" id="cb27-2" title="2">    <span class="ot">=</span> <span class="dt">Thread</span></a>
<a class="sourceLine" id="cb27-3" title="3">        {<span class="ot"> threadId_ ::</span> <span class="dt">ThreadId</span></a>
<a class="sourceLine" id="cb27-4" title="4">        ,<span class="ot"> _threadCont ::</span> s <span class="ot">-&gt;</span> [<span class="dt">Thread</span> s r]</a>
<a class="sourceLine" id="cb27-5" title="5">        }</a>
<a class="sourceLine" id="cb27-6" title="6">    <span class="op">|</span> <span class="dt">Accept</span> r</a></code></pre></div>
<p>型定義のとおり、<code>Thread</code>と<code>Accept</code>という二通りの値をとります<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>。</p>
<ul>
<li>⏩<code>Thread</code>はその用途からして、事実上<code>s -&gt; [Thread s r]</code>という関数と同等の型です。<span class="ascii">regex-applicative</span>は<code>ReObject</code>によって文字列<code>[s]</code>の値をマッチさせる際、この<code>s -&gt; [Thread s r]</code>に文字を渡します。
<ul>
<li>➡️そして、関数が結果として返した、<code>Thread s r</code>型の値を<small>（そのリストから）</small>一つずつキューに追加して、また次の文字にマッチさせます。</li>
<li>↩️一方、関数が空リストを返した場合は — そう、マッチが失敗した、ということなのです。その場合は、キューからさらに<code>Thread s r</code>の値を取り出して<small>（値コンストラクターが<code>Thread</code>であれば）</small>マッチしなかった文字をまた<code>s -&gt; [Thread s r]</code>に渡します。</li>
<li>なお、<code>threadId_</code>はキューに追加する際同じ<code>threadId_</code>の<code>Thread</code>を追加してしまうのを防ぐためのキーです。詳細は割愛します。</li>
</ul></li>
<li>✅<code>Accept r</code>は名前のとおり<span class="ascii">NFA</span>の受理状態を表しています。<code>s -&gt; [Thread s r]</code>を繰り返し適用して最終的に<code>Accept r</code>を返した<code>Thread</code>のみが「マッチした」と解釈されます。</li>
</ul>
<p>このように、<span class="ascii">regex-applicative</span>における<span class="ascii">NFA</span>は<code>s -&gt; [Thread s r]</code>を返す関数、すなわち「文字を受け取って次の状態のリストを返す継続」として作られています。</p>
<p>ただ実際に実行する際の流れを見てみると、<code>ReObject</code>に含まれる<code>Thread</code>を一つずつ実行してみて、結果が条件に合うものを選ぶ、といった方が近いです。<br />
例えば<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Interface.hs#L81-L85"><code>match</code>関数</a>では、<code>ReObject</code>に文字を一文字ずつ与えた結果の中から、<code>listToMaybe</code>を使って最初に<code>Accept</code>にたどり着く<code>Thread</code>を取得しています。<br />
それから、最長マッチする部分文字列を検索する<a href="https://github.com/feuerbach/regex-applicative/blob/5e9a06622d33c7657353ddaccfe101b96946027a/Text/Regex/Applicative/Interface.hs#L141-L149"><code>findLongestPrefix</code>関数</a>は、マッチが失敗するか残りの文字列が空になるまで繰り返し文字を<code>ReObject</code>に与えることで、できるだけ長いマッチが返るように調整しています。<br />
このように<span class="ascii">regex-applicative</span>は、<code>ReObject</code><span class="ascii">(NFA)</span>に文字を一つずつ与えてマッチ結果を生成する処理と、そのマッチ結果を選び取る処理とを分離することで、様々な方針でマッチできるようになっているのです。</p>
<h1 id="類似のライブラリーとの比較を軽く"><span class="link-to-here-outer"><a href="#類似のライブラリーとの比較を軽く" title="類似のライブラリーとの比較を軽く"><span class="link-to-here">Link to<br />
here</span></a></span>類似のライブラリーとの比較を軽く</h1>
<h2 id="各種パーサーコンビネーター"><span class="link-to-here-outer"><a href="#各種パーサーコンビネーター" title="各種パーサーコンビネーター"><span class="link-to-here">Link to<br />
here</span></a></span>各種パーサーコンビネーター</h2>
<p>さて、ここまでこの文章を読んでいただけた方の中には、「これって<span class="ascii">megaparsec</span>とか<span class="ascii">attoparsec</span>とかのパーサーコンビネーターライブラリーと何が違うんだ？」という疑問をお持ちの方も多いでしょう。<br />
そう、大抵の場合、パーサーコンビネーターライブラリーも下記のような特徴を持ち合わせています。</p>
<ul>
<li><span class="ascii">Haskell</span>の内部<span class="ascii">DSL</span>として実装されている
<ul>
<li><code>Applicative</code>や<code>Alternative</code>型クラスのメソッドを利用した<span class="ascii">API</span></li>
</ul></li>
<li>マッチした結果から（文字列以外の）<span class="ascii">Haskell</span>の値に割り当てるのが簡単</li>
<li>「文字<span class="ascii">(</span><code>Char</code><span class="ascii">)</span>」の列以外にもマッチできる</li>
</ul>
<p>特に「<code>Applicative</code>や<code>Alternative</code>型クラスのメソッドを利用した<span class="ascii">API</span>」である点は興味深く、場合によっては、使うライブラリーだけ換えて式をコピペしてもコンパイルは通る、なんてことが普通にあり得るくらい似ています。<br />
ただし、当然コンパイルが通るだけでは意図通りに動くとは限りません。<br />
<span class="ascii">regex-alternative</span>と一般的なパーサーコンビネーターライブラリーには、「<strong>自動的にバックトラックをするかしないか</strong>」という違いがあるためです。</p>
<p>例えば、次の式は<span class="ascii">regex-applicative</span>でも<span class="ascii">attoparsec</span>でも有効な式ですが、<span class="ascii">regex-applicative</span>の<code>match</code>関数では、「<code>ab</code>が<span class="ascii">1</span>回以上繰り返される文字列」にマッチして最後の<code>ab</code>を返すことができるのに、<span class="ascii">attoparsec</span>の<code>parse</code>関数ではパースに失敗してしまいます。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1">many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span></a></code></pre></div>
<p><code>stack build regex-applicative attoparsec</code>した上で以下のように書いて試してみましょう。<br />
まずは<span class="ascii">regex-applicative</span>で試す場合<span class="ascii">:</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Regex.Applicative</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="op">&gt;</span> match (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;abab&quot;</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="op">&gt;</span> match (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb29-8" title="8"></a>
<a class="sourceLine" id="cb29-9" title="9"><span class="op">&gt;</span> match (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ababab&quot;</span></a>
<a class="sourceLine" id="cb29-10" title="10"><span class="dt">Just</span> <span class="st">&quot;ab&quot;</span></a></code></pre></div>
<p>いずれの文字列でも<code>Just "ab"</code>が返ってきてますね😌。</p>
<p>続いて<span class="ascii">attoparsec</span>で試す場合<span class="ascii">:</span></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="co">-- attoparsecは`String`をサポートしてないのでOverloadedStringsでTextとして扱う</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb30-3" title="3"></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Attoparsec.Text</span></a>
<a class="sourceLine" id="cb30-6" title="6"></a>
<a class="sourceLine" id="cb30-7" title="7"><span class="co">-- 文字列の終端であることを明確にするために、空文字列をfeedしておく</span></a>
<a class="sourceLine" id="cb30-8" title="8"><span class="op">&gt;</span> feed (parse (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;abab&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb30-9" title="9"><span class="dt">Fail</span> <span class="st">&quot;&quot;</span> [] <span class="st">&quot;not enough input&quot;</span></a>
<a class="sourceLine" id="cb30-10" title="10"></a>
<a class="sourceLine" id="cb30-11" title="11"><span class="op">&gt;</span> feed (parse (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb30-12" title="12"><span class="dt">Fail</span> <span class="st">&quot;&quot;</span> [] <span class="st">&quot;not enough input&quot;</span></a>
<a class="sourceLine" id="cb30-13" title="13"></a>
<a class="sourceLine" id="cb30-14" title="14"><span class="op">&gt;</span> feed (parse (many (string <span class="st">&quot;ab&quot;</span>) <span class="op">*&gt;</span> string <span class="st">&quot;ab&quot;</span>) <span class="st">&quot;ababab&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb30-15" title="15"><span class="dt">Fail</span> <span class="st">&quot;&quot;</span> [] <span class="st">&quot;not enough input&quot;</span></a></code></pre></div>
<p>いずれの文字列でも失敗になってしまいました。なぜうまくいかないのでしょう？<br />
それは文字列<code>"ababab"</code>における<code>ab</code>を、<code>many (string "ab")</code>が消費してしまい、<code>*&gt;</code>の右辺に書いた<code>string "ab"</code>が処理できなくなってしまうためです。<br />
対する<span class="ascii">regex-applicative</span>における<code>many (string "ab") *&gt; string "ab"</code>では、正規表現全体がマッチするよう、自動でバックトラックしてくれます。<br />
<span class="ascii">regex-applicative</span>でも最初に<code>many (string "ab")</code>が<code>"ababab"</code>全体を消費した直後では、<code>*&gt;</code>の右辺に書いた<code>string "ab"</code>のマッチは当然失敗してしまいます。<br />
しかし、<span class="ascii">regex-applicative</span>はそれではあきらめません。<code>*&gt;</code>の右辺に書いた<code>string "ab"</code>が成功するまで、失敗する度に<code>many (string "ab")</code>が消費した文字を<span class="ascii">1</span>文字ずつ返却してくれるのです。これがバックトラックです。<br />
<span class="ascii">regex-alternative</span>に限らず、大抵の正規表現エンジンがこのように自動的なバックトラックを行います。</p>
<p>こうした性質の違いにより、<span class="ascii">regex-applicative</span>は<strong>文字列の中間に指定したパターンをマッチさせる</strong>のが、パーサーコンビネーターライブラリーよりも得意です。</p>
<p>例えば「文字列の中間にある<span class="ascii">1</span>桁以上の<span class="ascii">10</span>進数」にマッチさせる場合、<span class="ascii">regex-alternative</span>では次のように書きます。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Regex.Applicative.Common</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="op">&gt;</span> match (few anySym <span class="op">*&gt;</span> decimal <span class="op">&lt;*</span> few anySym) <span class="st">&quot;abc12345def&quot;</span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="dt">Just</span> <span class="dv">12345</span></a></code></pre></div>
<p><code>few</code>は「控えめな繰り返し」を実現するための関数です。引数で指定した正規表現を<span class="ascii">0</span>回以上マッチさせる、という点では<code>many</code>と同じですが、前後にある正規表現がなるべく長くマッチするよう、優先してマッチさせてくれます。<br />
<code>few anySym</code>は普通の正規表現ライブラリーでいうところの<code>.*?</code>に相当します。</p>
<p>同じことを<span class="ascii">attoparsec</span>で実現するために<code>many anyChar *&gt; decimal &lt;* many anyChar</code>と書いてみても、やはりうまくいきません。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Attoparsec.Text</span></a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="op">&gt;</span> feed (parse (many anyChar <span class="op">*&gt;</span> decimal <span class="op">&lt;*</span> many anyChar) <span class="st">&quot;abc12345def&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="dt">Fail</span> <span class="st">&quot;&quot;</span> [] <span class="st">&quot;not enough input&quot;</span></a></code></pre></div>
<p>理由は先ほどと同様で、最初に書いた<code>many anyChar</code>がすべての文字列を消費してしまい、それ以降の<code>decimal</code>などがマッチできないためです。<br />
正しく処理するには、「<code>decimal</code>の先頭以外の文字列」、すなわち「数字以外の文字列」が<code>many</code>であることを明示する方法をとるしかありません<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="op">&gt;</span> nonDigits <span class="ot">=</span> many (satisfy (<span class="fu">not</span> <span class="op">.</span> <span class="fu">isDigit</span>))</a>
<a class="sourceLine" id="cb33-4" title="4"><span class="op">&gt;</span> feed ((parse (nonDigits <span class="op">*&gt;</span> decimal <span class="op">&lt;*</span> nonDigits)) <span class="st">&quot;abc12345def&quot;</span>) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="dt">Done</span> <span class="st">&quot;&quot;</span> <span class="dv">12345</span></a></code></pre></div>
<p>そんなわけで、<span class="ascii">regex-applicative</span>は、<span class="ascii">Haskell</span>によくあるパーサーコンビネーターのように<strong><span class="ascii">Applicative</span>スタイルで書けて、なおかつ他の正規表現ライブラリーのように中間マッチがしやすい</strong>という、両方の良さを持ち合わせていると言えます。</p>
<h3 id="番外編-replace-attoparsecreplace-megaparsec"><span class="link-to-here-outer"><a href="#番外編-replace-attoparsecreplace-megaparsec" title="番外編-replace-attoparsecreplace-megaparsec"><span class="link-to-here">Link to<br />
here</span></a></span>番外編<span class="ascii">: replace-attoparsec</span>・<span class="ascii">replace-megaparsec</span></h3>
<p>…と、<span class="ascii">regex-applicative</span>のよさを語ったところで舌の根も乾かぬうちに恐縮ですが、実は<span class="ascii">attoparsec</span>をはじめパーサーコンビネーターライブラリーの「中間マッチがやりにくい」という弱点を改善するためのパッケージがあります。<br />
<a href="http://hackage.haskell.org/package/replace-attoparsec"><span class="ascii">replace-attoparsec</span></a>や<a href="http://hackage.haskell.org/package/replace-megaparsec"><span class="ascii">replace-megaparsec</span></a>といいます<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>。<br />
名前のとおり<span class="ascii">replace-attoparsec</span>が<span class="ascii">attoparsec</span>を改善するパッケージで、<span class="ascii">replace-megaparsec</span>が<span class="ascii">megaparsec</span>を改善するパッケージです。<br />
名前も<span class="ascii">API</span>もお互いそっくりなんで<small>（作者も同じですしね）</small>、今回は<span class="ascii">replace-attoparsec</span>の方を紹介しましょう。</p>
<p><span class="ascii">replace-attoparsec</span>を使えば、次のように書くだけで「文字列の中間にある<span class="ascii">1</span>桁以上の<span class="ascii">10</span>進数」を取り出すことができます。</p>
<pre class="hakell"><code>import Replace.Attoparsec.Text

&gt; feed (parse (sepCap decimal) &quot;abc12345def&quot;) &quot;&quot;
Done &quot;&quot; [Left &quot;abc&quot;,Right 12345,Left &quot;def&quot;]</code></pre>
<p><code>"abc12345def"</code>の中間にある<code>12345</code>だけでなく、パースできなかった<code>abc</code>、<code>def</code>という文字列もおまけで取得できました！<br />
<code>decimal</code>がパースできた箇所が<code>Right</code>として、パースできなかった箇所が<code>Left</code>として返却されていることに注意してください。</p>
<p><span class="ascii">replace-attoparsec</span>の<code>sepCap</code><small>（「<span class="ascii">Separate and Capture</span>」の略だそうです）</small>は、引数として受け取ったパーサーを、</p>
<ol type="1">
<li>とりあえず先頭からマッチさせてみて、</li>
<li>失敗したら先頭の一文字をスキップして、次の文字からまたマッチさせてみる</li>
</ol>
<p>という処理を繰り返しています。<br />
結果的にパースできない文字列はすべてスキップして、文字列の中間にある、パースできる文字列のみにパーサーを適用できるのです。</p>
<h2 id="verbalexpressions"><span class="link-to-here-outer"><a href="#verbalexpressions" title="verbalexpressions"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">VerbalExpressions</span></h2>
<p>そろそろ力尽きてきたのでここからはスライドのコピペで失礼します…🙏</p>
<ul>
<li>詳細わかりませんが作りはよく似てる
<ul>
<li><a href="https://github.com/VerbalExpressions/JSVerbalExpressions#examples"><span class="ascii">JavaScript</span>の例がこちら</a></li>
</ul></li>
<li>変な記号の演算子ではなく英語でつけられた関数なので、こちらの方が分かりやすいという人は多そう</li>
<li><a href="https://github.com/VerbalExpressions"><span class="ascii">Haskell</span>を含むいろんな言語で提供されてるらしい</a></li>
<li>さっと<a href="http://hackage.haskell.org/package/verbalexpressions-1.0.0.0/docs/Text-Regex-VerbalExpressions.html"><span class="ascii">Haskell</span>版のドキュメント</a>読んだ感じ、文字列のマッチに特化してるっぽい？</li>
</ul>
<h1 id="まとめ"><span class="link-to-here-outer"><a href="#まとめ" title="まとめ"><span class="link-to-here">Link to<br />
here</span></a></span>まとめ</h1>
<p>以上です！👋<br />
まとめもスライドからのコピペで！</p>
<ul>
<li><span class="ascii">regex-applicative</span>は、<span class="ascii">Haskell</span>の式で正規表現を書ける内部<span class="ascii">DSL</span></li>
<li>パーサーコンビネーターっぽく使えて、かつ正規表現の良さを持ち合わせている</li>
<li>内部は「文字を受け取って続きの状態のリストを返す関数」として表現された<span class="ascii">NFA</span>で実装されている</li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><code>Alternative</code>は、<code>Applicative</code>より強力な（できることが多い）型クラスです。そういう意味で、<span class="ascii">regex-applicative</span>は本当は「<span class="ascii">regex-alternative</span>」と呼んだ方が適切なのかも知れません。<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>正確には、キャプチャーした文字列を正規表現の中で再利用することができないので、他の正規表現ライブラリーのキャプチャー機能と完全に同等のことができるわけではありません。これは現状の<span class="ascii">regex-applicative</span>の制限です。<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>もちろん、実際のところ<span class="ascii">https</span>の場合デフォルトのポート番号は<span class="ascii">443</span>であるべきですが、ちゃんと実装しようとすると結構複雑になるのでご容赦を！<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>この記事の最後の方を書いていて思い出しました。<span class="ascii">regex-applicative</span>は<span class="ascii">DFA</span>ベースの正規表現エンジンでは不可能な「控えめな繰り返し」をサポートしているから、という理由もあるようです。なぜ<span class="ascii">DFA</span>ベースでは「控えめな繰り返し」ができないかは私もうまく説明できません…。<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>『正規表現技術入門』の<span class="ascii">p. 132</span>における実装例では、これを状態と文字による二次元配列として実装しています。<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>並行並列プログラミングで出てくるあの「スレッド」とは違うのでご注意ください。<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>ただし、一般に、正規表現ライブラリーであってもこのような書き方をした方が効率よくマッチさせやすいでしょう。<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><a href="https://haskell.jp/blog/posts/2018/substring-parser.html">こちらの記事</a>でも触れているとおり、かつて私も同じ目的のパッケージを作成しました。しかし、これらのパッケージの方が明らかにドキュメントが充実していて、機能も豊富なので今回はこれらを紹介します。将来的には<span class="ascii">substring-parser</span>は<span class="ascii">deprecated</span>にするかも知れません。<a href="#fnref8" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/unicode-show.html" style="margin-left: auto;" lang="ja">日本語をshowしてうまく表示されなかったら</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>日本語をshowしてうまく表示されなかったら</title>
    <link href="https://haskell.jp/blog/posts/2019/unicode-show.html" />
    <id>https://haskell.jp/blog/posts/2019/unicode-show.html</id>
    <published>2019-12-22T00:00:00Z</published>
    <updated>2019-12-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#ℹ️この記事は" title="ℹ️この記事は">ℹ️この記事は🎄</a></li>
<li><a href="#日本語などの話者がhaskellを始めるとあるある" title="日本語などの話者がhaskellを始めるとあるある">日本語（などの）話者が<span class="ascii">Haskell</span>を始めるとあるある</a></li>
<li><a href="#unicode-showを使おう" title="unicode-showを使おう">🌐<span class="ascii">unicode-show</span>を使おう</a></li>
<li><a href="#unicode-showの最近の修正" title="unicode-showの最近の修正"><span class="ascii">unicode-show</span>の最近の修正</a></li>
<li><a href="#番外編pretty-simpleも使おう" title="番外編pretty-simpleも使おう">（番外編）<span class="ascii">pretty-simple</span>も使おう</a></li>
</ul>
</div>
</div>
<h1 id="ℹ️この記事は"><span class="link-to-here-outer"><a href="#ℹ️この記事は" title="ℹ️この記事は"><span class="link-to-here">Link to<br />
here</span></a></span>ℹ️この記事は🎄</h1>
<p>この記事は、<a href="https://qiita.com/advent-calendar/2019/haskell"><span class="ascii">Haskell Advent Calendar 2019</span></a> <span class="ascii">22</span>日目の記事です。<br />
例年どおりタイプセーフプリキュア！の話をするつもりでしたが、ネタが実装できなかったので<a href="http://hackage.haskell.org/package/unicode-show"><span class="ascii">unicode-show</span></a>の話をします<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。<br />
まぁ、こちらの方がみなさんにとっては有益でしょうし🙃</p>
<h1 id="日本語などの話者がhaskellを始めるとあるある"><span class="link-to-here-outer"><a href="#日本語などの話者がhaskellを始めるとあるある" title="日本語などの話者がhaskellを始めるとあるある"><span class="link-to-here">Link to<br />
here</span></a></span>日本語（などの）話者が<span class="ascii">Haskell</span>を始めるとあるある</h1>
<p><span class="ascii">GHCi</span>に日本語を入力したり…</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">ghci<span class="op">&gt;</span> <span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="st">&quot;\12415\12435\12394\12391\24184\12379\12466\12483\12488\12384\12424\65281&quot;</span></a></code></pre></div>
<p>日本語を<code>print</code>したり…</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">ghci<span class="op">&gt;</span> <span class="fu">print</span> <span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="st">&quot;\31169\12289\22570\24525\34955\12398\32210\12364\20999\12428\12414\12375\12383\65281&quot;</span></a></code></pre></div>
<p>日本語を<code>show</code>したり…</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">ghci<span class="op">&gt;</span> iimashita x <span class="ot">=</span> <span class="st">&quot;今、&quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot;って言いました！？&quot;</span></a>
<a class="sourceLine" id="cb3-2" title="2">ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> (iimashita <span class="st">&quot;ハスケル&quot;</span>)</a>
<a class="sourceLine" id="cb3-3" title="3">今、<span class="st">&quot;\12495\12473\12465\12523&quot;</span>って言いました！？</a></code></pre></div>
<p>すると、日本語の大半が変な文字列に変わってしまいました😥。</p>
<p>へ… 変な文字列じゃないし！エスケープシーケンスに変換しただけだから！</p>
<p>これは、<span class="ascii">Haskell</span>標準における<code>show</code>関数の残念な仕様です。<br />
<code>show</code>関数に文字列を渡すと、ダブルクォートで囲った上で、<span class="ascii">ASCII</span>範囲外の文字列や、<span class="ascii">ASCII</span>の非表示文字などをエスケープシーケンスに変換して返します。<br />
これは、<code>show</code>関数をデバッグで使用した際、指定した文字列にどんな文字が含まれているか、簡単にわかるようにするための仕様です。<br />
文字の文字コードを表示すれば、<span class="ascii">NULL</span>文字や制御文字、ゼロ幅文字、特殊なスペースなど、視認しにくいおかしな文字が含まれていても、一目でわかるのです。</p>
<p>しかしこれは日本語話者である我々にとって、少なくとも日本語の文字に関しては「余計なお世話」です。<br />
<span class="ascii">NULL</span>文字や<span class="ascii">ASCII</span>の制御文字といった本来画面に表示することがない文字列ならともかく、<span class="ascii">ASCII</span>範囲外の文字列すべてをエスケープしてしまうのはやり過ぎでしょう。<br />
現代は<span class="ascii">Unicode</span>があるおかげで、日本語に限らずとも<span class="ascii">ASCII</span>範囲外の文字を扱うのは当たり前になりましたから。</p>
<h1 id="unicode-showを使おう"><span class="link-to-here-outer"><a href="#unicode-showを使おう" title="unicode-showを使おう"><span class="link-to-here">Link to<br />
here</span></a></span>🌐<span class="ascii">unicode-show</span>を使おう</h1>
<p>そこで便利なのが<a href="http://hackage.haskell.org/package/unicode-show"><span class="ascii">unicode-show</span></a>です。<br />
<span class="ascii">unicode-show</span>の<code>ushow</code>関数は、<code>show</code>がエスケープシーケンスに変換した日本語などの文字列を、元の文字列に戻してくれます。<br />
なので、新しい型クラスを定義する必要もなく、そのまま<code>Show</code>型クラスのインスタンスを再利用できるのです。</p>
<p>早速先ほどの<code>show</code>を使った例に適用してみましょう。</p>
<p>まずは👇のコマンドでインストールして、<span class="ascii">GHCi</span>を起動します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">stack</span> build unicode-show</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ex">stack</span> exec ghci</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"># あるいは、最近のcabalを使っている場合は...</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="ex">cabal</span> v2-install --lib unicode-show</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="ex">cabal</span> v2-repl -b unicode-show</a></code></pre></div>
<p><code>Text.Show.Unicode</code>モジュールを<code>import</code>して<code>show</code>を使っている箇所を<code>ushow</code>に変えれば、お望みどおりの挙動になります。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Show.Unicode</span></a>
<a class="sourceLine" id="cb5-2" title="2">ghci<span class="op">&gt;</span> iimashita x <span class="ot">=</span> <span class="st">&quot;今、&quot;</span> <span class="op">++</span> ushow x <span class="op">++</span> <span class="st">&quot;って言いました！？&quot;</span></a>
<a class="sourceLine" id="cb5-3" title="3">ghci<span class="op">&gt;</span> <span class="fu">putStrLn</span> (iimashita <span class="st">&quot;ハスケル&quot;</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">今、<span class="st">&quot;ハスケル&quot;</span>って言いました！？</a></code></pre></div>
<p>わくわくもんですね！</p>
<p><code>print</code>の例も、<code>uprint</code>に変えれば🆗です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">ghci<span class="op">&gt;</span> uprint <span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="st">&quot;私、堪忍袋の緒が切れました！&quot;</span></a></code></pre></div>
<p>ウルトラハッピーですね！！</p>
<p>さらに、次のコマンドを<span class="ascii">GHCi</span>に入力すれば、<span class="ascii">GHCi</span>に直接入力した日本語文字列もそのまま表示されるようになります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span>interactive<span class="op">-</span><span class="fu">print</span><span class="ot">=</span>uprint</a>
<a class="sourceLine" id="cb7-2" title="2">ghci<span class="op">&gt;</span> <span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="st">&quot;みんなで幸せゲットだよ！&quot;</span></a></code></pre></div>
<p>カンペキ✨</p>
<p>えっ、常に<code>uprint</code>したいからいちいち<code>:set -interactive-print=uprint</code>するのが面倒くさい？<br />
そんなあなたは👇を<code>~/.ghci</code>に書くことけって～いでしょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Show.Unicode</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="op">:</span>set <span class="op">-</span>interactive<span class="op">-</span><span class="fu">print</span><span class="ot">=</span>Text.Show.Unicode.uprint</a></code></pre></div>
<h1 id="unicode-showの最近の修正"><span class="link-to-here-outer"><a href="#unicode-showの最近の修正" title="unicode-showの最近の修正"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">unicode-show</span>の最近の修正</h1>
<p>そんな<span class="ascii">unicode-show</span>ですが、残念ながら一昨年、作者である村主崇行さんが亡くなってしまいました<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。<br />
日本に住む<span class="ascii">Haskeller</span>をサポートする日本<span class="ascii">Haskell</span>ユーザーグループとしては、このパッケージをメンテナンスし続けることに大きな意義があると判断し、私はこのパッケージを<a href="https://github.com/haskell-jp/"><span class="ascii">Haskell-jp</span></a>の<span class="ascii">GitHub</span>リポジトリーでメンテナンスすることにしました。<br />
以下がそのリポジトリーです。</p>
<p><a href="https://github.com/haskell-jp/unicode-show" class="uri"><span class="ascii">https://github.com/haskell-jp/unicode-show</span></a></p>
<p>といっても、メンテナーの名前や<code>LICENSE</code>ファイルを書き換えて最新版をアップロードして以降特に何もしていなかったのですが<small>（<a href="https://github.com/nushio3/unicode-show/issues/2">バグはあるけど直すのも難しそう</a>だし、概ね使えるし）</small>、なんと先日、<span class="ascii">Pull request</span>が来ました！</p>
<p><a href="https://github.com/haskell-jp/unicode-show/pull/4"><span class="ascii">Do not show values eagerly by Kaiepi · Pull Request #4 · haskell-jp/unicode-show</span></a></p>
<p>この修正を適用する前の<span class="ascii">unicode-show</span>は、文字列全体を評価してからエスケープシーケンスを元に戻す、という挙動だったため、長い文字列を与えた場合や無限の長さの文字列を与えた場合に、なかなか<small>（あるいは永遠に）</small>結果が返ってこないという問題がありました。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">ghci<span class="op">&gt;</span> uprint (<span class="fu">repeat</span> <span class="st">&quot;ああああ！&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">-- 何も表示されず、Ctrl + C を押すまで処理が返らない</span></a></code></pre></div>
<p>修正後はちゃんと遅延評価を利用することで、無限の長さの文字列でも少しずつ変換することができます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">ghci<span class="op">&gt;</span> uprint (<span class="fu">repeat</span> <span class="st">&quot;ああああ！&quot;</span>)</a>
<a class="sourceLine" id="cb10-2" title="2">[<span class="st">&quot;ああああ！&quot;</span>,<span class="st">&quot;ああああ！&quot;</span>, <span class="op">...</span> <span class="st">&quot;ああああ！&quot;</span>,<span class="st">&quot;ああInterrupted.</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="st">-- Ctrl + Cを押すまで出力し続ける</span></a></code></pre></div>
<p>今日記事にした一番の理由はこの話をするためです。<br />
<a href="https://github.com/Kaiepi"><span class="ascii">Kaiepi</span></a>さんありがとうございます！<br />
先ほどリリースしました！🎉</p>
<p><a href="http://hackage.haskell.org/package/unicode-show-0.1.0.4" class="uri"><span class="ascii">http://hackage.haskell.org/package/unicode-show-0.1.0.4</span></a></p>
<h1 id="番外編pretty-simpleも使おう"><span class="link-to-here-outer"><a href="#番外編pretty-simpleも使おう" title="番外編pretty-simpleも使おう"><span class="link-to-here">Link to<br />
here</span></a></span>（番外編）<span class="ascii">pretty-simple</span>も使おう</h1>
<p>時間がないので詳しくは省略しますが、実は<a href="http://hackage.haskell.org/package/pretty-simple"><span class="ascii">pretty-simple</span></a>というパッケージを使えば、日本語をそのまま出力するのに加えて、プリティープリントできます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">ghci<span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Text.Pretty.Simple</span></a>
<a class="sourceLine" id="cb11-2" title="2">ghci<span class="op">&gt;</span> pPrint [<span class="st">&quot;きーらーめーくー♪&quot;</span>, <span class="st">&quot;ほーしーの力でー♪&quot;</span>, <span class="st">&quot;あこがーれのー♪&quot;</span>, <span class="st">&quot;わーたーし描くよー♪&quot;</span>]</a>
<a class="sourceLine" id="cb11-3" title="3">[ <span class="st">&quot;きーらーめーくー♪&quot;</span></a>
<a class="sourceLine" id="cb11-4" title="4">, <span class="st">&quot;ほーしーの力でー♪&quot;</span></a>
<a class="sourceLine" id="cb11-5" title="5">, <span class="st">&quot;あこがーれのー♪&quot;</span></a>
<a class="sourceLine" id="cb11-6" title="6">, <span class="st">&quot;わーたーし描くよー♪&quot;</span></a>
<a class="sourceLine" id="cb11-7" title="7">]</a></code></pre></div>
<p>例ではわかりづらいですが、ちゃんと色も着けてくれます！<br />
それでは<span class="ascii">2020</span>年も、<span class="ascii">Happy Haskell Hacking</span>🎁</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>例年どおりですとプリキュア<span class="ascii">Advent Calendar</span>と同時投稿をしている予定でしたが、例年参加者が減っていたこともあり、今年はプリキュア<span class="ascii">Advent Calendar</span>はなくなってしまいました😞<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>村主崇行さんは「<a href="https://shop.ohmsha.co.jp/shopdetail/000000001926/">すごい<span class="ascii">Haskell</span>たのしく学ぼう！</a>」の翻訳を担当されるなど、<span class="ascii">unicode-show</span>以外にも日本の<span class="ascii">Haskell</span>界に多大な功績をもたらした方でした。<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/regex-applicative.html" lang="ja">regex-applicative: 内部DSLとしての正規表現（ブログ記事版）</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-in-vrchat.html" style="margin-left: auto;" lang="ja">VRのためにHaskellを使った話</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>VRのためにHaskellを使った話</title>
    <link href="https://haskell.jp/blog/posts/2019/haskell-in-vrchat.html" />
    <id>https://haskell.jp/blog/posts/2019/haskell-in-vrchat.html</id>
    <published>2019-12-03T00:00:00Z</published>
    <updated>2019-12-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#はじめに" title="はじめに">はじめに</a></li>
<li><a href="#vr空間でltがしたい" title="vr空間でltがしたい"><span class="ascii">VR</span>空間で<span class="ascii">LT</span>がしたい</a></li>
<li><a href="#webフレームワーク" title="webフレームワーク"><span class="ascii">Web</span>フレームワーク</a></li>
<li><a href="#はじめてのhaskellペアプロ" title="はじめてのhaskellペアプロ">はじめての<span class="ascii">Haskell</span>ペアプロ</a></li>
<li><a href="#デプロイ" title="デプロイ">デプロイ</a></li>
<li><a href="#実際に開催してみて" title="実際に開催してみて">実際に開催してみて</a></li>
<li><a href="#リポジトリ" title="リポジトリ">リポジトリ</a></li>
</ul>
</div>
</div>
<h1 id="はじめに"><span class="link-to-here-outer"><a href="#はじめに" title="はじめに"><span class="link-to-here">Link to<br />
here</span></a></span>はじめに</h1>
<p>はじめまして。趣味で<span class="ascii">Haskell</span>しているはる<span class="ascii">(haru2036)</span>と申します。まったり進行で開発しているので<span class="ascii">GHC</span>のバージョンアップの速さについていけてない感があります…… さて、今回はあんまり深い話はありません。どちらかと言うとこんなニッチなところに<span class="ascii">Haskell</span>使ったよというネタで書きます。</p>
<h1 id="vr空間でltがしたい"><span class="link-to-here-outer"><a href="#vr空間でltがしたい" title="vr空間でltがしたい"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">VR</span>空間で<span class="ascii">LT</span>がしたい</h1>
<p>突然ですが、私は<a href="https://vrchat.com/"><span class="ascii">VRChat</span></a>（以下<span class="ascii">VRC</span>）というソーシャル<span class="ascii">VR</span>サービス（<span class="ascii">Second Life</span>の<span class="ascii">VR</span>版みたいなものです）にハマっています。<br />
友人との雑談の中で<span class="ascii">VRC</span>の中で<span class="ascii">LT</span>会ができればプログラミングなどの話題で盛り上がれる人が集まってワイワイ楽しくできるのではないかと話して、その場のノリでとりあえず実装してみることにしました。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-room.png" title="完成したワールド" alt="完成したワールド" /><figcaption>完成したワールド</figcaption>
</figure>
<p>今回作りたかったのはスライドを表示するためのスクリーンと、ページ送りに使うボタンを実装したワールドです。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-control-panel.png" title="発表者用コントロールパネル" alt="発表者用コントロールパネル" /><figcaption>発表者用コントロールパネル</figcaption>
</figure>
<p><span class="ascii">VRC</span>ではアバターやワールドを自由に作ることができるのですが、<span class="ascii">VRC</span>が提供するコンポーネント以外のスクリプトは利用できません。<span class="ascii">Haskell</span>ユーザとしては得意なことを活用しづらい土壌です。<br />
幸いスライドを表示する手段はゲーム内で<span class="ascii">URL</span>から画像を取得し表示する<span class="ascii">VRC_Panorama</span>というコンポーネントを利用することにより確保できましたが、<span class="ascii">VRC_Panorama</span>が取得できる画像はワールド作成時に決め打ちで指定された<span class="ascii">URL</span>のリストに含まれるもののみです。<br />
そのため、スライド画像への<span class="ascii">URL</span>のリストを直接<span class="ascii">VRC_Panorama</span>に渡していると、イベントを開催する際よくある飛び入り参加やスライドの用意が遅れた参加者に対応できなくなってしまいます。</p>
<p>その問題を解決するために、イベント開始時からのページ数とスライドの画像<span class="ascii">URL</span>をマップする<span class="ascii">WebAPI</span>を用意しました。<br />
具体的には、<code>/slides/{pageCount}</code> のような形のエンドポイントを持った<span class="ascii">API</span>を用意し、そこから実際の画像へリダイレクトをかけるという方法を取りました。</p>
<figure>
<img src="/img/2019/haskell-in-vrchat/vrc-lt-image.png" title="実装イメージ図" alt="実装イメージ図" /><figcaption>実装イメージ図</figcaption>
</figure>
<h1 id="webフレームワーク"><span class="link-to-here-outer"><a href="#webフレームワーク" title="webフレームワーク"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Web</span>フレームワーク</h1>
<p>今回は自分で使うだけだしということでさらっとやってみたかったので<span class="ascii">Spock</span>を利用しました。もう少し誰でも使えるサービスにしたいと考えているので<span class="ascii">Servant</span>に載せ替えてかっちり作り直そうかと思い移植しているところです。</p>
<h1 id="はじめてのhaskellペアプロ"><span class="link-to-here-outer"><a href="#はじめてのhaskellペアプロ" title="はじめてのhaskellペアプロ"><span class="link-to-here">Link to<br />
here</span></a></span>はじめての<span class="ascii">Haskell</span>ペアプロ</h1>
<p>じつは<span class="ascii">LT</span>会をやろうと思いついた友人の<a href="https://twitter.com/b0xp2"><span class="ascii">BOXP</span></a>は<span class="ascii">Clojure</span>ユーザで、せっかくだからと<span class="ascii">API</span>の開発を手伝ってくれました。<br />
あまり<span class="ascii">Haskell</span>に馴染みはなかったものの、いわゆる関数型プログラミング的な概念はバッチリなのでスススっと書いてくれました。<br />
書いてくれる上での障壁になったのは、型関連の要素<span class="ascii">(</span><code>data</code>や<code>type</code>や<code>newtype</code>がぱっと見わからなかった、型コンストラクタ、値コンストラクタの概念）に馴染みが薄かったことでした。<br />
<span class="ascii">Discord</span>で画面共有しながら説明を行ったのですが、やはり同じ画面を見ながら説明するのはとてもやりやすいと感じました。<br />
本人からのメッセージはこちら。</p>
<blockquote>
<p>プログラミング<span class="ascii">Haskell</span>を昔読んでかじったことがある程度で素人もいいところでしたが、当人のサポートもあり思いついた数日後には実装が終わっていました。 はるくんの話にもある通り<span class="ascii">Discord</span>で画面共有しながらペアプロし、<span class="ascii">Haskell</span>でのテストコードの書き方も一から教えてもらいながら書きました。これは願ってもない体験だったので根気よく教えてくれたことに非常に感謝しています。</p>
<p>また、個人的には実装以外でのブレストや実際の会場でのデバッグを<span class="ascii">VRChat</span>上でできた事もとてもよかったなと思っています。 単純に実装を確認するためには二人以上で<span class="ascii">VRChat</span>に入る必要があるというのもありましたが、完全リモートでも身振り手振りありでブレストができたことや、アバターのおかげで環境に囚われないコミュニケーションができていたことも<span class="ascii">Good</span>でした。</p>
</blockquote>
<h1 id="デプロイ"><span class="link-to-here-outer"><a href="#デプロイ" title="デプロイ"><span class="link-to-here">Link to<br />
here</span></a></span>デプロイ</h1>
<p>今回は自分で使うだけな上に常時稼働している必要もなく、コストを最小限に抑えたかったので<span class="ascii">Heroku</span>にデプロイしました。<br />
<span class="ascii">Dockerfile</span>を書き、スタティックリンク周りで悩みながらもイメージを生成して<span class="ascii">Heroku</span>のレジストリに<span class="ascii">Push</span>し、後はいつもの<span class="ascii">Heroku</span>という感じでうまくいきました。</p>
<p>余談ですが、最近参加した<span class="ascii">Gotanda.hs</span>というイベントで<code>cabal build --enable-executable-static</code>でいい感じにシングルバイナリが生成できるというお話を聞いたので、最近<span class="ascii">stack</span>ばっかり使ってたのを改めて適材適所で使い分けていきたいなーと思っています。</p>
<h1 id="実際に開催してみて"><span class="link-to-here-outer"><a href="#実際に開催してみて" title="実際に開催してみて"><span class="link-to-here">Link to<br />
here</span></a></span>実際に開催してみて</h1>
<p>ここは<span class="ascii">Haskell</span>ほぼ全く関係ないですが……</p>
<p><img src="/img/2019/haskell-in-vrchat/vrc-lt.png" /> <span class="ascii">VRC-LT</span>という名前で<span class="ascii">6</span>回ほど開催しているのですが、場所の制約を受けずに勉強会ができ、その後の懇親会も会場の撤収時刻や終電を気にせず話したい人はとことん話し続ける事ができるというところが非常に良かったです。<br />
ホワイトボードはまだ未実装ですが、空間に書けるペンも配布されているのでその手のアイテムも取り入れれば懇親会での話も更にはずむのではないでしょうか。</p>
<p><span class="ascii">VRChat</span>は<span class="ascii">PC</span>のみでも利用することができます。 <span class="ascii">VRC-LT</span>はほぼ月イチペースで不定期開催ですので、もしよろしければ参加していただけると嬉しいです。 開催時のアーカイブ等も以下の<span class="ascii">Web</span>サイトにて公開中です。合わせてご覧ください。 <a href="https://vrc-lt.github.io"><span class="ascii">https://vrc-lt.github.io</span></a></p>
<h1 id="リポジトリ"><span class="link-to-here-outer"><a href="#リポジトリ" title="リポジトリ"><span class="link-to-here">Link to<br />
here</span></a></span>リポジトリ</h1>
<p>そんなこんなで開発中のリポジトリはこちらになります。<br />
拙いところもいっぱいですが<span class="ascii">Issue</span>や<span class="ascii">PR</span>などで気になった点を教えていただければ幸いです！<br />
<a href="https://github.com/vrc-lt/VRC-Slide-Server"><span class="ascii">https://github.com/vrc-lt/VRC-Slide-Server</span></a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/unicode-show.html" lang="ja">日本語をshowしてうまく表示されなかったら</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-day-2019.html" style="margin-left: auto;" lang="ja">Haskell Day 2019を開催しました！</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Day 2019を開催しました！</title>
    <link href="https://haskell.jp/blog/posts/2019/haskell-day-2019.html" />
    <id>https://haskell.jp/blog/posts/2019/haskell-day-2019.html</id>
    <published>2019-11-29T00:00:00Z</published>
    <updated>2019-11-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>先日<span class="ascii">2019</span>年<span class="ascii">11</span>月<span class="ascii">9</span>日、<a href="https://techplay.jp/space"><span class="ascii">TECH PLAY SHIBUYA</span></a>にて<a href="https://techplay.jp/event/727059"><span class="ascii">Haskell Day 2019</span></a>を開催しました。<br />
今回は、各発表の概要や、アンケートの結果をお伝えしたいと思います。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#発表" title="発表">発表</a>
<ul>
<li><a href="#関数型function-typeを見つめるプログラミング" title="関数型function-typeを見つめるプログラミング">関数型<span class="ascii">(function type)</span>を見つめるプログラミング</a></li>
<li><a href="#hkdhigher-kinded-datatype" title="hkdhigher-kinded-datatype"><span class="ascii">HKD(Higher Kinded Datatype)</span></a></li>
<li><a href="#しんさんきぼうのderivingストラテジー" title="しんさんきぼうのderivingストラテジー">「しんさんきぼう」の<span class="ascii">Deriving</span>ストラテジー</a></li>
<li><a href="#haskellメタプログラミングによるegisonのパターンマッチの実装" title="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="ascii">Haskell</span>メタプログラミングによる<span class="ascii">Egison</span>のパターンマッチの実装</a></li>
<li><a href="#関数と型で理解する自動微分" title="関数と型で理解する自動微分">関数と型で理解する自動微分</a></li>
<li><a href="#ghcjs-によるwebフロントエンド開発" title="ghcjs-によるwebフロントエンド開発"><span class="ascii">GHCJS</span> による<span class="ascii">Web</span>フロントエンド開発</a></li>
<li><a href="#haskellで作る競技型イベントの裏側" title="haskellで作る競技型イベントの裏側"><span class="ascii">Haskell</span>で作る競技型イベントの裏側</a></li>
<li><a href="#大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation" title="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation">大規模数値計算を支える <span class="ascii">Haskell</span> ── <span class="ascii">Pragmatic Haskell in Large-Scale Numerical Computation</span>──</a></li>
<li><a href="#cadenza-building-fast-functional-languages-on-the-jvm" title="cadenza-building-fast-functional-languages-on-the-jvm"><span class="ascii">Cadenza: Building fast functional languages on the JVM</span></a></li>
<li><a href="#lt" title="lt"><span class="ascii">LT</span></a></li>
</ul></li>
<li><a href="#アンケート結果" title="アンケート結果">アンケート結果</a>
<ul>
<li><a href="#haskell-以外のプログラミングに関する質問" title="haskell-以外のプログラミングに関する質問"><span class="ascii">Haskell</span> 以外のプログラミングに関する質問</a>
<ul>
<li><a href="#エンジニアの経験年数はどれくらいですか" title="エンジニアの経験年数はどれくらいですか">エンジニアの経験年数はどれくらいですか？</a></li>
<li><a href="#得意なプログラミング言語はなんですか" title="得意なプログラミング言語はなんですか">得意なプログラミング言語はなんですか？</a></li>
<li><a href="#得意好きな技術領域はどれですか" title="得意好きな技術領域はどれですか">得意・好きな技術領域はどれですか？</a></li>
<li><a href="#最近注目している技術があれば記述してください" title="最近注目している技術があれば記述してください">最近注目している技術があれば記述してください</a></li>
</ul></li>
<li><a href="#haskell-に関する質問" title="haskell-に関する質問"><span class="ascii">Haskell</span> に関する質問</a>
<ul>
<li><a href="#haskell-をいつ頃始めましたか" title="haskell-をいつ頃始めましたか"><span class="ascii">Haskell</span> をいつ頃始めましたか？</a></li>
<li><a href="#haskell-を初めてどれくらい経ちますか" title="haskell-を初めてどれくらい経ちますか"><span class="ascii">Haskell</span> を初めてどれくらい経ちますか？</a></li>
<li><a href="#読んだことのある日本語の-haskell-本は" title="読んだことのある日本語の-haskell-本は">読んだことのある日本語の <span class="ascii">Haskell</span> 本は？</a></li>
</ul></li>
</ul></li>
<li><a href="#おわりに" title="おわりに">おわりに</a></li>
<li><a href="#あわせて読みたい" title="あわせて読みたい">あわせて読みたい</a></li>
</ul>
</div>
</div>
<h1 id="発表"><span class="link-to-here-outer"><a href="#発表" title="発表"><span class="link-to-here">Link to<br />
here</span></a></span>発表</h1>
<p>まずは各種発表の紹介から。</p>
<h2 id="関数型function-typeを見つめるプログラミング"><span class="link-to-here-outer"><a href="#関数型function-typeを見つめるプログラミング" title="関数型function-typeを見つめるプログラミング"><span class="link-to-here">Link to<br />
here</span></a></span>関数型<span class="ascii">(function type)</span>を見つめるプログラミング</h2>
<p>「関数型」 — すなわち<span class="ascii">Haskell</span>でいうところの<code>a -&gt; b</code>で表される、<span class="ascii">Haskell</span>の関数について、ちょっと見方を変えた新しい発見を教えてくれました。</p>
<p><a href="https://github.com/nobsun/hday2019/blob/master/doc/ftype.pdf">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/nobsun.jpg" /></p>
<h2 id="hkdhigher-kinded-datatype"><span class="link-to-here-outer"><a href="#hkdhigher-kinded-datatype" title="hkdhigher-kinded-datatype"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HKD(Higher Kinded Datatype)</span></h2>
<p><span class="ascii">Higher Kinded Datatype (HKD)</span>という、昨今<span class="ascii">Haskell</span>界で流行りの型定義方法を解説しています。<br />
レコード型を定義する際<span class="ascii">HKD</span>にすることで、より柔軟に扱うことができるようになります。<br />
さらに、<a href="http://hackage.haskell.org/package/barbies"><span class="ascii">barbies</span></a>や<a href="http://hackage.haskell.org/package/extensible"><span class="ascii">extensible</span></a>といった、<span class="ascii">HKD</span>の利用を飛躍的に促進するパッケージも紹介されました。</p>
<p><a href="https://assets.adobe.com/public/b93f214d-58c2-482f-5528-a939d3e83660">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/fumieval.jpg" /></p>
<h2 id="しんさんきぼうのderivingストラテジー"><span class="link-to-here-outer"><a href="#しんさんきぼうのderivingストラテジー" title="しんさんきぼうのderivingストラテジー"><span class="link-to-here">Link to<br />
here</span></a></span>「しんさんきぼう」の<span class="ascii">Deriving</span>ストラテジー</h2>
<p><span class="ascii">Haskell</span>の<code>deriving</code>機能 — 型を定義したとき、型クラスのインスタンスまで自動で定義してくれるあの機能ですね — の、適用範囲を広げる<span class="ascii">GHC</span>の言語拡張をいろいろ紹介してくれました。</p>
<p><a href="https://aiya000.github.io/Maid/haskell-day-2019-deriving/#/">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/aiya000.jpg" /></p>
<h2 id="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="link-to-here-outer"><a href="#haskellメタプログラミングによるegisonのパターンマッチの実装" title="haskellメタプログラミングによるegisonのパターンマッチの実装"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>メタプログラミングによる<span class="ascii">Egison</span>のパターンマッチの実装</h2>
<p>プログラミング言語<a href="https://www.egison.org/ja/"><span class="ascii">Egison</span></a>の核となる機能である強力なパターンマッチを、<span class="ascii">GHC</span>の各種拡張を駆使することで、<span class="ascii">Haskell</span>のソースコードに自然に埋め込めるような形で実装した、という話です。</p>
<p><a href="https://www.egison.org/download/20191109HaskellDay.pdf">資料はこちら</a></p>
<p><a href="https://github.com/egison/egison-haskell">紹介しているライブラリーのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/egison.jpg" /></p>
<h2 id="関数と型で理解する自動微分"><span class="link-to-here-outer"><a href="#関数と型で理解する自動微分" title="関数と型で理解する自動微分"><span class="link-to-here">Link to<br />
here</span></a></span>関数と型で理解する自動微分</h2>
<p>関数の自動微分を行うパッケージ<a href="http://hackage.haskell.org/package/ad"><span class="ascii">ad</span></a>の仕組みを自力で実装してみることで解説してくれました。</p>
<p><a href="https://speakerdeck.com/lotz84/guan-shu-toxing-deli-jie-suruzi-dong-wei-fen">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/lotz.jpg" /></p>
<h2 id="ghcjs-によるwebフロントエンド開発"><span class="link-to-here-outer"><a href="#ghcjs-によるwebフロントエンド開発" title="ghcjs-によるwebフロントエンド開発"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHCJS</span> による<span class="ascii">Web</span>フロントエンド開発</h2>
<p><a href="http://hackage.haskell.org/package/miso"><span class="ascii">miso</span></a>というおいしそうな名前のアプリケーションフレームワークと、<span class="ascii">Firebase</span>と連携する<span class="ascii">miso</span>のサンプルを、ライブコーディングを通して紹介してくれました。<br />
<span class="ascii">miso</span>を使えば、<span class="ascii">GHCJS</span>を使って<span class="ascii">Elm Architecture</span>風の設計に基づいてアプリケーションを作ったり、さらにそのコードを利用してサーバーサイドレンダリングをしたりできます。</p>
<p>ℹ️資料はまだ公開されていません！当日はライブコーディングが大半の時間を占めていたため、同等の解説を文章にして公開したいというチェシャ猫さんの意向によるものです。<br />
現在執筆中のためお待ちください。🙇</p>
<p><a href="https://github.com/y-taka-23/miso-firebase-tutorial">発表中に使用したソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/y_taka_23.jpg" /></p>
<h2 id="haskellで作る競技型イベントの裏側"><span class="link-to-here-outer"><a href="#haskellで作る競技型イベントの裏側" title="haskellで作る競技型イベントの裏側"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span>で作る競技型イベントの裏側</h2>
<p>「<span class="ascii">mixi git challenge</span>」というイベントにおいてユーザーが投稿した解答を採点するサーバーを、<span class="ascii">Haskell</span>と<span class="ascii">Elm</span>で一から書き直した、という事例を発表してくれました。<br />
<a href="http://hackage.haskell.org/package/rio"><span class="ascii">rio</span></a>や<a href="http://hackage.haskell.org/package/servant"><span class="ascii">servant</span></a>といった著名なパッケージを使うだけでなく、足りないところを自力で補って新しいパッケージとして公開したり、さらに作成したアプリケーション自体を<span class="ascii">OSS</span>として公開したりすることで、大きな資産を残していただけました。</p>
<p><a href="https://www.slideshare.net/noob00/haskell-191796924">資料はこちら</a></p>
<p><a href="https://github.com/matsubara0507/git-plantation">紹介しているアプリケーションのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/matsubara0507.jpg" /></p>
<h2 id="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation"><span class="link-to-here-outer"><a href="#大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation" title="大規模数値計算を支える-haskell-pragmatic-haskell-in-large-scale-numerical-computation"><span class="link-to-here">Link to<br />
here</span></a></span>大規模数値計算を支える <span class="ascii">Haskell</span> ── <span class="ascii">Pragmatic Haskell in Large-Scale Numerical Computation</span>──</h2>
<p><a href="https://www.deepflow.co.jp/"><span class="ascii">DeepFlow</span>株式会社</a>における<span class="ascii">Haskell</span>の事例の紹介です。<br />
超高速で大規模な数値計算システムを、<span class="ascii">GHC</span>の多様な言語拡張を駆使して作っているそうです。<br />
<span class="ascii">Tagless Final</span>を活用することで知っているべき領域を区分して仕事を分けることに成功しているという点が印象的でした。</p>
<p><a href="https://speakerdeck.com/konn/da-gui-mo-shu-zhi-ji-suan-wozhi-eru-haskell-nil-nil-pragmatic-haskell-in-large-scale-numerical-computation-nil-nil">資料はこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/mr_konn.jpg" /></p>
<h2 id="cadenza-building-fast-functional-languages-on-the-jvm"><span class="link-to-here-outer"><a href="#cadenza-building-fast-functional-languages-on-the-jvm" title="cadenza-building-fast-functional-languages-on-the-jvm"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Cadenza: Building fast functional languages on the JVM</span></h2>
<p><a href="https://ekmett.github.io/cadenza/cadenza/index.html"><span class="ascii">cadenza</span></a>という、<span class="ascii">Truffle</span>（<span class="ascii">GraalVM</span>に含まれている、高速なインタープリター作成フレームワーク）製の関数型言語の紹介です。<br />
<span class="ascii">Truffle</span>がもたらす強力な<span class="ascii">JIT</span>と「<span class="ascii">Normalization by Evaluation</span>」という技術を応用することで、型検査と実行時両方における高いスピードを得ることが狙いだそうです。 将来的には依存型言語における型チェックや、<span class="ascii">GHC</span>のランタイムの高速化に寄与したいとのことです。</p>
<p><a href="https://drive.google.com/file/d/1bwYO66xUKeHyR4YCNm_1C82JlDNQLUXv/view">資料はこちら</a></p>
<p><a href="https://github.com/ekmett/cadenza">紹介しているアプリケーションのソースコードはこちら</a></p>
<p><img src="/img/2019/haskell-day-2019/ekmett.jpg" /></p>
<h2 id="lt"><span class="link-to-here-outer"><a href="#lt" title="lt"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">LT</span></h2>
<p>今回は<span class="ascii">Hakell Day</span>史上初めての試みとして、<span class="ascii">Lightning Talk</span>を当日公募しました。<br />
残念ながら<span class="ascii">5</span>分間という短い制限時間に収められない発表が大半でしたので、ぜひ👇の資料を読んでみてください！</p>
<p><strong>順番が間違っていたら済みません！ご指摘を！</strong></p>
<ul>
<li><a href="https://docs.google.com/presentation/d/1TiDWz3zLUwEWgpzXfgVZFIib6JtYriB03TVgHsimJC0/edit#slide=id.gc6f73a04f_0_0"><span class="ascii">3D Model in Haskell - Haskell</span>で<span class="ascii">3D</span>モデルに触れる</a></li>
<li><a href="https://speakerdeck.com/cyclone_t/iot-cases-with-haskell"><span class="ascii">Haskell</span>で<span class="ascii">IoT</span>やってます</a></li>
<li><a href="https://www.slideshare.net/jabaraster/haskell-day-2019-lt-tomoyuki-kawano"><span class="ascii">Quora</span>で<span class="ascii">Haskell</span>への愛を語る</a></li>
<li><a href="https://gitpitch.com/coord-e/slide-type-class-impl"><span class="ascii">Haskell</span>で作ってわかる型クラス</a></li>
<li><a href="https://drive.google.com/file/d/1YGKjl8S-LlfuB8yrHnKSK5G5MGsP9xd3/view"><span class="ascii">Abstract Typeclasses - How To Design a Future-Proof Typeclass</span></a></li>
<li><a href="http://www.mew.org/~kazu/material/2019-gc.pdf"><span class="ascii">GHC</span>の<span class="ascii">GC</span></a></li>
</ul>
<h1 id="アンケート結果"><span class="link-to-here-outer"><a href="#アンケート結果" title="アンケート結果"><span class="link-to-here">Link to<br />
here</span></a></span>アンケート結果</h1>
<p><span class="ascii">Haskell Day</span> の各セッションや、参加者のバックグランドなどについてアンケートをとりました。 なので、後者の方の集計結果を載せたいと思います（前者はセッション発表者へのフィードバック）。</p>
<h2 id="haskell-以外のプログラミングに関する質問"><span class="link-to-here-outer"><a href="#haskell-以外のプログラミングに関する質問" title="haskell-以外のプログラミングに関する質問"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> 以外のプログラミングに関する質問</h2>
<p>大きく分けて <span class="ascii">Haskell</span> に関する質問とそうでない質問がありました。 まずは <span class="ascii">Haskell</span> 以外に関する質問の方を集計結果を紹介します。</p>
<h3 id="エンジニアの経験年数はどれくらいですか"><span class="link-to-here-outer"><a href="#エンジニアの経験年数はどれくらいですか" title="エンジニアの経験年数はどれくらいですか"><span class="link-to-here">Link to<br />
here</span></a></span>エンジニアの経験年数はどれくらいですか？</h3>
<p><img src="/img/2019/haskell-day-2019/question1.jpg" /></p>
<h3 id="得意なプログラミング言語はなんですか"><span class="link-to-here-outer"><a href="#得意なプログラミング言語はなんですか" title="得意なプログラミング言語はなんですか"><span class="link-to-here">Link to<br />
here</span></a></span>得意なプログラミング言語はなんですか？</h3>
<p>ちなみに、言語のリストは <a href="https://haskellweekly.news/survey/2019.html"><span class="ascii">Haskell Survey 2019</span></a> を参考にしました。</p>
<p><img src="/img/2019/haskell-day-2019/question2.jpg" /></p>
<h3 id="得意好きな技術領域はどれですか"><span class="link-to-here-outer"><a href="#得意好きな技術領域はどれですか" title="得意好きな技術領域はどれですか"><span class="link-to-here">Link to<br />
here</span></a></span>得意・好きな技術領域はどれですか？</h3>
<p><img src="/img/2019/haskell-day-2019/question3.jpg" /></p>
<h3 id="最近注目している技術があれば記述してください"><span class="link-to-here-outer"><a href="#最近注目している技術があれば記述してください" title="最近注目している技術があれば記述してください"><span class="link-to-here">Link to<br />
here</span></a></span>最近注目している技術があれば記述してください</h3>
<p>自由記述形式にしたところ、ほとんど重複が無かったので箇条書きにします。</p>
<ul>
<li><span class="ascii">FP</span></li>
<li>匿名暗号通貨<span class="ascii">(Monero,Zcash,Dash,Koto)</span></li>
<li><span class="ascii">Cardano ADA</span></li>
<li><span class="ascii">GraphQL</span></li>
<li><span class="ascii">extensible</span></li>
<li><span class="ascii">Enigma</span></li>
<li><span class="ascii">worker</span>ベースの非同期プログラミング</li>
<li>フロント界隈</li>
<li><span class="ascii">Next.js</span></li>
<li>自然言語処理</li>
<li>型レベルプログラミング</li>
<li>自動微分</li>
<li><span class="ascii">AWS</span>によるサーバーレスアーキテクチャでのフルスタック<span class="ascii">Web</span>アプリケーション開発</li>
<li><span class="ascii">Rust</span></li>
<li><span class="ascii">Kubernetes</span></li>
<li><span class="ascii">TLA+</span></li>
<li><span class="ascii">algebraic effects and handlers</span></li>
<li>深層学習コンパイラ</li>
<li><span class="ascii">AR</span></li>
<li>定理証明支援系</li>
</ul>
<h2 id="haskell-に関する質問"><span class="link-to-here-outer"><a href="#haskell-に関する質問" title="haskell-に関する質問"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> に関する質問</h2>
<p>ちなみに、<span class="ascii">Haskell</span> に関する質問は <span class="ascii">Haskell Day 2018</span> でもアンケートしました。</p>
<h3 id="haskell-をいつ頃始めましたか"><span class="link-to-here-outer"><a href="#haskell-をいつ頃始めましたか" title="haskell-をいつ頃始めましたか"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> をいつ頃始めましたか？</h3>
<p><img src="/img/2019/haskell-day-2019/question4.jpg" /></p>
<h3 id="haskell-を初めてどれくらい経ちますか"><span class="link-to-here-outer"><a href="#haskell-を初めてどれくらい経ちますか" title="haskell-を初めてどれくらい経ちますか"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell</span> を初めてどれくらい経ちますか？</h3>
<p><img src="/img/2019/haskell-day-2019/question5.jpg" /></p>
<h3 id="読んだことのある日本語の-haskell-本は"><span class="link-to-here-outer"><a href="#読んだことのある日本語の-haskell-本は" title="読んだことのある日本語の-haskell-本は"><span class="link-to-here">Link to<br />
here</span></a></span>読んだことのある日本語の <span class="ascii">Haskell</span> 本は？</h3>
<p>参照<span class="ascii">:</span> <a href="https://wiki.haskell.jp/Links#書籍" class="uri"><span class="ascii">https://wiki.haskell.jp/Links#</span>書籍</a></p>
<p><img src="/img/2019/haskell-day-2019/question6.jpg" /></p>
<h1 id="おわりに"><span class="link-to-here-outer"><a href="#おわりに" title="おわりに"><span class="link-to-here">Link to<br />
here</span></a></span>おわりに</h1>
<p>以上の発表に加えて今回は、下記のスポンサー企業の皆様や<span class="ascii">@fumieval</span>くんのおかげで、大変満足度の高い懇親会ができました。</p>
<ul>
<li><a href="https://www.mvrck.co.jp/">マーベリック株式会社</a></li>
<li><a href="https://herp.co.jp/">株式会社<span class="ascii">HERP</span></a></li>
<li><a href="https://www.iij.ad.jp/">株式会社インターネットイニシアティブ</a></li>
<li><a href="https://www.cryptact.com/">株式会社クリプタクト</a></li>
</ul>
<figure>
<img src="/img/2019/haskell-day-2019/after-party.jpg" alt="懇親会で振る舞われた料理" /><figcaption>懇親会で振る舞われた料理</figcaption>
</figure>
<p>発表について。<br />
昨年は「<a href="https://haskell-jp.connpass.com/event/92617/"><span class="ascii">Haskell</span>ちょっと興味あるからちょっとできるまで</a>」というテーマを意識して、発表の難易度別に時間帯が分かれるよう調整しましたが、残念ながらうまくいきませんでした。<br />
そこで難易度調整の難しさを痛感したため、今回は敢えて難易度調整を行わなかったのです。<br />
結果、全体として難しい発表に偏ってしまった点は少し反省です。<a href="https://eng-blog.iij.ad.jp/archives/3467">私が会社で開いている<span class="ascii">Haskell</span>勉強会</a>に毎回参加いただいている同僚も、総じて難しくて追いつくのが大変だった、と仰ってました。<br />
次回は特別に難易度を下げた発表枠をいくつか作り、内容を事前に精査する、なんてプランを考えています。</p>
<p>会場について。<br />
<span class="ascii">TECHPLAY SHIBUYA</span>は素晴らしいですね！<br />
我々のようなお金がないコミュニティーが今回の規模のイベントを行うのにうってつけでした。<br />
元々イベントを開催する前提で作られており、受付と演壇が近いため受付しながら発表を聞くことができるのも、持ち回りで受付をしている我々にとって好都合でした。<br />
来年も是非使わせていただきたいです🙏</p>
<p>最後に。<br />
発表者のみなさんはもちろん、支えていただいたスタッフ、スポンサー企業、会場まで足を運んでいただいた参加者の皆様、その他この会の実現に関わったすべての方々に、この場を借りて感謝の意を示したいと思います。<br />
みなさんのご協力おかげで、大きなトラブルもなく、楽しいイベントが開催できました。ありがとうございます。<br />
今後も日本<span class="ascii">Haskell</span>ユーザーグループ（<span class="ascii">a.k.a. Haskell-jp</span>）をよろしくお願いします！<br />
<span class="ascii">hask(_ _)eller</span></p>
<h1 id="あわせて読みたい"><span class="link-to-here-outer"><a href="#あわせて読みたい" title="あわせて読みたい"><span class="link-to-here">Link to<br />
here</span></a></span>あわせて読みたい</h1>
<ul>
<li>参加者による参加レポート<span class="ascii">:</span>
<ul>
<li><a href="http://hiratara.hatenadiary.jp/entry/2019/11/09/110030">今日は <span class="ascii">Haskell Day 2019</span> の日です <span class="ascii">-</span> 北海道苫小牧市出身の初老<span class="ascii">PG</span>が書くブログ</a></li>
<li><a href="https://www.ncaq.net/2019/11/09/20/56/00/"><span class="ascii">Haskell Day 2019</span>に参加しました <span class="ascii">- ncaq</span></a></li>
<li><a href="https://matsubara0507.github.io/posts/2019-11-10-join-haskell-day-2019"><span class="ascii">Haskell Day 2019</span> に参加してきた</a></li>
</ul></li>
<li><a href="https://haskell.jp/blog/posts/2018/haskell-day-2018.html">去年の開催レポート</a></li>
</ul>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/haskell-in-vrchat.html" lang="ja">VRのためにHaskellを使った話</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-copilot.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、Copilotという内部DSLについて</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、Copilotという内部DSLについて</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-copilot.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-copilot.html</id>
    <published>2019-10-01T00:00:00Z</published>
    <updated>2019-10-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-gibbon.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表を紹介します。<br />
今回は、<a href="https://copilot-language.github.io/"><span class="ascii">Copilot</span></a>という、<span class="ascii">C</span>言語のコードを生成する<span class="ascii">Haskell</span>製内部<span class="ascii">DSL</span>についての発表です。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#copilot-3.0-a-haskell-runtime-verification-framework-for-uavs" title="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="ascii">Copilot 3.0: a Haskell runtime verification framework for UAVs</span></a></li>
<li><a href="#copilotを試してみる" title="copilotを試してみる"><span class="ascii">Copilot</span>を試してみる</a></li>
</ul>
</div>
</div>
<h1 id="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="link-to-here-outer"><a href="#copilot-3.0-a-haskell-runtime-verification-framework-for-uavs" title="copilot-3.0-a-haskell-runtime-verification-framework-for-uavs"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Copilot 3.0: a Haskell runtime verification framework for UAVs</span></h1>
<p>発表者<span class="ascii">: Frank Dedden</span> <em><span class="ascii">Royal Netherlands Aerospace Center</span></em><span class="ascii">, Alwyn Goodloe</span> <em><span class="ascii">NASA Langley Research Center</span></em><span class="ascii">, Ivan Perez</span> <em><span class="ascii">NIA / NASA Formal Methods</span></em></p>
<p><span class="ascii">Haskell</span>製の内部<span class="ascii">DSL</span>から<span class="ascii">C</span>言語のソースコードを生成する、<a href="https://copilot-language.github.io/"><span class="ascii">Copilot</span></a>の紹介です。<br />
似た謳い文句の内部<span class="ascii">DSL</span>として<a href="http://hackage.haskell.org/package/ivory"><span class="ascii">ivory</span></a>がありますが、<span class="ascii">Copilot</span>は、ハードウェアの実行時検証を行う<span class="ascii">C</span>言語のコードを生成することに、より特化しています。<br />
「センサーから信号を受け取って、一定の条件を満たした場合に何らかの処理を実行する」という処理を<span class="ascii">Haskell</span>で宣言的に記述すると、メモリの消費量・実行時間において常に一定な<span class="ascii">C</span>言語のコードを生成することが出来ます。</p>
<p>メモリが限られていて、リアルタイムな処理が必要なハードウェアにとって「邪魔にならない監視」を実現するための必須条件なのでしょう。<br />
現状<span class="ascii">Haskell</span>は<span class="ascii">GC</span>が必要であるといった制約もあり、リアルタイムな処理や厳格なメモリー管理が必要な機器での採用は難しいですが、<span class="ascii">Ivory</span>や今回発表された<span class="ascii">Copilot</span>はあくまでも「<span class="ascii">C</span>言語のコードを生成するだけ」なので、生成する<span class="ascii">Haskell</span>ではメモリー管理をする必要がありません。<br />
にっくきスペースリークに悩まされる心配もないのです。<br />
こういった<span class="ascii">Haskell</span>製内部<span class="ascii">DSL</span>は、<span class="ascii">Haskell</span>の持つ強い型付けによるメリットを享受しながら、変換した言語の実行時におけるパフォーマンスを出しやすい、といういいとこ取りなメリットがあるので、もっと広まってほしいユースケースですね。</p>
<h1 id="copilotを試してみる"><span class="link-to-here-outer"><a href="#copilotを試してみる" title="copilotを試してみる"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Copilot</span>を試してみる</h1>
<ul>
<li>ℹ️ 実際に使用したコードは<a href="https://github.com/haskell-jp/blog/tree/master/examples/2019/hiw-copilot"><span class="ascii">Haskell-jp Blog</span>の<span class="ascii">GitHub</span>のリポジトリー</a>にあります。</li>
<li>ℹ️ 使用した<span class="ascii">copilot</span>パッケージのバージョンは、<span class="ascii">3.0.1</span>です。</li>
<li>ℹ️ サンプルコードの解説については、<span class="ascii">notogawa</span>さんのアドバイスも参考になりました<small>（<a href="https://haskell.jp/slack-log/html/C4M4TT8JJ/46.html#message-1554858057.072700"><span class="ascii">Haskell-jp</span>の<span class="ascii">slack-log</span>ではこのあたり</a>。執筆時点で<span class="ascii">CSS</span>が当たってないため読みづらいですが一応）</small>。ありがとうございます！</li>
</ul>
<p>せっかくなんで<span class="ascii">Copilot</span>を試してみましょう。<br />
公式サイトにあったサンプルコードそのまんまですが、生成される<span class="ascii">C</span>のコードを眺めてみます。</p>
<p>👇のコマンドでサンプルコードが入ったリポジトリーを<span class="ascii">git clone</span>した後、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">git</span> clone https://github.com/haskell-jp/blog</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">cd</span> blog/examples/2019/hiw-copilot</a></code></pre></div>
<p>👇のコマンドでビルド・<span class="ascii">C</span>言語によるコードの生成できるはずです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">stack</span> build copilot</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ex">stack</span> exec runghc heater.hs</a></code></pre></div>
<p>こちらが生成元の<span class="ascii">Haskell</span>のコードです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell:heater.hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span> <span class="dt">Language.Copilot</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span> <span class="dt">Copilot.Compile.C99</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((&gt;), (&lt;), div)</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">temp ::</span> <span class="dt">Stream</span> <span class="dt">Word8</span></a>
<a class="sourceLine" id="cb3-7" title="7">temp <span class="ot">=</span> extern <span class="st">&quot;temperature&quot;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="ot">ctemp ::</span> <span class="dt">Stream</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="cb3-10" title="10">ctemp <span class="ot">=</span> (unsafeCast temp) <span class="op">*</span> (<span class="fl">150.0</span> <span class="op">/</span> <span class="fl">255.0</span>) <span class="op">-</span> <span class="fl">50.0</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">spec <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-13" title="13">  trigger <span class="st">&quot;heaton&quot;</span>  (ctemp <span class="op">&lt;</span> <span class="fl">18.0</span>) [arg ctemp]</a>
<a class="sourceLine" id="cb3-14" title="14">  trigger <span class="st">&quot;heatoff&quot;</span> (ctemp <span class="op">&gt;</span> <span class="fl">21.0</span>) [arg ctemp]</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16">main <span class="ot">=</span> reify spec <span class="op">&gt;&gt;=</span> compile <span class="st">&quot;heater&quot;</span></a></code></pre></div>
<p>まず、<code>temp</code>と<code>ctemp</code>という識別子に定義した式が、センサーが発信する、連続的に変化する値を表しています。<br />
<span class="ascii">Copilot</span>の言葉はこれを<code>Stream</code>と呼んでいます。</p>
<p><code>spec</code>という識別子で定義している式が、「どのセンサーから信号を受け取って、どんな条件を満たした場合にどの処理を実行するか」規定しているようです。<br />
👆の場合、<code>ctemp</code>という<code>Stream</code>が<code>18.0</code>を下回ったら<code>heaton</code>というイベントを発火し、<code>21.0</code>を超えたら<code>heatoff</code>というイベントを発火する、と定めているわけですね。<br />
そして<code>main</code>関数で実行している<code>reify spec &gt;&gt;= compile "heater"</code>という箇所で、<code>.h</code>ファイルと<code>.c</code>ファイルを書き込んでいます。</p>
<p>そして、生成されたヘッダーファイル<code>heater.h</code>がこう👇</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c:heater.h"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">extern</span> <span class="dt">uint8_t</span> temperature;</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="dt">void</span> heatoff(<span class="dt">float</span> heatoff_arg0);</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="dt">void</span> heaton(<span class="dt">float</span> heaton_arg0);</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="dt">void</span> step(<span class="dt">void</span>);</a></code></pre></div>
<p>で、肝心の<span class="ascii">C</span>のコード本体<code>heater.c</code>がこちらです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c:heater.c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="pp">#include </span><span class="im">&quot;heater.h&quot;</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="dt">static</span> <span class="dt">uint8_t</span> temperature_cpy;</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="dt">bool</span> heatoff_guard(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="cf">return</span> ((((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>)) &gt; (<span class="fl">21.0</span>);</a>
<a class="sourceLine" id="cb5-11" title="11">}</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="dt">float</span> heatoff_arg0(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="cf">return</span> (((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>);</a>
<a class="sourceLine" id="cb5-15" title="15">}</a>
<a class="sourceLine" id="cb5-16" title="16"></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="dt">bool</span> heaton_guard(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-18" title="18">  <span class="cf">return</span> ((((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>)) &lt; (<span class="fl">18.0</span>);</a>
<a class="sourceLine" id="cb5-19" title="19">}</a>
<a class="sourceLine" id="cb5-20" title="20"></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="dt">float</span> heaton_arg0(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-22" title="22">  <span class="cf">return</span> (((<span class="dt">float</span>)(temperature_cpy)) * ((<span class="fl">150.0</span>) / (<span class="fl">255.0</span>))) - (<span class="fl">50.0</span>);</a>
<a class="sourceLine" id="cb5-23" title="23">}</a>
<a class="sourceLine" id="cb5-24" title="24"></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="dt">void</span> step(<span class="dt">void</span>) {</a>
<a class="sourceLine" id="cb5-26" title="26">  (temperature_cpy) = (temperature);</a>
<a class="sourceLine" id="cb5-27" title="27">  <span class="cf">if</span> ((heatoff_guard)()) {</a>
<a class="sourceLine" id="cb5-28" title="28">    (heatoff)(((heatoff_arg0)()));</a>
<a class="sourceLine" id="cb5-29" title="29">  };</a>
<a class="sourceLine" id="cb5-30" title="30">  <span class="cf">if</span> ((heaton_guard)()) {</a>
<a class="sourceLine" id="cb5-31" title="31">    (heaton)(((heaton_arg0)()));</a>
<a class="sourceLine" id="cb5-32" title="32">  };</a>
<a class="sourceLine" id="cb5-33" title="33">}</a></code></pre></div>
<p>先ほど<code>Stream</code>として定義した値のうち、<code>temp</code>は、<code>temperature</code>というグローバル変数と、それを一時的に保存する<code>temperature_cpy</code>という二つの変数に翻訳されました。<br />
<code>spec</code>において<code>trigger</code>という関数で列挙した「どのセンサーから信号を受け取って、どんな条件を満たした場合にどの処理を実行するか」というルールは、<code>step</code>という関数に現れたようです。<br />
この関数を利用する側では、<code>heaton</code>関数と<code>heatoff</code>関数を別途定義した上で、<code>temperature</code>にセンサーから受け取った値を代入して<code>step</code>を呼ぶことによって、<code>temperature</code>の値が条件に一致したとき、<code>heaton</code>関数と<code>heatoff</code>関数を実行してハードウェアの制御ができるのでしょう。<br />
<span class="ascii">Haskell</span>側で定義したもう一つの<code>Stream</code>、<code>ctemp</code>は、<code>heaton_guard</code>、<code>heaton_arg0</code>、<code>heatoff_guard</code>、<code>heatoff_arg0</code>、それぞれの関数に書かれた、<code>temperature_cpy</code>の値を変換する式に現れているようです。</p>
<p>正直なところこの程度であれば、直接<span class="ascii">C</span>で書いた方が余計なカッコもないし読みやすそうではあります。<br />
<code>temp</code>を<code>ctemp</code>に変換する式<code>(150.0 / 255.0) - 50.0</code>が変換後のソースコードでは冗長に適用されていることから、もっと最適化できそうですし。<br />
とはいえ、わざわざ<span class="ascii">DSL</span>を作ったからには、より複雑で、<span class="ascii">Haskell</span>でなければ書いてられないようなケースが、<span class="ascii">Copilot</span>の開発者の現場ではあるのでしょう<small>（なんせ<span class="ascii">NASA</span>の方も関わっているぐらいですから！）</small>。<br />
詳しいユースケースや、ビルド時のフローといった運用方法を聞きたいところですね。</p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/haskell-day-2019.html" lang="ja">Haskell Day 2019を開催しました！</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/haskell-symposium.html" style="margin-left: auto;" lang="ja">Haskell Symposium 2019 レポート</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>Haskell Symposium 2019 レポート</title>
    <link href="https://haskell.jp/blog/posts/2019/haskell-symposium.html" />
    <id>https://haskell.jp/blog/posts/2019/haskell-symposium.html</id>
    <published>2019-10-01T00:00:00Z</published>
    <updated>2019-10-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p><a href="https://icfp19.sigplan.org/home/haskellsymp-2019"><span class="ascii">Haskell Symposium 2019</span></a>に<span class="ascii">IIJ</span>として参加してきました。</p>
<p>聴講した発表についての概要をまとめましたので、どの論文を読んでみるか決めるなどの際にご活用ください。内容については私の聞きまちがい・読みまちがいなどあると思いますのでご了承ください。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#haskell-symposiumとは" title="haskell-symposiumとは"><span class="ascii">Haskell Symposium</span>とは</a></li>
<li><a href="#bidirectional-type-class-instances" title="bidirectional-type-class-instances"><span class="ascii">Bidirectional Type Class Instances</span></a></li>
<li><a href="#generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances" title="generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances"><span class="ascii">Generic and Flexible Defaults for Verified, Law-Abiding Type-Class Instances</span></a></li>
<li><a href="#modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study" title="modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study"><span class="ascii">Modular effects in Haskell through effect polymorphism and explicit dictionary applications - A new approach and the</span> μ<span class="ascii">VeriFast verifier as a case study</span></a></li>
<li><a href="#verifying-effectful-haskell-programs-in-coq" title="verifying-effectful-haskell-programs-in-coq"><span class="ascii">Verifying Effectful Haskell Programs in Coq</span></a></li>
<li><a href="#solving-haskell-equality-constraints-using-coq" title="solving-haskell-equality-constraints-using-coq"><span class="ascii">Solving Haskell equality constraints using Coq</span></a></li>
<li><a href="#formal-verification-of-spacecraft-control-programs-an-experience-report" title="formal-verification-of-spacecraft-control-programs-an-experience-report"><span class="ascii">Formal Verification of Spacecraft Control Programs: An Experience Report</span></a></li>
<li><a href="#g2q-haskell-constraint-solving" title="g2q-haskell-constraint-solving"><span class="ascii">G2Q: Haskell Constraint Solving</span></a></li>
<li><a href="#making-a-faster-curry-with-extensional-types" title="making-a-faster-curry-with-extensional-types"><span class="ascii">Making a Faster Curry with Extensional Types</span></a></li>
<li><a href="#multi-stage-programs-in-context" title="multi-stage-programs-in-context"><span class="ascii">Multi-Stage Programs in Context</span></a></li>
<li><a href="#working-with-source-plugins" title="working-with-source-plugins"><span class="ascii">Working with Source Plugins</span></a></li>
<li><a href="#stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism" title="stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism"><span class="ascii">STCLang: State Thread Composition as a Foundation for Monadic Dataflow Parallelism</span></a></li>
<li><a href="#synthesizing-functional-reactive-programs" title="synthesizing-functional-reactive-programs"><span class="ascii">Synthesizing Functional Reactive Programs</span></a></li>
<li><a href="#the-essence-of-live-coding-change-the-program-keep-the-state" title="the-essence-of-live-coding-change-the-program-keep-the-state"><span class="ascii">The essence of live coding: Change the program, keep the state!</span></a></li>
<li><a href="#monad-transformers-and-modular-algebraic-effects-what-binds-them-together" title="monad-transformers-and-modular-algebraic-effects-what-binds-them-together"><span class="ascii">Monad Transformers and Modular Algebraic Effects: What Binds Them Together</span></a></li>
<li><a href="#scoping-monadic-relational-database-queries" title="scoping-monadic-relational-database-queries"><span class="ascii">Scoping Monadic Relational Database Queries</span></a></li>
</ul>
</div>
</div>
<h1 id="haskell-symposiumとは"><span class="link-to-here-outer"><a href="#haskell-symposiumとは" title="haskell-symposiumとは"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Haskell Symposium</span>とは</h1>
<p><a href="https://icfp19.sigplan.org/"><span class="ascii">International Conference on Functional Programming</span></a>（<span class="ascii">ICFP</span>）に合わせて開催される<span class="ascii">Haskell</span>に関する国際会議です。<span class="ascii">Haskell</span>に関する研究を発表したり、実践的な経験や将来の言語の開発について議論したり、その他の宣言的プログラミングを促進したりします。</p>
<h1 id="bidirectional-type-class-instances"><span class="link-to-here-outer"><a href="#bidirectional-type-class-instances" title="bidirectional-type-class-instances"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Bidirectional Type Class Instances</span></h1>
<ul>
<li>著者：<span class="ascii">Koen Pauwels (KU Leuven), Georgios Karachalias (KU Leuven), Michiel Derhaeg (Guardsquare), Tom Schrijvers (KU Leuven)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/8/Bidirectional-Type-Class-Instances" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/8/Bidirectional-Type-Class-Instances</span></a></li>
<li>論文：<a href="https://arxiv.org/abs/1906.12242" class="uri"><span class="ascii">https://arxiv.org/abs/1906.12242</span></a></li>
</ul>
<p><span class="ascii">GADT</span>と型クラスはそれぞれ便利だが混ぜると問題が起きる場合がある。</p>
<p>次のような<code>Term</code>があるとき、その<code>Show</code>インスタンスを考える。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Term</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">Con</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">Tup</span><span class="ot"> ::</span> <span class="dt">Term</span> b <span class="ot">-&gt;</span> <span class="dt">Term</span> c <span class="ot">-&gt;</span> <span class="dt">Term</span> (b, c)</a></code></pre></div>
<p>次のように<code>Show</code>インスタンスを定義すると型エラーになる。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Term</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="fu">show</span> (<span class="dt">Con</span> a) <span class="ot">=</span> <span class="fu">show</span> a</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="fu">show</span> (<span class="dt">Tup</span> x y) <span class="ot">=</span> <span class="fu">unwords</span> [<span class="st">&quot;(&quot;</span>, <span class="fu">show</span> x, <span class="st">&quot;,&quot;</span>, <span class="fu">show</span> y, <span class="st">&quot;)&quot;</span>]</a></code></pre></div>
<pre><code>Could not deduce (Show b) arising from a use of `show&#39;
from the context (Show a) or from (a ~ (b, c))</code></pre>
<p>これは<code>Show (b, c)</code>ならば<code>Show b</code>という関係がないために起こる。</p>
<p>一方タプルについての<code>Show</code>は、<code>Show a</code>かつ<code>Show b</code>ならば<code>Show (a, b)</code>という関係である。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">Show</span> (a, b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  …</a></code></pre></div>
<p>この「ならば」を両方向にすれば問題は解決できるのではないかというのが、この論文の主張である。</p>
<h1 id="generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances"><span class="link-to-here-outer"><a href="#generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances" title="generic-and-flexible-defaults-for-verified-law-abiding-type-class-instances"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Generic and Flexible Defaults for Verified, Law-Abiding Type-Class Instances</span></h1>
<ul>
<li>著者：<span class="ascii">Ryan Scott (Indiana University), Ryan R. Newton (Indiana University)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/3/Generic-and-Flexible-Defaults-for-Verified-Law-Abiding-Type-Class-Instances" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/3/Generic-and-Flexible-Defaults-for-Verified-Law-Abiding-Type-Class-Instances</span></a></li>
<li>論文：<a href="https://ryanglscott.github.io/papers/verified-classes.pdf" class="uri"><span class="ascii">https://ryanglscott.github.io/papers/verified-classes.pdf</span></a></li>
</ul>
<p>型クラスの法則は依存型を使えば証明できるが、インスタンスごとに書くのはめんどうなので<code>Generics</code>で出来るようにしようという話である。</p>
<h1 id="modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study"><span class="link-to-here-outer"><a href="#modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study" title="modular-effects-in-haskell-through-effect-polymorphism-and-explicit-dictionary-applications---a-new-approach-and-the-μverifast-verifier-as-a-case-study"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Modular effects in Haskell through effect polymorphism and explicit dictionary applications - A new approach and the</span> μ<span class="ascii">VeriFast verifier as a case study</span></h1>
<ul>
<li>著者：<span class="ascii">Dominique Devriese (Vrije Universiteit Brussel)</span></li>
<li>概要・論文：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/1/Modular-effects-in-Haskell-through-effect-polymorphism-and-explicit-dictionary-applic" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/1/Modular-effects-in-Haskell-through-effect-polymorphism-and-explicit-dictionary-applic</span></a></li>
</ul>
<p>様々な種類の効果が複雑に絡み合うアプリケーションを整理するために、「効果を伴う処理を持った辞書」を明示的に渡す方式の提案である。</p>
<p>提案した方式によって<span class="ascii">VeriFast</span>を再実装してみることで、実際に発生した問題と解決方法を解説している。</p>
<h1 id="verifying-effectful-haskell-programs-in-coq"><span class="link-to-here-outer"><a href="#verifying-effectful-haskell-programs-in-coq" title="verifying-effectful-haskell-programs-in-coq"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Verifying Effectful Haskell Programs in Coq</span></h1>
<ul>
<li>著者：<span class="ascii">Jan Christiansen (Flensburg University of Applied Sciences), Sandra Dylus (University of Kiel), Niels Bunkenburg (University of Kiel)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/4/Verifying-Effectful-Haskell-Programs-in-Coq" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/4/Verifying-Effectful-Haskell-Programs-in-Coq</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342592" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342592</span></a></li>
</ul>
<p><span class="ascii">Coq</span>による、効果を伴うプログラムの証明に関する話。</p>
<p>効果について直接証明することはせず、<span class="ascii">Free</span>モナドを用いての証明を試みても、そのまま<span class="ascii">Coq</span>に翻訳すると停止性チェックによってエラーになってしまう。</p>
<p>そのために行った工夫に加え、具体例として、<code>trace</code>や（部分関数による）エラーなど、<span class="ascii">Haskell</span>において暗黙に発生する効果を考慮したモデル化について検討した。</p>
<h1 id="solving-haskell-equality-constraints-using-coq"><span class="link-to-here-outer"><a href="#solving-haskell-equality-constraints-using-coq" title="solving-haskell-equality-constraints-using-coq"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Solving Haskell equality constraints using Coq</span></h1>
<ul>
<li>著者：<span class="ascii">Zubin Duggal</span></li>
<li>概要・論文：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/15/Solving-Haskell-equality-constraints-using-Coq" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/15/Solving-Haskell-equality-constraints-using-Coq</span></a></li>
</ul>
<p><span class="ascii">data kinds</span>や<span class="ascii">type families</span>といった<span class="ascii">GHC</span>拡張によって厳格なデータ型を定義できるが、それに対する操作を定義すると<span class="ascii">GHC</span>には解けない型レベルの等式が生成されることがある。</p>
<p>制約カインドの型に対する型クラスとして<code>Proven</code>を提供し、この制約がある箇所を<span class="ascii">GHC</span>型検査プラグインが検出して対応する<span class="ascii">Coq</span>コードのテンプレートを生成する。</p>
<p>その<span class="ascii">Coq</span>コードに証明がなければ警告を表示する。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">type</span> <span class="dt">ProofName</span> <span class="ot">=</span> <span class="dt">Symbol</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">class</span> c <span class="ot">=&gt;</span> <span class="dt">Proven</span> (<span class="ot">prf ::</span> <span class="dt">ProofName</span>) (<span class="ot">c ::</span> <span class="dt">Constraint</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="kw">where</span> {}</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="ot">applyProof ::</span> <span class="kw">forall</span> prf c a<span class="op">.</span> <span class="dt">Proven</span> prf c <span class="ot">=&gt;</span> (c <span class="ot">=&gt;</span> a) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb5-7" title="7">applyProof x <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9">lemma3 <span class="ot">=</span> applyProof <span class="op">@</span><span class="st">&quot;nonzero_pop&quot;</span> <span class="op">@</span>(<span class="dt">NNonZero</span> (<span class="dt">Popcount</span> b) <span class="op">~</span> <span class="dt">True</span>) <span class="dt">Refl</span></a></code></pre></div>
<p>いくつか制約があるが<span class="ascii">Haskell</span>の型を<span class="ascii">Coq</span>に自動的に変換している。</p>
<h1 id="formal-verification-of-spacecraft-control-programs-an-experience-report"><span class="link-to-here-outer"><a href="#formal-verification-of-spacecraft-control-programs-an-experience-report" title="formal-verification-of-spacecraft-control-programs-an-experience-report"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Formal Verification of Spacecraft Control Programs: An Experience Report</span></h1>
<ul>
<li>著者：<span class="ascii">Andrey Mokhov (Newcastle University), Georgy Lukyanov (Newcastle University), Jakob Lechner (RUAG Space Austria GmbH)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/5/Formal-Verification-of-Spacecraft-Control-Programs-An-Experience-Report" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/5/Formal-Verification-of-Spacecraft-Control-Programs-An-Experience-Report</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342593" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342593</span></a></li>
</ul>
<p><span class="ascii">REDFIN</span>という固定小数演算と整数演算のための処理系があるのだが、そのアセンブリーコードに対して形式検証をしたという報告である。</p>
<h1 id="g2q-haskell-constraint-solving"><span class="link-to-here-outer"><a href="#g2q-haskell-constraint-solving" title="g2q-haskell-constraint-solving"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">G2Q: Haskell Constraint Solving</span></h1>
<ul>
<li>著者：<span class="ascii">William T. Hallahan (Yale University), Anton Xue (Yale University), Ruzica Piskac (Yale University)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/2/G2Q-Haskell-Constraint-Solving" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/2/G2Q-Haskell-Constraint-Solving</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342590" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342590</span></a></li>
</ul>
<p><span class="ascii">G2Q</span>は<span class="ascii">Haskell</span>のソースに<span class="ascii">quasi quote</span>で埋め込む<span class="ascii">DSL</span>である。</p>
<p><span class="ascii">Haskell</span>で書いた条件式を<span class="ascii">symbolic execution</span>して、<span class="ascii">SMT solver</span>に渡す式に変換して、<span class="ascii">SMT solver</span>に条件を満たす関数を導出させる。</p>
<h1 id="making-a-faster-curry-with-extensional-types"><span class="link-to-here-outer"><a href="#making-a-faster-curry-with-extensional-types" title="making-a-faster-curry-with-extensional-types"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Making a Faster Curry with Extensional Types</span></h1>
<ul>
<li>著者：<span class="ascii">Paul Downen (University of Oregon), Zachary Sullivan, Zena M. Ariola (University of Oregon), Simon Peyton Jones (Microsoft)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/6/Making-a-Faster-Curry-with-Extensional-Types" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/6/Making-a-Faster-Curry-with-Extensional-Types</span></a></li>
<li>論文：<a href="https://ix.cs.uoregon.edu/~pdownen/publications/eta.pdf" class="uri"><span class="ascii">https://ix.cs.uoregon.edu/~pdownen/publications/eta.pdf</span></a></li>
</ul>
<p>パフォーマンスのためにη変換してほしいところを明示したいことがある。</p>
<p>例えば、次のような意味論上は等価な関数<code>f1</code>と<code>f2</code>があるとする。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">f1 <span class="ot">=</span> \x <span class="ot">-&gt;</span> <span class="kw">let</span> z <span class="ot">=</span> h x x <span class="kw">in</span> \y <span class="ot">-&gt;</span> e y z</a>
<a class="sourceLine" id="cb6-2" title="2">f2 <span class="ot">=</span> \x <span class="ot">-&gt;</span> \y <span class="ot">-&gt;</span> <span class="kw">let</span> z <span class="ot">=</span> h x x <span class="kw">in</span> e y z</a></code></pre></div>
<p>実際は<code>f1</code>は引数<code>x</code>を取った後クロージャー生成のためにヒープ確保するのに対して、<code>f2</code>はアリティが<span class="ascii">2</span>の関数と解釈されて中間のクロージャーが必要なくなる。</p>
<p><code>~&gt;</code>というアリティの情報を持った関数型を新たに導入して<code>-&gt;</code>の代わりに使えるようにする。</p>
<p><code>TYPE (a :: RuntimeRep (FunRep 2))</code>というような新たなポリモーフィズムを導入する。ここでの<code>2</code>がアリティ。</p>
<p><code>Int</code>に対して<code>Int#</code>があるように基本的にはパフォーマンスが必要なライブラリーなど内部的に使用する想定。</p>
<h1 id="multi-stage-programs-in-context"><span class="link-to-here-outer"><a href="#multi-stage-programs-in-context" title="multi-stage-programs-in-context"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Multi-Stage Programs in Context</span></h1>
<ul>
<li>著者：<span class="ascii">Matthew Pickering (University of Bristol), Nicolas Wu (Imperial College London), Csongor Kiss (Imperial College London)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/9/Multi-Stage-Programs-in-Context" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/9/Multi-Stage-Programs-in-Context</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342597" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342597</span></a></li>
</ul>
<p>次のような準引用があったときに、組み合わせると元々あったはずの情報が欠落する場合がある。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">qshow ::</span> <span class="dt">Code</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb7-2" title="2">qshow <span class="ot">=</span> [q| show |]</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">qread ::</span> <span class="dt">Code</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-5" title="5">qread <span class="ot">=</span> [q| read |]</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="ot">trim ::</span> <span class="dt">Code</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb7-8" title="8">trim <span class="ot">=</span> [q| $(qshow) . $(qread) |]</a></code></pre></div>
<p><code>qshow</code>と<code>qread</code>にあった<code>Int</code>という情報が、組み合わせて<code>trim</code>とすると欠落してコンパイルエラーになってしまう。</p>
<p><span class="ascii">splice</span>するときに<span class="ascii">Haskell</span>ソースコードの構文木ではなく<span class="ascii">Core</span>に対するものを出力すればそれは型が明示されているし問題がない。</p>
<p>しかも、<span class="ascii">splice</span>後の型検査を省略できるのでコンパイルの高速化にも寄与する。</p>
<h1 id="working-with-source-plugins"><span class="link-to-here-outer"><a href="#working-with-source-plugins" title="working-with-source-plugins"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Working with Source Plugins</span></h1>
<ul>
<li>著者：<span class="ascii">Matthew Pickering (University of Bristol), Nicolas Wu (Imperial College London), Boldizsár Németh (Eötvös Loránd University)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/11/Working-with-Source-Plugins" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/11/Working-with-Source-Plugins</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342599" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342599</span></a></li>
</ul>
<p><span class="ascii">souce plugins</span>のしくみや、書き方、実装時のテクニックの紹介である。</p>
<h1 id="stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism"><span class="link-to-here-outer"><a href="#stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism" title="stclang-state-thread-composition-as-a-foundation-for-monadic-dataflow-parallelism"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">STCLang: State Thread Composition as a Foundation for Monadic Dataflow Parallelism</span></h1>
<ul>
<li>著者：<span class="ascii">Sebastian Ertel, Justus Adam (Technische Universität Dresden), Norman A. Rink (TU Dresden), Andrés Goens, Jeronimo Castrillon (TU Dresden)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/12/STCLang-State-Thread-Composition-as-a-Foundation-for-Monadic-Dataflow-Parallelism" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/12/STCLang-State-Thread-Composition-as-a-Foundation-for-Monadic-Dataflow-Parallelism</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342600" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342600</span></a></li>
</ul>
<p>同じ時刻の<span class="ascii">HIW</span>の発表を聴講していたためこちらは聴講していません。</p>
<h1 id="synthesizing-functional-reactive-programs"><span class="link-to-here-outer"><a href="#synthesizing-functional-reactive-programs" title="synthesizing-functional-reactive-programs"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Synthesizing Functional Reactive Programs</span></h1>
<ul>
<li>著者：<span class="ascii">Bernd Finkbeiner, Felix Klein (Saarland University), Ruzica Piskac (Yale University, Mark Santolucito (Yale University)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/13/Synthesizing-Functional-Reactive-Programs" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/13/Synthesizing-Functional-Reactive-Programs</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342601" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342601</span></a></li>
</ul>
<p>同じ時刻の<span class="ascii">HIW</span>の発表を聴講していたためこちらは聴講していません。</p>
<h1 id="the-essence-of-live-coding-change-the-program-keep-the-state"><span class="link-to-here-outer"><a href="#the-essence-of-live-coding-change-the-program-keep-the-state" title="the-essence-of-live-coding-change-the-program-keep-the-state"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">The essence of live coding: Change the program, keep the state!</span></h1>
<ul>
<li>著者：<span class="ascii">Manuel Bärenz (sonnen eServices GmbH)</span></li>
<li>概要・論文：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/14/The-essence-of-live-coding-Change-the-program-keep-the-state-" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/14/The-essence-of-live-coding-Change-the-program-keep-the-state-</span></a></li>
</ul>
<p>同じ時刻の<span class="ascii">HIW</span>の発表を聴講していたためこちらは聴講していません。</p>
<h1 id="monad-transformers-and-modular-algebraic-effects-what-binds-them-together"><span class="link-to-here-outer"><a href="#monad-transformers-and-modular-algebraic-effects-what-binds-them-together" title="monad-transformers-and-modular-algebraic-effects-what-binds-them-together"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Monad Transformers and Modular Algebraic Effects: What Binds Them Together</span></h1>
<ul>
<li>著者：<span class="ascii">Tom Schrijvers (KU Leuven), Maciej Piróg (University of Wroc</span>ł<span class="ascii">aw), Nicolas Wu (Imperial College London), Mauro Jaskelioff (CONICET)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/7/Monad-Transformers-and-Modular-Algebraic-Effects-What-Binds-Them-Together" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/7/Monad-Transformers-and-Modular-Algebraic-Effects-What-Binds-Them-Together</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342595" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342595</span></a></li>
</ul>
<p>モナドトランスフォーマーと代数的効果との対比である。</p>
<p>モナドトランスフォーマーから代数的効果への変換またその逆のときにどういう手法があって、それぞれを構成する要素がどう対応しているかを説明している。</p>
<p>モナドトランスフォーマーと代数的効果だとモナドトランスフォーマーの方が表現できるものが大きいのでモナドトランスフォーマーから代数的効果へはどんなものでも変換できるわけではない。</p>
<p>例えば<code>catch</code>や<code>local</code>は代数的効果にできない。</p>
<h1 id="scoping-monadic-relational-database-queries"><span class="link-to-here-outer"><a href="#scoping-monadic-relational-database-queries" title="scoping-monadic-relational-database-queries"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Scoping Monadic Relational Database Queries</span></h1>
<ul>
<li>著者：<span class="ascii">Anton Ekblad (Chalmers University of Technology)</span></li>
<li>概要：<a href="https://icfp19.sigplan.org/details/haskellsymp-2019-papers/10/Scoping-Monadic-Relational-Database-Queries" class="uri"><span class="ascii">https://icfp19.sigplan.org/details/haskellsymp-2019-papers/10/Scoping-Monadic-Relational-Database-Queries</span></a></li>
<li>論文：<a href="https://dl.acm.org/citation.cfm?id=3342598" class="uri"><span class="ascii">https://dl.acm.org/citation.cfm?id=3342598</span></a></li>
</ul>
<p>モナドは<span class="ascii">Haskell</span>界隈で非常に普及しているので<span class="ascii">SQL</span>に対する<span class="ascii">EDSL</span>としてモナドの構造を採用したい。</p>
<p>このとき<span class="ascii">SQL</span>の結合を表現すると、<span class="ascii">SQL</span>としてはスコープ外にもかかわらず<span class="ascii">EDSL</span>としてはスコープ内となって使える変数ができてしまう。</p>
<p>これを<span class="ascii">EDSL</span>としてもエラーとしたい。</p>
<p>例えば、次のような例で実行時エラーとなってしまう。ここで<code>a0</code>は<code>tableA</code>の列とする。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">SELECT</span> a0, b0</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">FROM</span></a>
<a class="sourceLine" id="cb8-3" title="3">  tableA</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="kw">LEFT</span> <span class="kw">JOIN</span></a>
<a class="sourceLine" id="cb8-5" title="5">      (<span class="kw">SELECT</span> b0 <span class="kw">FROM</span> tableB <span class="kw">WHERE</span> a0 <span class="op">==</span> b1)</a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="kw">ON</span> tableA.a2 <span class="op">==</span> tableb.b2</a></code></pre></div>
<p><code>SELECT b0 FROM tableB WHERE a0 == b1</code>の部分でスコープ外の<code>a0</code>を参照しているためエラーとなる。</p>
<p>単純なモナド<span class="ascii">EDSL</span>だと次のようになりコンパイルが通る。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">do</span></a>
<a class="sourceLine" id="cb9-2" title="2">  a0 <span class="op">:*:</span> a1 <span class="op">:*:</span> a2 <span class="ot">&lt;-</span> from table0</a>
<a class="sourceLine" id="cb9-3" title="3">  leftJoin <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-4" title="4">    b0 <span class="op">:*:</span> b1 <span class="op">:*:</span> b2 <span class="ot">&lt;-</span> from table1</a>
<a class="sourceLine" id="cb9-5" title="5">    ristrict <span class="op">$</span> a0 <span class="op">.==</span> b1</a>
<a class="sourceLine" id="cb9-6" title="6">  on <span class="op">$</span> a2 <span class="op">.==</span> b2</a></code></pre></div>
<p><code>ristrict $ a0 .== b1</code>の部分において<code>a0</code>は<span class="ascii">Haskell</span>としてはスコープ内にある。</p>
<p>この問題を次のような型レベル関数を駆使することで<span class="ascii">EDSL</span>においてもコンパイル時エラーとすることができた。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Cols</span> a</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Outer</span> a</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">UnAggr</span> a</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">FromRow</span> a</a></code></pre></div>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-copilot.html" lang="ja">HIW 2019で発表された、Copilotという内部DSLについて</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-gibbon.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、Gibbonコンパイラーについて</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、Gibbonコンパイラーについて</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-gibbon.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-gibbon.html</id>
    <published>2019-09-28T00:00:00Z</published>
    <updated>2019-09-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-ghc-future.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表を紹介します。<br />
今回は、<a href="http://iu-parfunc.github.io/gibbon/"><span class="ascii">Gibbon</span></a>という、<span class="ascii">GHC</span>以外の<span class="ascii">Haskell</span><small>（の、サブセット）</small>の処理系についての発表です。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#the-gibbon-compiler-accelerating-a-small-subset-of-haskell" title="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="ascii">The Gibbon Compiler: Accelerating a small subset of Haskell</span></a></li>
</ul>
</div>
</div>
<h1 id="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="link-to-here-outer"><a href="#the-gibbon-compiler-accelerating-a-small-subset-of-haskell" title="the-gibbon-compiler-accelerating-a-small-subset-of-haskell"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">The Gibbon Compiler: Accelerating a small subset of Haskell</span></h1>
<p>発表者<span class="ascii">: Ryan R. Newton</span> <em><span class="ascii">Indiana University</span></em><span class="ascii">, Michael Vollmer</span> <em><span class="ascii">Indiana University, USA</span></em><span class="ascii">, Chaitanya Koparkar</span> <em><span class="ascii">Indiana University</span></em></p>
<p><span class="ascii">Gibbon</span>は最適化の手法を研究するために作られたコンパイラーです。<br />
具体的には、我々<small>（特に<span class="ascii">Haskeller</span>）</small>がよく使う、木構造全体に対する処理の最適化です。</p>
<p>こうした木構造のデータは、通常ポインターを使ってメモリー内にバラバラに格納されますが、<span class="ascii">Gibbon</span>による最適化を行うと、実際にプログラムがどのような順番で木を処理しているのか解析して、（元のデータ構造を配列に変換した上で）その順番に並べられた配列として処理するコードに変換する、という大胆な変換を行います。 図にするとこんなイメージでしょうか？</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array1.svg" alt="変換前の木構造。各ノードがそれぞれ（レベル順で）A, B, … , Gという値を持っている" /><figcaption>変換前の木構造。各ノードがそれぞれ（レベル順で）<span class="ascii">A, B,</span> … <span class="ascii">, G</span>という値を持っている</figcaption>
</figure>
<p>👆のような木構造があったとして、</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array2.svg" alt="行きがけ順（A, B, D, E, C, F, Gの順）でアクセスする" /><figcaption>行きがけ順（<span class="ascii">A, B, D, E, C, F, G</span>の順）でアクセスする</figcaption>
</figure>
<p>👆における、赤い線の順番<small>（行きがけ順）</small>にアクセスする関数があったとします。<br />
適当に<span class="ascii">Haskell</span>の再帰関数として書くと、👇こういうコードです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> <span class="ot">=</span> <span class="dt">Node</span> <span class="dt">Char</span> (<span class="dt">Maybe</span> <span class="dt">Tree</span>) (<span class="dt">Maybe</span> <span class="dt">Tree</span>) <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">tree ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb1-4" title="4">tree <span class="ot">=</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="dt">Node</span> <span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb1-6" title="6">    ( <span class="dt">Just</span></a>
<a class="sourceLine" id="cb1-7" title="7">      ( <span class="dt">Node</span> <span class="ch">&#39;B&#39;</span></a>
<a class="sourceLine" id="cb1-8" title="8">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;D&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-9" title="9">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;E&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-10" title="10">      )</a>
<a class="sourceLine" id="cb1-11" title="11">    )</a>
<a class="sourceLine" id="cb1-12" title="12">    ( <span class="dt">Just</span></a>
<a class="sourceLine" id="cb1-13" title="13">      ( <span class="dt">Node</span> <span class="ch">&#39;C&#39;</span></a>
<a class="sourceLine" id="cb1-14" title="14">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;F&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-15" title="15">        (<span class="dt">Just</span> (<span class="dt">Node</span> <span class="ch">&#39;G&#39;</span> <span class="dt">Nothing</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb1-16" title="16">      )</a>
<a class="sourceLine" id="cb1-17" title="17">    )</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="ot">preOrder ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-20" title="20">preOrder access (<span class="dt">Node</span> char mLeft mRight) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-21" title="21">  access char</a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23">  <span class="kw">case</span> mLeft <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="dt">Just</span> left <span class="ot">-&gt;</span> preOrder access left</a>
<a class="sourceLine" id="cb1-25" title="25">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27">  <span class="kw">case</span> mRight <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-28" title="28">    <span class="dt">Just</span> right <span class="ot">-&gt;</span> preOrder access right</a>
<a class="sourceLine" id="cb1-29" title="29">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</a></code></pre></div>
<p><span class="ascii">Gibbon</span>はこの関数と、それが処理する木構造を解析して、</p>
<figure>
<img src="/img/2019/hiw-gibbon/tree-and-array3.svg" alt="変換された配列。A, B, D, E, C, F, Gの順に要素が並んだただの配列" /><figcaption>変換された配列。<span class="ascii">A, B, D, E, C, F, G</span>の順に要素が並んだただの配列</figcaption>
</figure>
<p>👆のような、ただの配列（とそれに対する関数）にまとめて変換してしまう、というのです！</p>
<p>現代のコンピューターは、このような配列の要素にまとめてアクセス処理する方が、ポインターをたどって各要素を処理するより、たいてい遙かに速いです。<br />
<span class="ascii">Gibbon</span>はこの特性を活かすべく、我々<span class="ascii">Haskeller</span>が好んで使うような、ポインターだらけの木構造を可能な限り配列に変換することで、要素をまとめて処理する（<span class="ascii">traverse</span>する）演算の最適化を図るコンパイラーです。</p>
<p>ちなみに、元の木に対するノードの追加に相当する処理は、新しいノードに対するポインターを書き込む処理に変換するそうです。<br />
なので何度も追加を繰り返すと、あまり恩恵が受けられなくなってしまいそうです。</p>
<p>なかなか興味深いアイディアですが、個人的に聞きそびれた疑問が<span class="ascii">2</span>つあります。<br />
一つは、そもそも木構造を定義するような状況というのは、いろいろな順番でアクセスしたいし、新しい要素の追加も繰り返し行いたいケースではないでしょうか？<br />
例えば<a href="http://hackage.haskell.org/package/unordered-containers"><span class="ascii">unordered-containers</span></a>にある<code>HashMap</code>型は探索木を使った頻繁に使われるデータ構造ですが、<code>HashMap</code>を使う場合に行う処理の多くは、ランダムアクセスや要素の追加・削除でしょう。</p>
<p>なので、<span class="ascii">Gibbon</span>が最適化したい「木構造」というのは、どちらかというと探索木のような木ではなく、構文木のような、要素をまとめて処理することを前提とした木のことなのかもしれません。<br />
確かに人間が書く言語の構文木程度であれば、すべてメモリー上で処理できる程度のサイズに収まる<small>（という想定でなければコンパイラー作りがものすごく難しくなる）</small>でしょうし、構文木の処理を高速化できれば、遅い遅いと言われる<span class="ascii">GHC</span>のコンパイル速度も高められるはずです。それはそれでありがたい。</p>
<p>もう一つは、これまた例えば<code>HashMap</code>型のような木をベースにした連想配列も、配列ベースのハッシュテーブルに変換することができるのでしょうか？<br />
もしそうだとすると、ランダムアクセスに対する計算量のオーダーも<span class="ascii">O(log n)</span>から<span class="ascii">O(1)</span>に変わるわけですし、要素をまとめて処理する以外の演算についても劇的な改善が見込めるかもしれません。<br />
もちろんこれも先ほどの推測が正しければ無意味な想像ですが、夢のある話ですね。</p>
<p><span class="ascii">Gibbon</span>は将来的には、<code>Packed</code>という型クラスを提供することで、<span class="ascii">GHC</span>本体への統合も視野に入れているそうです。<br />
<code>Packed</code>を実装した型は、値をどのように配列に変換するのか定義することで、<span class="ascii">Gibbon</span>による最適化のためのヒントを与えることができます。</p>
<p>参考<span class="ascii">:</span> <a href="https://ja.wikipedia.org/w/index.php?title=%E6%9C%A8%E6%A7%8B%E9%80%A0_(%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)&amp;oldid=72655479">木構造 <span class="ascii">(</span>データ構造<span class="ascii">) - Wikipedia</span></a></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/haskell-symposium.html" lang="ja">Haskell Symposium 2019 レポート</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-ghc-future.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、GHC 8.10に導入されるであろう機能</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、GHC 8.10に導入されるであろう機能</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-ghc-future.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-ghc-future.html</id>
    <published>2019-09-17T00:00:00Z</published>
    <updated>2019-09-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p><a href="/posts/2019/hiw-ghc8.8.html">前回</a>から引き続き、<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>への参加レポートとして、私の印象に残った発表をいくつか紹介します。<br />
今回は、「<span class="ascii">GHC 8.10</span>に導入されるであろう機能」です。<br />
いずれも該当する<span class="ascii">Merge Request</span>は<span class="ascii">master</span>ブランチにマージ済みなので、おそらく<span class="ascii">GHC 8.10</span>で提供されるでしょう。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#holefitplugins-and-the-future-of-interactive-development-in-ghc" title="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="ascii">HoleFitPlugins and the future of interactive development in GHC</span></a></li>
<li><a href="#visible-dependent-quantification" title="visible-dependent-quantification"><span class="ascii">Visible dependent quantification</span></a></li>
</ul>
</div>
</div>
<h2 id="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="link-to-here-outer"><a href="#holefitplugins-and-the-future-of-interactive-development-in-ghc" title="holefitplugins-and-the-future-of-interactive-development-in-ghc"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HoleFitPlugins and the future of interactive development in GHC</span></h2>
<ul>
<li>発表者<span class="ascii">: Matthías Páll Gissurarson</span> <em><span class="ascii">Chalmers University of Technology, Sweden</span></em></li>
<li>該当の<span class="ascii">Merge Request:</span> <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/153"><span class="ascii">!153</span></a></li>
<li>該当の<span class="ascii">GHC Proposal:</span> なし</li>
</ul>
<p><a href="https://icfp18.sigplan.org/details/haskellsymp-2018-papers/10/Suggesting-Valid-Hole-Fits-for-Typed-Holes-Experience-Report-">昨年の<span class="ascii">Haskell Symposium</span>でも発表</a>されて<span class="ascii">GHC 8.6</span>で導入された、「<span class="ascii">Valid Hole Fits</span>」という機能のさらなる拡張について。</p>
<p>まず、「<span class="ascii">Valid Hole Fits</span>」という機能について軽く紹介します<small>（詳しくは<a href="https://wataru86.github.io/slides/vhs/">こちらのスライド</a>が参考になるかと思います）</small>。<br />
「<span class="ascii">Valid Hole Fits</span>」はアンダースコア <code>_</code>で始まる識別子を書いたとき、<span class="ascii">GHC</span>が推論した型にマッチする関数をエラーメッセージに付記することで、ユーザーがどんな式を書けばよいか、ヒントを与えてくれるものです。</p>
<p>例えば、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> _someFunc) [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">True</span>]</a></code></pre></div>
<p>上記のように、アンダースコア <code>_</code>で始まる識別子を書いたとき、</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">16</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="op">...</span></a>
<a class="sourceLine" id="cb2-3" title="3">      <span class="dt">Valid</span> hole fits include</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">        enumFrom ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-5" title="5">          with <span class="fu">enumFrom</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-6" title="6">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Enum</span>’))</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ot">        show ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-8" title="8">          with <span class="fu">show</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-9" title="9">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Show</span>’))</a>
<a class="sourceLine" id="cb2-10" title="10"><span class="ot">        repeat ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-11" title="11">          with <span class="fu">repeat</span> <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-12" title="12">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.List</span>’))</a>
<a class="sourceLine" id="cb2-13" title="13"><span class="ot">        return ::</span> <span class="kw">forall</span> (<span class="ot">m ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) a<span class="op">.</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb2-14" title="14">          with <span class="fu">return</span> <span class="op">@</span>[] <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-15" title="15">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a>
<a class="sourceLine" id="cb2-16" title="16"><span class="ot">        pure ::</span> <span class="kw">forall</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) a<span class="op">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb2-17" title="17">          with <span class="fu">pure</span> <span class="op">@</span>[] <span class="op">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-18" title="18">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a>
<a class="sourceLine" id="cb2-19" title="19"><span class="ot">        mempty ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> a</a>
<a class="sourceLine" id="cb2-20" title="20">          with <span class="fu">mempty</span> <span class="op">@</span>(<span class="dt">Bool</span> <span class="ot">-&gt;</span> [a0])</a>
<a class="sourceLine" id="cb2-21" title="21">          (imported from ‘<span class="dt">Prelude</span>’ (<span class="fu">and</span> originally defined <span class="kw">in</span> ‘<span class="dt">GHC.Base</span>’))</a></code></pre></div>
<p>といった具合に、アンダースコアで始まる識別子<code>_someFunc</code>の型を<code>Bool -&gt; [a0]</code>と推論した上で<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>、実際にその型に該当する関数を、当該のスコープにおいてアクセスできる関数の中から探して教えてくれる、それが「<span class="ascii">Valid Hole Fits</span>」という機能です。</p>
<p>今回発表された「<span class="ascii">HoleFitPlugins</span>」という機能は、名前のとおりこの「<span class="ascii">Valid Hole Fits</span>」に対するプラグイン機構です。<br />
「<span class="ascii">Valid Hole Fits</span>」が表示する「型にマッチした関数」を探す処理を、<span class="ascii">Haskell</span>のコードで書き換えられるようにしてくれます！</p>
<p>「そこまでする必要あるの？」という気もしてきますが、発表者曰く</p>
<ul>
<li><span class="ascii">Hoogle</span>をはじめ、<span class="ascii">TensorFlow</span>など<span class="ascii">GHC</span>の外部にあるものを利用して「型にマッチした関数」を探せるようにするために必要</li>
<li><span class="ascii">GHCi</span>とこの機構を組み合わせることで、もっとインタラクティブな開発を促進したい</li>
</ul>
<p>という意図があるそうです。</p>
<p>最新安定版の<span class="ascii">GHC</span>では利用できませんが、<a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/extending_ghc.html#hole-fit-plugins">ドキュメントがこちら</a>にあるので、<span class="ascii">GHC</span>の<span class="ascii">HEAD</span><small>（<span class="ascii">master</span>ブランチで開発中のバージョン）</small>をコンパイルすれば使用できるようです。</p>
<p>加えて発表では、<code>_</code>で始まる識別子を書く際の構文を拡張することで、どのように<span class="ascii">candidate</span>を探すか指定できるようにする、なんて機能も紹介されました<small>（ドキュメントを読む限りこの機能はまだ<span class="ascii">HEAD</span>に入ってない？）</small>。<br />
例えば、<span class="ascii">Hoogle</span>を使って<span class="ascii">Valid Hole Fits</span>を探したいとき、次のように書くことで検索対象を<code>Control.Applicative</code>に限定する、といったことをできるようしてくれます。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">g ::</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb3-2" title="2">g <span class="ot">=</span> _{hoogleLookup <span class="st">&quot;+Control.Applicative&quot;</span>}</a></code></pre></div>
<p><span class="ascii">Valid Hole Fits</span>の検索方法をその場で微調整したい、というときに使うものですね。</p>
<h2 id="visible-dependent-quantification"><span class="link-to-here-outer"><a href="#visible-dependent-quantification" title="visible-dependent-quantification"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">Visible dependent quantification</span></h2>
<ul>
<li>発表者<span class="ascii">: Ryan Scott</span> <em><span class="ascii">Indiana University at Bloomington, USA</span></em></li>
<li>該当の<span class="ascii">Merge Request:</span> <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/378"><span class="ascii">!378</span></a></li>
<li>該当の<span class="ascii">GHC Proposal:</span> <a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0081-forall-arrow.rst"><span class="ascii">0081-forall-arrow</span></a></li>
</ul>
<p>タイトルのとおり、「<span class="ascii">Visible dependent quantification</span>」という機能の紹介です。</p>
<p>最近のバージョンの<span class="ascii">GHCi</span>における<code>:kind</code>コマンドは、次のような、<span class="ascii">GHC</span>がサポートしていない構文の型注釈を出力することがあります。<br />
例えば</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XKindSignatures</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XPolyKinds</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">SomeType</span> k (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="op">&gt;</span> <span class="op">:</span>kind <span class="dt">SomeType</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="dt">SomeType</span><span class="ot"> ::</span> <span class="kw">forall</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>における、<code>SomeType :: forall k -&gt; k -&gt; *</code>の<code>forall k -&gt;</code>という部分です。<br />
現在の<span class="ascii">Haskell</span>で<code>forall k</code>などと書くときは、必ず</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">SomeType</span><span class="ot"> ::</span> <span class="kw">forall</span> k<span class="op">.</span> k <span class="ot">-&gt;</span> <span class="op">*</span></a></code></pre></div>
<p>といった具合に、ピリオドで区切った構文になります。<br />
ところが先ほどの<code>:kind</code>の出力では、<code>forall k -&gt;</code>とあるとおり、<code>forall k</code>に<small>（型ではなく、カインドとしての）</small>関数を表す<code>-&gt;</code>が使われています。<br />
「<span class="ascii">Visible dependent quantification</span>」はまさにこれを、<code>:kind</code>コマンドによって出力される構文だけではなく、ユーザーが直接書ける構文にしよう、というものです。 <span class="ascii">GHC</span>に「依存型」という機能を加える「<span class="ascii">Dependent Haskell</span>」にも必要な機能だそうです。<br />
私自身はこの機能を使う機会がちょっと思い浮かばなかったので省略しますが、より詳しい解説は発表者である<a href="https://ryanglscott.github.io/2019/03/15/visible-dependent-quantification-in-haskell/"><span class="ascii">Ryan</span>自身による記事（英語）</a>をご覧ください。何が「<span class="ascii">Visible</span>」でどう「<span class="ascii">Dependent</span>」なのかわかるはずです。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>復習<span class="ascii">:</span> この、「アンダースコアで始まる識別子<code>_someFunc</code>の型を<code>Bool -&gt; [a0]</code>と推論した上で」エラーメッセージにおいて<code>Found hole: _someFunc :: Bool -&gt; [a0]</code>と教えてくれるのが「<span class="ascii">Type Hole</span>」という機能なのでした。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-gibbon.html" lang="ja">HIW 2019で発表された、Gibbonコンパイラーについて</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/hiw-ghc8.8.html" style="margin-left: auto;" lang="ja">HIW 2019で発表された、GHC 8.8で導入された機能</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>HIW 2019で発表された、GHC 8.8で導入された機能</title>
    <link href="https://haskell.jp/blog/posts/2019/hiw-ghc8.8.html" />
    <id>https://haskell.jp/blog/posts/2019/hiw-ghc8.8.html</id>
    <published>2019-09-11T00:00:00Z</published>
    <updated>2019-09-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>こんにちは。<br />
今回からいくつか、「<a href="https://icfp19.sigplan.org/home/hiw-2019#About"><span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop 2019</span></a>」に私が先月参加した際のレポートとして、印象深い発表をテーマごとに分けた短い記事を執筆します。<br />
最近公開された<a href="https://www.haskell.org/ghc/download_ghc_8_8_1.html"><span class="ascii">GHC 8.8</span></a>の話はもちろん、未来の<span class="ascii">GHC</span>やその他の<span class="ascii">Haskell</span>の処理系を知るのによいイベントでしたので、その一部だけでも伝われば幸いです。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#そもそもhaskell-implementors-workshop-hiwとは" title="そもそもhaskell-implementors-workshop-hiwとは">そもそも<span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop (HIW)</span>とは？</a></li>
<li><a href="#hie-files-in-ghc-8.8" title="hie-files-in-ghc-8.8"><span class="ascii">HIE files in GHC 8.8</span></a></li>
<li><a href="#ghc-status-report" title="ghc-status-report"><span class="ascii">GHC status report</span></a></li>
<li><a href="#とりあえず今回はここまで" title="とりあえず今回はここまで">とりあえず今回はここまで</a></li>
</ul>
</div>
</div>
<h1 id="そもそもhaskell-implementors-workshop-hiwとは"><span class="link-to-here-outer"><a href="#そもそもhaskell-implementors-workshop-hiwとは" title="そもそもhaskell-implementors-workshop-hiwとは"><span class="link-to-here">Link to<br />
here</span></a></span>そもそも<span class="ascii">Haskell Implementors</span>’ <span class="ascii">Workshop (HIW)</span>とは？</h1>
<p>シリーズ（？）第<span class="ascii">1</span>回目なので、簡単に<span class="ascii">HIW</span>そのものについて紹介しておきましょう。<br />
<span class="ascii">HIW</span>は、<a href="https://icfp19.sigplan.org/home"><span class="ascii">ICFP (International Conference on Functional Programming)</span></a>という関数型プログラミングについての国際会議に併設された、<span class="ascii">Haskell</span>の実装者のためのワークショップです。<br />
名前の通り、<span class="ascii">GHC</span>をはじめとする<span class="ascii">Haskell</span>の処理系<small>（あるいは、<span class="ascii">Haskell</span>で実装された言語処理系）</small>の実装に関する発表だけでなく、かなり緩いテーマの<span class="ascii">Lightning Talk</span>の時間があったり、<span class="ascii">GHC</span>の将来の方向性について自由に議論する時間もあったりしました。</p>
<p>今回はそのうち、掲題のとおり「<span class="ascii">HIW 2019</span>で発表された、<span class="ascii">GHC 8.8</span>で導入された機能」を紹介します。まずは「<span class="ascii">HIE files in GHC 8.8</span>」から。</p>
<h1 id="hie-files-in-ghc-8.8"><span class="link-to-here-outer"><a href="#hie-files-in-ghc-8.8" title="hie-files-in-ghc-8.8"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">HIE files in GHC 8.8</span></h1>
<p>発表者<span class="ascii">: Zubin Duggal, Matthew Pickering</span> <em><span class="ascii">University of Bristol</span></em></p>
<p><span class="ascii">GHC 8.8</span>で新たに追加された、<span class="ascii">HIE</span><small>（「<span class="ascii">Haskell Interface Extended</span>」の略と思われます）</small>ファイルについての発表です。<br />
コンパイル時に<span class="ascii">GHC</span>が得たモジュールの情報を、<a href="https://github.com/haskell/haskell-ide-engine"><span class="ascii">Haskell IDE Engine</span></a>などの<span class="ascii">IDE</span>のバックエンドが再利用しやすい形で出力する機能です。<br />
従来<span class="ascii">Haskell IDE Engine</span><small>（その裏で使われている<span class="ascii">ghc-mod</span>）</small>や<a href="https://github.com/ndmitchell/ghcid"><span class="ascii">ghcid</span></a>、<a href="https://github.com/chrisdone/intero"><span class="ascii">intero</span></a>などの、「<span class="ascii">IDE</span>バックエンド」<small>（エディターが入力の補完や入力したソースコードにおけるエラーを表示する際に通信するソフトウェア）</small>は、自前で<span class="ascii">GHC API</span>や<span class="ascii">GHCi</span>を呼ぶことで、型チェックしたり定義ジャンプに必要な位置情報を収集したりしていたのですが、そうした情報の収集をすべて<span class="ascii">GHC</span>自身が<span class="ascii">HIE</span>ファイルを出力することで賄えるようになる、ということです。</p>
<p>私は従来開発中、<code>stack test --pedantic --file-watch</code>などと<span class="ascii">Neovim</span>のターミナル機能で実行して実行ファイルをビルドしつつ、<span class="ascii">HIE</span>にエラーの表示や入力の補完をさせていたのですが、その際も二重にソースコードが解析されていたんですね！<br />
私がそのようにわざわざ<code>stack test</code>と<span class="ascii">HIE</span>を並行して実行させているのは、<span class="ascii">HIE</span>がしばしばフリーズしてしまったり<small>（<span class="ascii">Neovim</span>ごと再起動すれば直ることも多いんですが…😰）</small>、<span class="ascii">HIE</span>だけでは実行ファイルの作成やテストの実行ができない、という理由があるためです。<br />
<code>stack test</code>だけで<span class="ascii">HIE</span>ファイルが生成されるようになれば、エラーに関する情報やソースコードの解析結果といった情報が一元化されるので、より安定的に、より少ないリソースで<span class="ascii">HIE</span>が使えるようになるでしょう。本家<span class="ascii">Haskell IDE Engine</span>がサポートする日が楽しみです。</p>
<p>この、<span class="ascii">HIE</span>ファイルを利用するアプリケーションの例も紹介されました。<br />
<a href="https://github.com/wz1000/hie-lsp"><span class="ascii">hie-lsp</span></a>という小さな<span class="ascii">Language Server Protocol</span>の実装に加え、<a href="https://github.com/mpickering/hie-lsif"><span class="ascii">hie-lsif</span></a>という、<span class="ascii">HIE</span>ファイルから「<a href="https://github.com/microsoft/language-server-protocol/blob/master/indexFormat/specification.md"><span class="ascii">Language Server Index Format (LSIF)</span></a>」形式のファイルを作成するコマンドが印象的でした。<br />
この<span class="ascii">LSIF</span>というファイルは、例えば<span class="ascii">GitHub</span>のリポジトリ上でブラウザからソースコードを閲覧する際にも、定義ジャンプといった便利な機能を使えるようにするためのものです。リポジトリに置いたソースコードを処理系がどのように解釈したかを保存しておくことで、<span class="ascii">Language Server</span>はじめ処理系を実行することなく利用できるようにするものだそうです。<br />
現状は仕様策定中なためか、実際に<span class="ascii">LSIF</span>を解釈するアプリケーションは見つかりませんでしたが、今後の活用に期待が高まりますね。</p>
<p>加えて、<span class="ascii">HIE</span>ファイルが将来的にサポートしたい機能などについても発表されました。</p>
<ul>
<li>型クラスのインスタンスが、具体的にどの型のインスタンスとして解決されたかの出力
<ul>
<li>定義ジャンプしたときに、型クラス自身の宣言ではなく、実装に飛べるようにするため</li>
</ul></li>
<li>従来<span class="ascii">GHC</span>が分割コンパイルをサポートするために、モジュールの依存情報を出力していた「インターフェースファイル<small>（<code>.hi</code>という拡張子で出力されているあのファイル）</small>」との統合</li>
<li>すべての型推論の結果</li>
</ul>
<h1 id="ghc-status-report"><span class="link-to-here-outer"><a href="#ghc-status-report" title="ghc-status-report"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">GHC status report</span></h1>
<p>発表者<span class="ascii">: Simon Peyton Jones</span> <em><span class="ascii">Microsoft, UK</span></em></p>
<p><span class="ascii">GitLab</span>への移行や<span class="ascii">Hadrian</span>と呼ばれる新しいビルドシステムの導入など、インフラ周りでいろいろ変更があったこともあり、遅れてしまいましたが<span class="ascii">GHC 8.8</span>がもうすぐ出るよ、という内容の発表でした<small>（発表当時。もう<a href="https://www.haskell.org/ghc/blog/20190825-ghc-8.8.1-released.html"><span class="ascii">GHC 8.8</span>はリリースされています</a>）</small>。</p>
<p>言及された主な追加機能は以下のとおりです。</p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TypeApplications"><code>TypeApplications</code></a>という言語拡張が、型変数だけでなくカインド変数に対しても適用できるようになりました。<br />
正直に言って、個人的に使いどころがまだまだなさそうな機能ではありますが…。</li>
<li><p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a>という言語拡張を使った場合に、パターンマッチした変数に型注釈を付けることができるようになる、という機能がありまして、これが拡張されました。<br />
具体的には、従来下記のように書くことで、関数自体の型注釈にある型変数<code>a</code>と、パターンマッチした変数<code>x</code>に型注釈した<code>b</code>が等しくなるように書くことができたのを、</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">f ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" title="2">f (<span class="dt">Just</span> (<span class="ot">x ::</span> b)) <span class="ot">=</span> <span class="co">{- ... -}</span></a></code></pre></div>
<p>さらに拡張して、関数自体の型注釈にある型変数<strong>ではない</strong><code>Int</code>と、パターンマッチした変数<code>x</code>に型注釈した<code>b</code>が等しくなるように書くことができるようにした、という拡張です。<br />
あたかも型変数でパターンマッチしているかのようですね。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" title="2">f (<span class="dt">Just</span> (<span class="ot">x ::</span> b)) <span class="ot">=</span> <span class="co">{- ... -}</span></a></code></pre></div>
<p>一体何の役に立つの？とも思いましたが、<a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0128-scoped-type-variables-types.rst#128motivation">この修正に向けた提案</a>曰く、</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">f ::</span> <span class="dt">ReallyReallyReallyReallyLongTypeName</span> <span class="ot">-&gt;</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb3-2" title="2">f (<span class="ot">x ::</span> a) <span class="ot">=</span> … (<span class="fu">read</span> <span class="st">&quot;&quot;</span><span class="ot"> ::</span> a) …</a></code></pre></div>
<p>と書くことで、長い型名に対して別名を付けることができるようになる、というメリットがあるそうです。なるほど💡</p></li>
</ul>
<h1 id="とりあえず今回はここまで"><span class="link-to-here-outer"><a href="#とりあえず今回はここまで" title="とりあえず今回はここまで"><span class="link-to-here">Link to<br />
here</span></a></span>とりあえず今回はここまで</h1>
<p>テーマを絞って短い記事にした方が<span class="ascii">SEO</span>的にいいんじゃないかと思いまして、今回は敢えて紹介する発表を絞りました。<br />
今後は下記のテーマについて紹介する予定です。</p>
<ul>
<li><span class="ascii">HIW 2019</span>で発表された、これからの<span class="ascii">GHC</span>に入るであろう機能</li>
<li><span class="ascii">HIW 2019</span>で発表された、<span class="ascii">GHC</span>以外の言語処理系</li>
</ul>
<p>また、<span class="ascii">HIW</span>と同じく<span class="ascii">ICFP 2019</span>に併設して開催された、<a href="https://icfp19.sigplan.org/home/haskellsymp-2019"><span class="ascii">Haskell Symposium 2019</span></a>の発表についても別途共有する予定です。<br />
乞うご期待。<br />
<span class="ascii">hask(_ _)eller</span></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-ghc-future.html" lang="ja">HIW 2019で発表された、GHC 8.10に導入されるであろう機能</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/fallible.html" style="margin-left: auto;" lang="ja">fallibleというパッケージをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>
<entry>
    <title>fallibleというパッケージをリリースしました</title>
    <link href="https://haskell.jp/blog/posts/2019/fallible.html" />
    <id>https://haskell.jp/blog/posts/2019/fallible.html</id>
    <published>2019-07-18T00:00:00Z</published>
    <updated>2019-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<article lang="ja">

    <div class="container">
        <div class="row">
            <div class="col-lg-offset-2 col-lg-8 col-md-offset-1 col-md-10">
                <ul class="social-buttons">
                    <li><div>
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                    </div></li>
                    <li><div>
                        <script type="text/javascript">
                            reddit_target = "haskell_jp";
                            reddit_title  = document.title;
                        </script>
                        <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
                    </div></li>
                    <li><div>
                        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en"></a>
                        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
                    </div></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div id="md-post-content" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <hr />
<p>タイトルの通り、<span class="ascii">fallible</span>というパッケージを紹介します。</p>
<ul>
<li><a href="https://github.com/matsubara0507/fallible"><span class="ascii">matsubara0507/fallible: interface for fallible data type like Maybe and Either. - GitHub</span></a></li>
</ul>
<p>ちなみに、<span class="ascii">fallible</span>は<span class="ascii">Haskell-jp Slack</span>で<span class="ascii">:</span></p>
<p><img src="../../img/2019/fallible/slack.jpg" style="width: 100%;"></p>
<p>と質問したところ、該当するようなパッケージは無さそうだったので作ったという経緯があります。 その際に助言をくれた <a href="https://github.com/fumieval"><span class="ascii">fumieval</span></a>氏のコードをほとんど引用した形になったので、<span class="ascii">Haskell-jp Blog</span>に紹介記事を載せることにしました<span class="ascii">(</span>僕は普段、自分のブログに自作したパッケージを書いています<span class="ascii">)</span>。</p>
<div id="table-of-contents-outer">
<div id="table-of-contents">
<div class="table-of-contents-title">
Contents
</div>
<ul>
<li><a href="#fallibleパッケージ" title="fallibleパッケージ"><span class="ascii">fallible</span>パッケージ</a>
<ul>
<li><a href="#やってること" title="やってること">やってること</a></li>
<li><a href="#基本演算子" title="基本演算子">基本演算子</a></li>
</ul></li>
<li><a href="#サンプルコード" title="サンプルコード">サンプルコード</a></li>
<li><a href="#使い方" title="使い方">使い方</a></li>
<li><a href="#おしまい" title="おしまい">おしまい</a></li>
</ul>
</div>
</div>
<h2 id="fallibleパッケージ"><span class="link-to-here-outer"><a href="#fallibleパッケージ" title="fallibleパッケージ"><span class="link-to-here">Link to<br />
here</span></a></span><span class="ascii">fallible</span>パッケージ</h2>
<p><span class="ascii">Haskell</span>でアプリケーションを記述してると次のようなコードを書くことがありますよね？</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-4" title="4">run targetName token verbose <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-5" title="5">  users <span class="ot">&lt;-</span> getUsers token</a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="kw">case</span> users <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="dt">Left</span> err <span class="ot">-&gt;</span> logDebug&#39; err</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="dt">Right</span> us <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-9" title="9">      <span class="kw">case</span> userId <span class="op">&lt;$&gt;</span> L.find isTarget us <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> logDebug&#39; emsg</a>
<a class="sourceLine" id="cb1-11" title="11">        <span class="dt">Just</span> tid <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-12" title="12">          channels <span class="ot">&lt;-</span> getChannels token</a>
<a class="sourceLine" id="cb1-13" title="13">          <span class="kw">case</span> channels <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-14" title="14">            <span class="dt">Left</span> err  <span class="ot">-&gt;</span> logDebug&#39; err</a>
<a class="sourceLine" id="cb1-15" title="15">            <span class="dt">Right</span> chs <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-16" title="16">              <span class="kw">let</span> chs&#39; <span class="ot">=</span> <span class="fu">filter</span> (<span class="fu">elem</span> tid <span class="op">.</span> channelMembers) chs</a>
<a class="sourceLine" id="cb1-17" title="17">              <span class="fu">mapM_</span> (logDebug&#39; <span class="op">.</span> channelName) chs&#39;</a>
<a class="sourceLine" id="cb1-18" title="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-19" title="19">    logDebug&#39; <span class="ot">=</span> logDebug verbose</a>
<a class="sourceLine" id="cb1-20" title="20">    emsg <span class="ot">=</span> <span class="st">&quot;user not found: &quot;</span> <span class="op">++</span> targetName</a>
<a class="sourceLine" id="cb1-21" title="21">    isTarget user <span class="ot">=</span> userName user <span class="op">==</span> targetName</a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="ot">logDebug ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-24" title="24">logDebug verbose msg <span class="ot">=</span> <span class="kw">if</span> verbose <span class="kw">then</span> <span class="fu">putStrLn</span> msg <span class="kw">else</span> <span class="fu">pure</span> ()</a></code></pre></div>
<p><span class="ascii">Slack</span>のようなチャットツールをイメージしてください。 該当の名前<span class="ascii">(</span><code>targetName</code><span class="ascii">)</span>を持つユーザーを与えると、そのユーザーが参加しているチャンネルの一覧を表示するというような振る舞いです。 こう段々になってしまうのは気持ち悪いですよね。 <span class="ascii">fallible</span>の目的はこの段々を次のように平坦にすることです<span class="ascii">(</span><code>where</code> などは割愛<span class="ascii">):</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Data.Fallible</span> (evalContT, exit, lift, (!?=), (???))</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Token</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-4" title="4">run targetName token verbose <span class="ot">=</span> evalContT <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-5" title="5">  users    <span class="ot">&lt;-</span> lift (getUsers token) <span class="op">!?=</span> exit <span class="op">.</span> logDebug&#39;</a>
<a class="sourceLine" id="cb2-6" title="6">  targetId <span class="ot">&lt;-</span> userId <span class="op">&lt;$&gt;</span> L.find isTarget users <span class="op">???</span> exit (logDebug&#39; emsg)</a>
<a class="sourceLine" id="cb2-7" title="7">  channels <span class="ot">&lt;-</span> lift (getChannels token) <span class="op">!?=</span> exit <span class="op">.</span> logDebug&#39;</a>
<a class="sourceLine" id="cb2-8" title="8">  lift <span class="op">$</span> <span class="fu">mapM_</span> (logDebug&#39; <span class="op">.</span> channelName) <span class="op">$</span></a>
<a class="sourceLine" id="cb2-9" title="9">    <span class="fu">filter</span> (<span class="fu">elem</span> targetId <span class="op">.</span> channelMembers) channels</a></code></pre></div>
<h3 id="やってること"><span class="link-to-here-outer"><a href="#やってること" title="やってること"><span class="link-to-here">Link to<br />
here</span></a></span>やってること</h3>
<p>というか、もともとのアイデアは下記のブログです<span class="ascii">:</span></p>
<ul>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html"><span class="ascii">ContT</span> を使ってコードを綺麗にしよう！ <span class="ascii">- BIGMOON Haskeller</span>’<span class="ascii">s BLOG</span></a></li>
</ul>
<p>これを一般化<span class="ascii">(</span><code>Maybe a</code> 固有ではなく <code>Either e a</code> でも使う<span class="ascii">)</span>できないかなぁというのがもともとの発想です。</p>
<h3 id="基本演算子"><span class="link-to-here-outer"><a href="#基本演算子" title="基本演算子"><span class="link-to-here">Link to<br />
here</span></a></span>基本演算子</h3>
<p>次の<span class="ascii">4</span>つの演算子を利用します<span class="ascii">:</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">(!?=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (<span class="dt">Either</span> e a) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">(!??) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">(??=) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Either</span> e a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">(???) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>ただし、内部実装的には <code>Maybe a</code> や <code>Either e a</code> は <code>Fallible</code> 型クラスで一般化されています<span class="ascii">:</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Fallible</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">type</span> <span class="dt">Failure</span><span class="ot"> f ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">  tryFallible ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Failure</span> f) a</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">instance</span> <span class="dt">Fallible</span> <span class="dt">Maybe</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="kw">type</span> <span class="dt">Failure</span> <span class="dt">Maybe</span> <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb4-7" title="7">  tryFallible <span class="ot">=</span> <span class="fu">maybe</span> (<span class="dt">Left</span> ()) <span class="dt">Right</span></a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">instance</span> <span class="dt">Fallible</span> (<span class="dt">Either</span> e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="kw">type</span> <span class="dt">Failure</span> (<span class="dt">Either</span> e) <span class="ot">=</span> e</a>
<a class="sourceLine" id="cb4-11" title="11">  tryFallible <span class="ot">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="ot">(!?=) ::</span> (<span class="dt">Monad</span> m, <span class="dt">Fallible</span> t) <span class="ot">=&gt;</span> m (t a) <span class="ot">-&gt;</span> (<span class="dt">Failure</span> t <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="ot">(???) ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Fallible</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>これらを継続モナドと組み合わせることで<span class="ascii">IO</span>と失敗系モナド<span class="ascii">(</span><code>Maybe a</code> や <code>Either e a</code><span class="ascii">)</span>を、モナドトランスフォーマーなしに<span class="ascii">Do</span>記法で書くことができます！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- 継続モナドに関する関数</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ot">evalConstT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ContT</span> r m r <span class="ot">-&gt;</span> m r</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">exit ::</span> m r <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a</a>
<a class="sourceLine" id="cb5-5" title="5">exit <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">.</span> <span class="fu">const</span></a></code></pre></div>
<h2 id="サンプルコード"><span class="link-to-here-outer"><a href="#サンプルコード" title="サンプルコード"><span class="link-to-here">Link to<br />
here</span></a></span>サンプルコード</h2>
<p>疑似的な<span class="ascii">IO</span>で良いなら<a href="https://github.com/matsubara0507/fallible/tree/master/example"><span class="ascii">fallible</span>リポジトリの<span class="ascii">example</span>ディレクトリ</a>にあります<span class="ascii">(</span>上述の例はそれです<span class="ascii">)</span>。</p>
<p>実際の利用例であれば、最近自作した<a href="https://github.com/matsubara0507/mixlogue"><span class="ascii">matsubara0507/mixlogue</span></a>という<span class="ascii">Haskell</span>アプリケーションで多用しています<span class="ascii">(</span><a href="https://github.com/matsubara0507/mixlogue/blob/8afd16ab4048ff62976b8e38347078fdaa7417dd/src/Mixlogue/Cmd.hs#L81-L93">ココ</a>とか<a href="https://github.com/matsubara0507/mixlogue/blob/8afd16ab4048ff62976b8e38347078fdaa7417dd/src/Mixlogue/Message.hs#L15-L25">ココ</a>とか<span class="ascii">)</span>。 ちなみに、<span class="ascii">mixlogue</span>は特定の<span class="ascii">Slack</span>の分報チャンネル<span class="ascii">(</span><code>times_hoge</code><span class="ascii">)</span>の発言を収集するというだけのツールです。</p>
<h2 id="使い方"><span class="link-to-here-outer"><a href="#使い方" title="使い方"><span class="link-to-here">Link to<br />
here</span></a></span>使い方</h2>
<p><span class="ascii">README</span>を参照してください。</p>
<p>現状<span class="ascii">Hackage</span>にはあげてないので、<span class="ascii">stack</span>や<span class="ascii">Cabal</span>で<span class="ascii">GitHub</span>リポジトリから参照する方法を利用してください。</p>
<h2 id="おしまい"><span class="link-to-here-outer"><a href="#おしまい" title="おしまい"><span class="link-to-here">Link to<br />
here</span></a></span>おしまい</h2>
<p><span class="ascii">fumieval</span>氏のコードをほとんど引用するだけになったので自分でリリースするか迷ったんですけど、リリースしてくれというのも丸投げがひどいので自分でリリースしました。 まぁこういう結果が生まれるのも<span class="ascii">OSS</span>コミュニティの醍醐味ということで。 <span class="ascii">fumieval</span>氏、いつもアドバイスをくれてありがとう！</p>
<p><span class="ascii">(</span>もちろん他の<span class="ascii">Haskell-jp</span>の皆さんも！<span class="ascii">)</span></p>
            </div>
        </div>
        <div id="post-navigation" class="row" style="margin-top: 20px;">
            <div class="col-lg-offset-2 col-lg-3 col-md-offset-1 col-md-4 col-xs-4">
                
                <i class="glyphicon glyphicon-chevron-left" aria-hidden="true" style="margin-right: 5px;"></i>
                <a href="/posts/2019/hiw-ghc8.8.html" lang="ja">HIW 2019で発表された、GHC 8.8で導入された機能</a>
                
            </div>
            <div class="col-lg-2 col-md-2 col-xs-4 text-center">
                <a href="/" lang="ja">トップに戻る</a>
            </div>
            <div class="col-lg-3 col-md-4 col-xs-4">
                
                <a href="/posts/2019/strip-ansi-escape.html" style="margin-left: auto;" lang="ja">strip-ansi-escapeというパッケージをリリースしました</a>
                <i class="glyphicon glyphicon-chevron-right" aria-hidden="true" style="margin-left: 5px;"></i>
                
            </div>
        </div>
    </div>
</article>

]]></summary>
</entry>

</feed>
